; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; the original Game Boy has DMA for sprite attributes, so we modify
; an attribute table in work RAM and copy it to OAM during vblank.
; this table has to be aligned to an 8-bit boundary because the DMA
; register only accepts a hi-byte and assumes $00 for the lo-byte
;
.RAMSECTION "Attrs" \
        SLOT "WRAMLO"   ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        attrs           INSTANCEOF Sprite 40
        ; number of sprites in use for the card-sprites:
        ; (doesn't include the cursor, so this maxes out at 38)
        used            BYTE
.ENDS

.RAMSECTION "DoDMA"     SLOT "HRAM"     RETURNORG
        doDMA           DSB 5
.ENDS

.SECTION "tiles_sprites" ALIGN 16
;///////////////////////////////////////////////////////////////////////////////

.DEF    SPRITE_PALLETE  %01001100

tiles_sprites:
;-------------------------------------------------------------------------------
.INCBIN "build/sprites.2bpp"            FSIZE tiles_sprites__size

; tile indices for the hand sprite:
.DEF    SPRITE_HAND_LHS         $00
.DEF    SPRITE_HAND_RHS         $08

; card back rows 1 & 2, column 1 (left)
.DEF    SPRITE_BACK_12X1        $68
; card back rows 1 & 2, column 2 (middle)
.DEF    SPRITE_BACK_12X2        $70
; card back rows 1 & 2, column 3 (right)
.DEF    SPRITE_BACK_12X3        $78
; card back rows 3 & 4, column 1 (left)
.DEF    SPRITE_BACK_34X1        $68+1
; card back rows 3 & 4, column 2 (middle)
.DEF    SPRITE_BACK_34X2        $70+1
; card back rows 3 & 4, column 3 (right)
.DEF    SPRITE_BACK_34X3        $78+1

; card rows 1 & 2, column 1 (left)
.DEF    SPRITE_CARD_12X1_A      $80
.DEF    SPRITE_CARD_12X1_2      $81
.DEF    SPRITE_CARD_12X1_3      $82
.DEF    SPRITE_CARD_12X1_4      $83
.DEF    SPRITE_CARD_12X1_5      $84
.DEF    SPRITE_CARD_12X1_6      $85
.DEF    SPRITE_CARD_12X1_7      $86
.DEF    SPRITE_CARD_12X1_8      $87
.DEF    SPRITE_CARD_12X1_9      $88
.DEF    SPRITE_CARD_12X1_10     $89
.DEF    SPRITE_CARD_12X1_J      $8a
.DEF    SPRITE_CARD_12X1_Q      $8b
.DEF    SPRITE_CARD_12X1_K      $8c
; card rows 1 & 2, column 2 (middle)
.DEF    SPRITE_CARD_12X2        $00+2
; card rows 1 & 2, column 3 (right)
.DEF    SPRITE_CARD_12X3_SPD    $48+3
.DEF    SPRITE_CARD_12X3_CLB    $50+3
.DEF    SPRITE_CARD_12X3_HRT    $58+3
.DEF    SPRITE_CARD_12X3_DMD    $60+3
; card rows 3 & 4, column 1 (left)
.DEF    SPRITE_CARD_34X1_SPD    $48+1
.DEF    SPRITE_CARD_34X1_CLB    $50+1
.DEF    SPRITE_CARD_34X1_HRT    $58+1
.DEF    SPRITE_CARD_34X1_DMD    $60+1
; card rows 3 & 4, column 2 (middle)
.DEF    SPRITE_CARD_34X2        $08+2
; card rows 3 & 4, column 3 (right)
.DEF    SPRITE_CARD_34X3_A      $00+4
.DEF    SPRITE_CARD_34X3_2      $08+4
.DEF    SPRITE_CARD_34X3_3      $10+4
.DEF    SPRITE_CARD_34X3_4      $18+4
.DEF    SPRITE_CARD_34X3_5      $20+4
.DEF    SPRITE_CARD_34X3_6      $28+4
.DEF    SPRITE_CARD_34X3_7      $30+4
.DEF    SPRITE_CARD_34X3_8      $38+4
.DEF    SPRITE_CARD_34X3_9      $40+4
.DEF    SPRITE_CARD_34X3_10     $48+4
.DEF    SPRITE_CARD_34X3_J      $50+4
.DEF    SPRITE_CARD_34X3_Q      $58+4
.DEF    SPRITE_CARD_34X3_K      $60+4

;///////////////////////////////////////////////////////////////////////////////
.ENDS

.include        "cursor.wla"    NAMESPACE "cursor"


init:
;===============================================================================
        ; copy the sprite tiles to VRAM:
        ld      HL,     tiles_sprites   ; set source address
        ld      DE,     VRAM_TILES1     ; set destination VRAM position
        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_sprites__size / 16) - 1
        call    tilemap.copyTiles

        call    clearAttrs
        call    cursor.init

        ; set sprite palettes:
        ld      A,      TILE_PALETTE
        ld      [OBP0], A
        ld      A,      SPRITE_PALLETE
        ld      [OBP1], A

        ld      HL,     LCDC
        set     2,      [HL]            ; enable 8x16 sprites
        set     1,      [HL]            ; switch sprites on
        
        ret


clearAttrs:
;===============================================================================
; clears the working copy of the sprite attributes:
; this will be uploaded to OAM on the next vblank
;
;-------------------------------------------------------------------------------
        ld      HL,     attrs
        ld      BC,     SECTIONEND_sprites.Attrs-SECTIONSTART_sprites.Attrs
        jp      zero


update:
;===============================================================================
; update sprites (during vblank):
;
;-------------------------------------------------------------------------------
        ; handle the cursor:
        call    cursor.update

        ; DMA the sprite attributes from work RAM into OAM:
        ;
        ; the DMA register only accepts 8-bits, which will
        ; be the hi-byte of the address to copy from
        ld      A,      >sprites.attrs
        
        ; whilst the DMA is occuring the CPU can only access HRAM,
        ; therefore we must initialise the DMA and wait via a routine
        ; running from HRAM. the routine has been copied into HRAM during
        ; `init_interrupts`. B must be set to the number of loop iterations
        ; to wait and C is set to the lo-byte of the DMA register
        ;
        ; despite using the information given here,
        ; <https://gbdev.io/pandocs/OAM_DMA_Transfer.html>,
        ; the BGB emulator would break on bad access during DMA
        ; unless the wait was increased from 40 ($28) to 41!
        ;
        ld      BC,     (41<<8) + <DMA
        call    sprites.doDMA

        ret


tilePosToScrXY:
;===============================================================================
; given a tile row/col, return the position in X/Y on-screen pixels:
; note that this accounts for the tilemap scroll offset
;
; in:   B       tilemap row position
;       C       tilemap column position
;
; out:  B       Y-position on screen (in pixels)
;       C       X-position on screen (in pixels)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        ; multiply row by 8:
        sla     B                       ; x2
        sla     B                       ; x4
        sla     B                       ; x8

        ; subtract the scroll offset:
        ;
        ; the difficulty here is that we can only subtract C from A, and *not*
        ; A from C which is the wrong way around for our numbers. we compensate
        ; for this by inverting and adding instead of subtracting
        ;
        ldh     A,      [<SCY]          ; read Y-scroll register through hi-RAM
        cpl                             ; invert the number (i.e. -A)
        add     A,      B
        add     A,      16              ; account for off-screen sprite space
        ld      B,      A               ; return value back in B

        ; multiply column by 8:
        sla     C                       ; x2
        sla     C                       ; x4
        sla     C                       ; x8
        ; subtract the scroll offset:
        ldh     A,      [<SCX]          ; read X-scroll register through hi-RAM
        cpl                             ; invert the number (i.e. -A)
        add     A,      C
        add     A,      8               ; account for off-screen sprite space
        ld      C,      A               ; return value back in C

        ret


cardToSprite:
;===============================================================================
; converts a card into a sprite and places it into the cursor's hand:
;
; in:   A       the card to create a sprite version of
;-------------------------------------------------------------------------------
        ; keep an original copy of the card value in E
        ld      E,      A

        xor     A
        ld      [used], A

        ; get starting X & Y position
        ld      HL,     cursor.cursor_y
        ld      B,      [HL]
        ld      HL,     cursor.cursor_x
        ld      C,      [HL]

        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      E
        and     %00001111               ; trim out the other bits
        add     TILE3X4_CARD_1X1-1      ; offset the tile with the ordinal
        ld      D,      A
        call    pushSprite
        ret


pushSprite:
;===============================================================================
; define a sprite's attributes, adding it to the screen:
;
; in:   BC      y & x position of sprite
;       D       tile-number of sprite
;-------------------------------------------------------------------------------
        push    AF

        ld      HL,     attrs           ; local sprite table
        ld      A,      [used]          ; get current available sprite index
        add     A,      2               ; (skip cursor sprites)
        rlca                            ; x2
        rlca                            ; x4 (4 bytes per sprite)
        add     A,      L               ; add to base address
        ld      A,      H               ; handle hi-byte...
        adc     0                       ; add the ripple
        ld      H,      A
        ; HL is the address of the sprite entry in the local sprite table
        ld      A,      B               ; y-position
        ld      [HL+],  A
        ld      A,      C               ; x-position
        ld      [HL+],  A
        pop     AF                      ; retrieve tile-index
        ld      [HL+],  A
        ld      A,      %00000000       ; display attributes
        ld      [HL+],  A
        
        ; move to next sprite slot
        ld      HL,     used
        inc     [HL]
        
        ret