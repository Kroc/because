; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; the original Game Boy has DMA for sprite attributes, so we modify
; an attribute table in work RAM and copy it to OAM during vblank.
; this table has to be aligned to an 8-bit boundary because the DMA
; register only accepts a hi-byte and assumes $00 for the lo-byte
;
.RAMSECTION "Attrs"     SLOT "WRAMLO" ALIGN 256         RETURNORG
        ;-----------------------------------------------------------------------
        attrs           INSTANCEOF Sprite 40            ; (160 bytes)
        ; how many sprites are free for use:
        ; the first two sprites must be the hand cursor, and the cards must be
        ; assigned from the last sprite downward for sprite-priority reasons
        free            BYTE
.ENDS

; a few bytes in HRAM need to be reserved to hold a wait loop
.RAMSECTION "DoDMA"     SLOT "HRAM"                     RETURNORG
        doDMA           DSB 5
.ENDS

.SECTION "tiles_sprites" ALIGN 16
;///////////////////////////////////////////////////////////////////////////////

.DEF    SPRITE_PALLETE  %01001100

tiles_sprites:
;-------------------------------------------------------------------------------
.INCBIN "build/sprites.2bpp"            FSIZE tiles_sprites__size

; tile indices for the hand sprite:
.DEF    SPRITE_HAND_LHS         $00
.DEF    SPRITE_HAND_RHS         $08
.DEF    SPRITE_HOLD_LHS         $00+2
.DEF    SPRITE_HOLD_RHS         $08+2

; card back rows 1 & 2, column 1 (left)
.DEF    SPRITE_BACK_12X1        $60+4
; card back rows 1 & 2, column 2 (middle)
.DEF    SPRITE_BACK_12X2        $68+4
; card back rows 1 & 2, column 3 (right)
.DEF    SPRITE_BACK_12X3        $70+4
; card back rows 3 & 4, column 1 (left)
.DEF    SPRITE_BACK_34X1        $60+6
; card back rows 3 & 4, column 2 (middle)
.DEF    SPRITE_BACK_34X2        $68+6
; card back rows 3 & 4, column 3 (right)
.DEF    SPRITE_BACK_34X3        $70+6

; card rows 1 & 2, column 1 (left)
.DEF    SPRITE_CARD_12X1        $10
.DEF    SPRITE_CARD_12X1_A      $10+0
.DEF    SPRITE_CARD_12X1_2      $10+2
.DEF    SPRITE_CARD_12X1_3      $10+4
.DEF    SPRITE_CARD_12X1_4      $10+6
.DEF    SPRITE_CARD_12X1_5      $10+8
.DEF    SPRITE_CARD_12X1_6      $10+10
.DEF    SPRITE_CARD_12X1_7      $10+12
.DEF    SPRITE_CARD_12X1_8      $10+14
.DEF    SPRITE_CARD_12X1_9      $10+16
.DEF    SPRITE_CARD_12X1_10     $10+18
.DEF    SPRITE_CARD_12X1_J      $10+20
.DEF    SPRITE_CARD_12X1_Q      $10+22
.DEF    SPRITE_CARD_12X1_K      $10+24
; card rows 1 & 2, column 2 (middle)
.DEF    SPRITE_CARD_12X2        $28+2
; card rows 1 & 2, column 3 (right)
.DEF    SPRITE_CARD_12X3        $30
.DEF    SPRITE_CARD_12X3_SPD    $30+0
.DEF    SPRITE_CARD_12X3_CLB    $30+2
.DEF    SPRITE_CARD_12X3_HRT    $30+4
.DEF    SPRITE_CARD_12X3_DMD    $30+6
; card rows 3 & 4, column 1 (left)
.DEF    SPRITE_CARD_34X1        $38
.DEF    SPRITE_CARD_34X1_SPD    $38+0
.DEF    SPRITE_CARD_34X1_CLB    $38+2
.DEF    SPRITE_CARD_34X1_HRT    $38+4
.DEF    SPRITE_CARD_34X1_DMD    $38+6
; card rows 3 & 4, column 2 (middle)
.DEF    SPRITE_CARD_34X2        $40
; card rows 3 & 4, column 3 (right)
.DEF    SPRITE_CARD_34X3        $48
.DEF    SPRITE_CARD_34X3_A      $48+0
.DEF    SPRITE_CARD_34X3_2      $48+2
.DEF    SPRITE_CARD_34X3_3      $48+4
.DEF    SPRITE_CARD_34X3_4      $48+6
.DEF    SPRITE_CARD_34X3_5      $48+8
.DEF    SPRITE_CARD_34X3_6      $48+10
.DEF    SPRITE_CARD_34X3_7      $48+12
.DEF    SPRITE_CARD_34X3_8      $48+14
.DEF    SPRITE_CARD_34X3_9      $48+16
.DEF    SPRITE_CARD_34X3_10     $48+18
.DEF    SPRITE_CARD_34X3_J      $48+20
.DEF    SPRITE_CARD_34X3_Q      $48+22
.DEF    SPRITE_CARD_34X3_K      $48+24

;///////////////////////////////////////////////////////////////////////////////
.ENDS

; default starting position of the cursor
; (for the GameBoy's screen)
.DEF    CURSOR_START_X  80
.DEF    CURSOR_START_Y  72

; (NOTE: don't cross an 8-bit boundary for a micro-optimisation)
;
.RAMSECTION "cursor"    SLOT "WRAMLO" BITWINDOW 8 RETURNORG
        ;-----------------------------------------------------------------------
        cursor_dest_x   BYTE            ; new X-position to move cursor to
        cursor_x        BYTE            ; current cursor X-position
        cursor_dest_y   BYTE            ; new Y-position to move cursor to
        cursor_y        BYTE            ; current cursor Y-position
.ENDS


init:
;===============================================================================
        ; copy the sprite tiles to VRAM:
        ld      HL,     tiles_sprites   ; set source address
        ld      DE,     VRAM_TILES1     ; set destination VRAM position
        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_sprites__size / 16) - 1
        call    tilemap.copyTiles

        ; clear all sprite attributes
        call    clearAttrs
        
        ; configure cursor:
        ;-----------------------------------------------------------------------
        ; clear variables:
        xor     A                       ; A = 0
        ld      HL,     SECTIONSTART_sprites.cursor
        ld      [HL+],  A               ; cursor_dest_x = 0
        ld      [HL+],  A               ; cursor_x = 0
        ld      [HL+],  A               ; cursor_dest_y = 0
        ld      [HL+],  A               ; cursor_y = 0

        ; configure the cursor sprite:
        ld      HL,     attrs
        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [cursor_y],             A
        ld      [cursor_dest_y],        A
        ld      [HL+],  A
        ld      A,      CURSOR_START_X  ; starting X-position
        ld      [cursor_x],             A
        ld      [cursor_dest_x],        A
        ld      [HL+],  A
        ld      A,      SPRITE_HAND_LHS ; tile-number
        ld      [HL+],  A
        ;;ld      A,      %00000000
        xor     A
        ld      [HL+],  A

        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [HL+],  A
        ld      A,      CURSOR_START_X + 8
        ld      [HL+],  A
        ld      A,      SPRITE_HAND_RHS ; tile-number
        ld      [HL+],  A
        ;;ld      A,      %00000000
        xor     A
        ld      [HL+],  A

        ; reset the sprites-in-use count
        ld      A,      38-1            ; (0-based)
        ld      [free], A

        ; set sprite palettes:
        ;-----------------------------------------------------------------------
        ld      A,      SPRITE_PALLETE
        ldh     [<OBP0], A
        ;;ld      A,      SPRITE_PALLETE
        ldh     [<OBP1], A

        ld      HL,     LCDC
        set     2,      [HL]            ; enable 8x16 sprites
        set     1,      [HL]            ; switch sprites on
        
        ret


clearAttrs:
;===============================================================================
; clears the working copy of the sprite attributes:
; this will be uploaded to OAM on the next vblank
;
;-------------------------------------------------------------------------------
        ld      HL,     attrs
        ld      BC,     SECTIONEND_sprites.Attrs-SECTIONSTART_sprites.Attrs
        jp      zero


clearCards:
;===============================================================================
; remove the cards held by the cursor:
;
;-------------------------------------------------------------------------------
        ; reset the hand sprite to the default cursor
        ld      A,              SPRITE_HAND_LHS
        ld      [attrs.1.tile], A
        ld      A,              SPRITE_HAND_RHS
        ld      [attrs.2.tile], A
        ; reset the index of the next free sprite (0-based)
        ld      A,      38-1
        ld      [free], A
        ; number of bytes to clear: 38 sprites
        ; (cursor sprites are excluded),
        ; times 4 bytes per sprite
        ld      BC,     38 * _sizeof_Sprite
        ; address of the third sprite in the local sprite table;
        ; the first two sprites are the hand cursor
        ld      HL,     attrs.3
        ; zero all the bytes
        jp      zero


update:
;===============================================================================
; update sprites (during vblank):
;
;-------------------------------------------------------------------------------
        ; handle the cursor:
        call    updateCursor

        ; DMA the sprite attributes from work RAM into OAM:
        ;
        ; the DMA register only accepts 8-bits, which will
        ; be the hi-byte of the address to copy from
        ld      A,      >attrs
        
        ; whilst the DMA is occuring the CPU can only access HRAM,
        ; therefore we must initialise the DMA and wait via a routine
        ; running from HRAM. the routine has been copied into HRAM during
        ; `init_interrupts`. B must be set to the number of loop iterations
        ; to wait and C is set to the lo-byte of the DMA register
        ;
        ; despite using the information given here,
        ; <https://gbdev.io/pandocs/OAM_DMA_Transfer.html>,
        ; the BGB emulator would break on bad access during DMA
        ; unless the wait was increased from 40 ($28) to 41!
        ;
        ld      BC,     (41<<8) + <DMA
        jp      doDMA                   ; this is in HRAM!


updateCursor:
;===============================================================================
; move the cursor one frame towards its destination:
;
; note that sprite position changes are written to the work RAM
; and this is automatically synced with OAM during vblank
;
; out:  BC, DE  (preserved)
;       HL, A   (clobbered)
;-------------------------------------------------------------------------------
        ; is the cursor in its intended X-position?
        ;
        ; the destination X-position and current X-position are next to each
        ; other in RAM; we subtract them from each other to check for any
        ; difference
        ld      HL,     sprites.cursor_dest_x   ; begin with destination X addr
        ld      A,      [HL+]           ; read and increment addr to current-X
        sub     A,      [HL]            ; subtract destination-X from current-X
        jr      z,      @y              ; if equal, no horizontal movement

        ; move in the X-direction:
        ; TODO: apply min/max speed?
        ;
        sra     A
        sra     A
        jr      nz,     +
        inc     A
+       add     A,      [HL]

        ld      [HL],                   A
        ld      [sprites.attrs.1.x],    A
        add     A,                      8
        ld      [sprites.attrs.2.x],    A

        ;-----------------------------------------------------------------------
@y:     inc     HL                      ; = cursor_dest_y
        ld      A,      [HL+]           ; read and increment addr to current-Y
        sub     A,      [HL]            ; subtract destination-Y from current-Y
        ret     z                       ; if equal, no vertical movement
        
        ; move in the Y-direction:
        ;
        sra     A
        sra     A
        jr      nz,     +
        inc     A
+       add     A,      [HL]

        ld      [HL],                   A
        ld      [sprites.attrs.1.y],    A
        ld      [sprites.attrs.2.y],    A

        ret


tilePosToScrXY:
;===============================================================================
; given a tile row/col, return the position in X/Y on-screen pixels:
; note that this accounts for the tilemap scroll offset
;
; in:   B       tilemap row position
;       C       tilemap column position
;
; out:  B       Y-position on screen (in pixels)
;       C       X-position on screen (in pixels)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        ; multiply row by 8:
        sla     B                       ; x2
        sla     B                       ; x4
        sla     B                       ; x8

        ; subtract the scroll offset:
        ;
        ; the difficulty here is that we can only subtract C from A, and *not*
        ; A from C which is the wrong way around for our numbers. we compensate
        ; for this by inverting and adding instead of subtracting
        ;
        ldh     A,      [<SCY]          ; read Y-scroll register through hi-RAM
        cpl                             ; invert the number (i.e. -A)
        add     A,      B
        add     A,      16              ; account for off-screen sprite space
        ld      B,      A               ; return value back in B

        ; multiply column by 8:
        sla     C                       ; x2
        sla     C                       ; x4
        sla     C                       ; x8
        ; subtract the scroll offset:
        ldh     A,      [<SCX]          ; read X-scroll register through hi-RAM
        cpl                             ; invert the number (i.e. -A)
        add     A,      C
        add     A,      8               ; account for off-screen sprite space
        ld      C,      A               ; return value back in C

        ret


moveCursorToTile:
;===============================================================================
; move the cursor to a given tile row/col:
; this is a tile position, NOT pixels
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       row position to move the cursor to
;       C       column position to move the cursor to
;
; out:  HL      (preserved)
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        ; convert the tile row/col to screen-space pixels
        call    tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        dec     C

        ; fall-through to set the cursor destination
        ;

moveCursorToScrXY:
;===============================================================================
; move the cursor to a specific X/Y position on the screen, in pixels:
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       Y position to move the cursor to
;       C       X position to move the cursor to
;
; out:  BC      (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; update the destination cursor position
        ld      HL,     cursor_dest_x
        ld      [HL],   C               ; set destination X-position
        inc     L
        inc     L
        ld      [HL],   B               ; set distination Y-position
        
        ret


cardToSprite:
;===============================================================================
; converts a card into a sprite and places it into the cursor's hand:
;
; in:   A       the card to create a sprite version of
;-------------------------------------------------------------------------------
        ; keep an original copy of the card value in E
        ld      E,      A

        ; clear the current card sprites
        ; (this must not clobber E)
        call    clearCards

        ; change the cursor
        ld      A,      $00+2
        ld      [attrs.1.tile], A
        ld      A,      $08+2
        ld      [attrs.2.tile], A

        ; get starting X & Y position
        ld      HL,     cursor_y
        ld      B,      [HL]
        ld      HL,     cursor_x
        ld      C,      [HL]

        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        call    @right
        ld      A,      E
        and     %00001111               ; trim out the other bits
        rlca
        ld      D,      A               ; save value for the botom-right
        add     SPRITE_CARD_12X1-2      ; offset the tile with the ordinal
        call    pushSprite

        ; top-middle:
        ;-----------------------------------------------------------------------
        call    @right
        ld      A,      SPRITE_CARD_12X2; this has a fixed sprite tile
        call    pushSprite

        ; top-right: suit
        ;-----------------------------------------------------------------------
        call    @right
        ld      A,      E
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca
        ld      E,      A               ; preserve this for the other corner
        add     SPRITE_CARD_12X3        ; (original value not needed again)
        call    pushSprite

        ; bottom-left:
        ;-----------------------------------------------------------------------
        call    @down
        ld      A,      E
        add     SPRITE_CARD_34X1
        call    pushSprite

        ; bottom-middle:
        ;-----------------------------------------------------------------------
        call    @right
        ld      A,      SPRITE_CARD_34X2
        call    pushSprite

        ; bottom-right: suit
        ;-----------------------------------------------------------------------
        call    @right
        ld      A,      D               ; retrieve suit from top-left corner
        add     SPRITE_CARD_34X3-2
        call    pushSprite

        ret

        ;-----------------------------------------------------------------------
        ; position next sprite to the right of the previous
@right: ld      A,      8
        add     A,      C
        ld      C,      A
        ret

        ; position next sprite on the next row
@down:  ld      A,      16              ; unlike BG tiles, sprites are 8x16
        add     A,      B
        ld      B,      A
        ld      A,      -16             ; move back from 3rd column to 1st
        add     A,      C
        ld      C,      A
        ret


pushSprite:
;===============================================================================
; define a sprite's attributes, adding it to the screen:
;
; in:   A       tile-number of sprite
;       BC      y & x position of sprite
;-------------------------------------------------------------------------------
        push    AF                      ; tile-number is not first

        ld      HL,     attrs.3         ; local sprite table
        ld      A,      [free]          ; get current available sprite index
        rlca                            ; x2
        rlca                            ; x4 (4 bytes per sprite)
        add     A,      L               ; add to base address
        ld      L,      A               ; update lo-byte
        ; HL is the address of the sprite entry in the local sprite table
        ld      A,      B               ; y-position
        ld      [HL+],  A
        ld      A,      C               ; x-position
        ld      [HL+],  A
        pop     AF                      ; retrieve tile-index
        ld      [HL+],  A
        ;;ld      A,      %00000000       ; display attributes
        xor     A
        ld      [HL+],  A
        
        ; move to next sprite slot
        ld      HL,     free
        dec     [HL]
        
        ret