; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2023:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
.DEF    GAME_NONE       0

.DEF    __game_id       1
.DEF    __game_priority 1000


.RAMSECTION "Game"                      RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        id              BYTE            ; index of current game being played
;;      start_seed      WORD            ; starting random seed of current game
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS

; each game defines an address to call to start the game;
; this table will be appended to by each game included
;
.SECTION "AddrInit"                     RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
addr_init:
;===============================================================================
        .ADDR           $0000           ;=GAME_NONE
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS

; each game defines an address to call when the player taps on a card
; this table will be appended to by each game included
;
; each game defines an address to call to start the game;
; this table will be appended to by each game included
;
; #FIXME: `SEMIFREE` here is a workaround for a bug
; where this section is being assigned to $0001!
;
.SECTION "AddrAction"                   SEMIFREE RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
addr_action:
;===============================================================================
        .ADDR           $0000           ;=GAME_NONE
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS

; include the games:
; the order of these includes determines their IDs!
;
.INC    "game_acesup.wla"       NAMESPACE "acesup"
.INC    "game_fortunes.wla"     NAMESPACE "fortunes"
.INC    "game_klondike.wla"     NAMESPACE "klondike"


init:
;===============================================================================
; start a game:
; 
; in:   A       ID of game to start (`GAME_*`)
;-------------------------------------------------------------------------------
        ld      [id],   A               ; set the game ID

        ; completely clear the table of cards, both the piles and the storage
        ; pool of all cards on the table. this will also clear the undo buffer
        call    tableau.init
        ; when the piles are cleared,
        ; the cursor's pile must be reallocated
        call    tableau.allocateCursorPile
        ; move the menu off-screen
        call    menu.hide

        ; start the specific game based on game ID:
        ;
        ld      A,      [id]
        ld      HL,     addr_init
        rst     rst_jumpTable

        ; fallthrough
        ; ...

play:
;===============================================================================
-       call    handleControls
        jr      -


handleControls:
;===============================================================================
; handles controller input:
;
; being a separate routine, we can just return after processing a button press,
; avoiding an additional jump outside of the switch block
;-------------------------------------------------------------------------------
        ; wait for a button press. this will halt the CPU
        ; between vblanks until a new button is pressed
        call    getButton

        bit     BUTTON_DOWN,    A       ; cursor down?
        jp      nz,     tableau.cursorDown

        bit     BUTTON_UP,      A       ; cursor up?
        jp      nz,     tableau.cursorUp

        bit     BUTTON_LEFT,    A       ; cursor left?
        jp      nz,     tableau.cursorLeft

        bit     BUTTON_RIGHT,   A       ; cursor right?
        jp      nz,     tableau.cursorRight

        bit     BUTTON_B,       A       ; B button?
        jp      nz,     doAction

        bit     BUTTON_A,       A       ; A button?
        jp      nz,     doUndo

        bit     BUTTON_START,   A       ; START button?
        jr      nz,     @menu

        ret

        ; show in-game menu:
        ;-----------------------------------------------------------------------
        ; TODO: when cards are in hand, these must be hidden
        ;       and then restored when the menu is closed
        ; TODO: also, handle if mid-animation when this happens!
        ;       (wait until move is complete?)
        ;
@menu:  call    menu.setGameOverMenu
        call    tilemap.update
        call    waitVBlank

        ; enter the menu; execution will hold there until the menu is cancelled
        ; or an option is selected in which case execution might never return!
        call    menu.show

        ; restore the card the cursor was pointing to
        call    tableau.resetCursorMode
        rst     tableau.rst_getPointPile
        jp      tableau.pointToPile


doAction:
;===============================================================================
; action button pressed; defer action to the specific game:
;-------------------------------------------------------------------------------
        ; retrieve the pile being pointed at (L)
        ; and the card-index (A) in that pile
        rst     tableau.rst_getPointPile
        ; parameters will be passed to the game via DE
        ld      D,      A               ; D = card-index (A)
        ld      E,      L               ; E = pile-index (L)
        ld      HL,     addr_action     ; table of game's `do_action` routines
        ld      A,      [id]            ; ID of currently running game
        ; (instead of using an RST instruction,
        ;  JP is used to do a tail-call)
        jp      rst_jumpTable           ; call game's `do_action` routine


doUndo:
;===============================================================================
; undoes the last move:
;-------------------------------------------------------------------------------
        call    undo.pop                ; retrieve the last move
        ret     c                       ; return if buffer empty

        call    undo.disable            ; don't add the move back
        call    tableau.movePileUndo    ;  to the undo buffer!
        call    undo.enable

        call    undo.isChained          ; check if the next undo is "chained"
        jr      nz,     doUndo          ; if so, also undo that

        ret