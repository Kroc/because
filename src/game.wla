; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
.ENUMID 0
.ENUMID GAME_NONE
.ENUMID GAME_ACESUP                     ; "Aces Up"
.ENUMID GAME_FORTUNES                   ; "Fortune's Favour"
.ENUMID GAME_KLONDIKE                   ; "Klondike"

.RAMSECTION "Game"                      RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        id              BYTE            ; index of current game being played
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS


init:
;===============================================================================
        call    sprites.init
        call    tilemap.init

        call    menu.hide

        call    acesup.init
        ;;call    fortunes.init
        ;;call    klondike.init

        ; fallthrough
        ; ...

play:
;===============================================================================
-       call    handleControls
        jr      -


handleControls:
;===============================================================================
; handles controller input:
;
; being a separate routine, we can just return after processing a button press,
; avoiding an additional jump outside of the switch block
;-------------------------------------------------------------------------------
        ; wait for a button press. this will halt the CPU
        ; between vblanks until a new button is pressed
        call    getButton

        bit     BUTTON_DOWN,    A       ; cursor down?
        jp      nz,     tableau.cursorDown

        bit     BUTTON_UP,      A       ; cursor up?
        jp      nz,     tableau.cursorUp

        bit     BUTTON_LEFT,    A       ; cursor left?
        jp      nz,     tableau.cursorLeft

        bit     BUTTON_RIGHT,   A       ; cursor right?
        jp      nz,     tableau.cursorRight

        bit     BUTTON_B,       A       ; B button?
        jp      nz,     doAction

        bit     BUTTON_A,       A       ; A button?
        jp      nz,     doUndo

        bit     BUTTON_START,   A       ; START button?
        jr      nz,     @menu

        ret

        ; show in-game menu:
        ;-----------------------------------------------------------------------
        ; TODO: when cards are in hand, these must be hidden
        ;       and then restored when the menu is closed
        ; TODO: also, handle if mid-animation when this happens!
        ;       (wait until move is complete?)
        ;
@menu:  call    menu.setGameOverMenu
        call    tilemap.update
        call    waitVBlank

        ; enter the menu; execution will hold there until the menu is cancelled
        ; or an option is selected in which case execution might never return!
        call    menu.show

        ; restore the card the cursor was pointing to
        call    tableau.resetCursorMode
        rst     tableau.rst_getPointPile
        jp      tableau.pointToPile


doAction
;===============================================================================
; action button pressed; defer action to the specific game:
;-------------------------------------------------------------------------------
        ld      HL,     id              ; ID of game currently running
        ld      C,      [HL]            ; (we will need to reuse HL & A)

        ; retrieve the pile being pointed at (L)
        ; and the card-index (A) in that pile
        rst     tableau.rst_getPointPile

        ; which game is currently running?
        dec     C                       ; was it `1`?
        jp      z,      acesup.tapCard

        jp      tableau.tapCard


doUndo:
;===============================================================================
; undoes the last move:
;-------------------------------------------------------------------------------
        call    undo.pop                ; retrieve the last move
        ret     c                       ; return if buffer empty

        call    undo.disable            ; don't add the move back
        call    tableau.movePileUndo    ;  to the undo buffer!
        call    undo.enable

        call    undo.isChained          ; check if the next undo is "chained"
        jr      nz,     doUndo          ; if so, also undo that

        ret