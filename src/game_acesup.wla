; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; create template card piles for the intial setup of the game
;-------------------------------------------------------------------------------
; this table must not cross a page boundary!
;
.SECTION \
        "piles"                 BITWINDOW 8

tableau.BeginPiles
        ; label,                type, max-cards,
        ; row,                  col,
        ; pile-left,            pile-right,
        ; pile-up,              pile-down
tableau.DefinePile \
        acesup_deck,            PILE_DECK, 52, \
        1,                      MENU_WIDTH + 1, \
        tableau.depot4,         tableau.depot1, \
        tableau.deck,           tableau.deck
tableau.DefinePile \
        acesup_depot1,          PILE_COLUMN, 13, \
        1,                      MENU_WIDTH + 5, \
        tableau.deck,           tableau.depot2, \
        tableau.depot1,         tableau.depot1
tableau.DefinePile \
        acesup_depot2,          PILE_COLUMN, 13, \
        1,                      MENU_WIDTH + 8 \
        tableau.depot1,         tableau.depot3, \
        tableau.depot2,         tableau.depot2
tableau.DefinePile \
        acesup_depot3,          PILE_COLUMN, 13, \
        1,                      MENU_WIDTH + 11 \
        tableau.depot2,         tableau.depot4, \
        tableau.depot3,         tableau.depot3
tableau.DefinePile \
        acesup_depot4,          PILE_COLUMN, 13, \
        1,                      MENU_WIDTH + 14 \
        tableau.depot3,         tableau.deck, \
        tableau.depot4,         tableau.depot4

.ENDS


init:
;===============================================================================
        rst     rst_waitVBlank
        
        ; temp: set scroll offset to move menu off-screen
        ld      A,      MENU_WIDTH * 8
        ldh     [<SCX], A
        xor     A
        ldh     [<SCY], A

        ; setup the playfield for the game
        ;-----------------------------------------------------------------------
        ; completely clear the table of cards, both the piles and the storage
        ; pool of all cards on the table. DE will be set to the beginning
        ; of the storage pool, as needed by the allocation routines
        ;
        call    tableau.clearPiles

        ; allocate the deck:
        ld      BC,     acesup_deck
        call    tableau.allocateDeck

        ; allocate the depots:
        ld      HL,     tableau.depot1
        call    tableau.allocatePile
        call    tableau.allocatePile    ; depot 2, 3 & 4 all follow in order,
        call    tableau.allocatePile    ; so we don't need to set HL & BC again
        call    tableau.allocatePile

        ;-----------------------------------------------------------------------
        ld      HL,     tableau.depot1
        ld      A,      CARD_K | SUIT_SPADE | CARD_BACK
        call    tableau.addCard
        ld      A,      CARD_K | SUIT_SPADE | CARD_BACK
        call    tableau.addCard
        ld      A,      CARD_K | SUIT_SPADE | CARD_BACK
        call    tableau.addCard
        ld      A,      CARD_K | SUIT_SPADE | CARD_BACK
        call    tableau.addCard
        ld      A,      CARD_K | SUIT_SPADE | CARD_BACK
        call    tableau.addCard
        ld      A,      CARD_K | SUIT_SPADE | CARD_BACK
        call    tableau.addCard

        ld      A,      CARD_K | SUIT_SPADE
        call    tableau.addCard
        ld      A,      CARD_Q | SUIT_HEART
        call    tableau.addCard
        ld      A,      CARD_J | SUIT_CLUB
        call    tableau.addCard
        ld      A,      CARD_X | SUIT_DIAMOND
        call    tableau.addCard
        ld      A,      CARD_9 | SUIT_SPADE
        call    tableau.addCard
        ld      A,      CARD_8 | SUIT_HEART
        call    tableau.addCard
        ld      A,      CARD_7 | SUIT_CLUB
        call    tableau.addCard
        ;;ld      A,      CARD_6 | SUIT_DIAMOND
        ;;call    tableau.addCard
        ;;ld      A,      CARD_5 | SUIT_SPADE
        ;;call    tableau.addCard
        ;;ld      A,      CARD_4 | SUIT_HEART
        ;;call    tableau.addCard
        ;;ld      A,      CARD_3 | SUIT_CLUB
        ;;call    tableau.addCard
        ;;ld      A,      CARD_2 | SUIT_DIAMOND
        ;;call    tableau.addCard
        ;;ld      A,      CARD_A | SUIT_SPADE
        ;;call    tableau.addCard

        ld      HL,     tableau.depot2
        ld      A,      CARD_J | SUIT_HEART
        call    tableau.addCard
        ld      HL,     tableau.depot3
        ld      A,      CARD_Q | SUIT_CLUB
        call    tableau.addCard
        ;;ld      HL,     tableau.depot4
        ;;ld      A,      CARD_K | SUIT_DIAMOND
        ;;call    tableau.addCard

        ;-----------------------------------------------------------------------
        ld      HL,     tableau.deck
        call    tableau.drawPile
        ld      HL,     tableau.depot1
        call    tableau.drawPile
        ld      HL,     tableau.depot2
        call    tableau.drawPile
        ld      HL,     tableau.depot3
        call    tableau.drawPile
        ld      HL,     tableau.depot4
        call    tableau.drawPile

        ;-----------------------------------------------------------------------
        rst     rst_screenOff
        call    tilemap.refresh
        rst     rst_screenOn
        
        ; move the cursor to the bottom card in the first depot pile
        ld      HL,     tableau.depot1
        call    tableau.pointToPile

        ; play loop:
        ;=======================================================================
@main:  call handleControls

        jp @main


handleControls:
;===============================================================================
; handles controller input:
;
; being a separate routine, we can just return after processing a button press,
; avoiding an additional jump outside of the switch block
;-------------------------------------------------------------------------------
        ; wait for a button press. this will halt the CPU
        ; between vblanks until a new button is pressed
        call    getButton

        ; cursor down?
        bit     BUTTON_DOWN,    A
        jr      z,      +

        jp      tableau.moveCursorDown

        ; cursor up?
+       bit     BUTTON_UP,      A
        jr      z,      +

        jp      tableau.moveCursorUp

        ; cursor left?
+       bit     BUTTON_LEFT,    A
        jr      z,      +

        jp      tableau.moveCursorLeft

        ; cursor right?
+       bit     BUTTON_RIGHT,   A
        jr      z,      +

        jp      tableau.moveCursorRight

        ; A button?
+       bit     BUTTON_A,       A
        jr      z,      +

        jp      tableau.pickCard

+       ret
