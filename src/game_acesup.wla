; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; create template card piles for the intial setup of the game:
;
;       .---.   .---. .---. .---. .---.
;       |DCK|   | D | | D | | D | | D |
;       |   |   | 1 | | 2 | | 3 | | 4 |
;       '---'   '---' '---' '---' '---'
;       .---.
;       |DSC|
;       |   |
;       '---'
;
.DEF    TYPE_DEPOT_ACESUP       TYPE_COLUMN | RULE_EXPOSED

piles.Begin
        ; label,                type, max-cards,
        ; row,                  col,
        ; pile-left,            pile-right,
        ; pile-up,              pile-down
piles.Define \
        acesup_deck,            TYPE_DECK, 52, \
        1,                      TABLEAU_LEFT + 1, \
        INDEX_DEPOT4,           INDEX_DEPOT1, \
        INDEX_DECK,             INDEX_DECK
piles.Define \
        acesup_discard,         TYPE_DISCARD | RULE_LOCKED, 52, \
        7,                      TABLEAU_LEFT + 1, \
        INDEX_DEPOT4,           INDEX_DEPOT1, \
        INDEX_DECK,             INDEX_DISCARD
piles.Define \
        acesup_depot1,          TYPE_DEPOT_ACESUP, 13, \
        1,                      TABLEAU_LEFT + 5, \
        INDEX_DECK,             INDEX_DEPOT2, \
        INDEX_DEPOT1,           INDEX_DEPOT1
piles.Define \
        acesup_depot2,          TYPE_DEPOT_ACESUP, 13, \
        1,                      TABLEAU_LEFT + 8 \
        INDEX_DEPOT1,           INDEX_DEPOT3, \
        INDEX_DEPOT2,           INDEX_DEPOT2
piles.Define \
        acesup_depot3,          TYPE_DEPOT_ACESUP, 13, \
        1,                      TABLEAU_LEFT + 11 \
        INDEX_DEPOT2,           INDEX_DEPOT4, \
        INDEX_DEPOT3,           INDEX_DEPOT3
piles.Define \
        acesup_depot4,          TYPE_DEPOT_ACESUP, 13, \
        1,                      TABLEAU_LEFT + 14 \
        INDEX_DEPOT3,           INDEX_DECK, \
        INDEX_DEPOT4,           INDEX_DEPOT4


init:
;===============================================================================
        call    waitVBlank
        
        ; temp: set scroll offset to move menu off-screen
        ld      A,      MENU_WIDTH * 8
        ldh     [<SCX], A
        xor     A
        ldh     [<SCY], A

        ; setup the tableau layout for the game
        ;-----------------------------------------------------------------------
        ; completely clear the table of cards, both the piles
        ; and the storage pool of all cards on the table
        ;
        call    piles.clear
        ; when the piles are cleared,
        ; the cursor's pile must be reallocated
        call    tableau.allocateCursorPile

        ld      BC,     acesup_deck
        call    piles.allocateDeck      ; allocate the deck,
        call    piles.allocate          ; and discard pile

        ; allocate the depots:
        ld      L,      INDEX_DEPOT1    ; (skip `INDEX_HAND`)
        call    piles.allocate
        call    piles.allocate          ; depot 2, 3 & 4 all follow in order,
        call    piles.allocate          ; so we don't need to set L & BC again
        call    piles.allocate

        ;-----------------------------------------------------------------------
        ld      L,      INDEX_DEPOT1
        ld      A,      CARD_J | SUIT_CLUB
        call    piles.pushCard
        ld      A,      CARD_3 | SUIT_SPADE
        call    piles.pushCard

        ld      L,      INDEX_DEPOT2
        ld      A,      CARD_X | SUIT_HEART
        call    piles.pushCard
        ld      A,      CARD_4 | SUIT_SPADE
        call    piles.pushCard

        ld      L,      INDEX_DEPOT3
        ld      A,      CARD_2 | SUIT_SPADE
        call    piles.pushCard
        ld      A,      CARD_6 | SUIT_CLUB
        call    piles.pushCard

        ld      L,      INDEX_DEPOT4
        ld      A,      CARD_A | SUIT_SPADE
        call    piles.pushCard
        ld      A,      CARD_3 | SUIT_DIAMOND
        call    piles.pushCard

        ;-----------------------------------------------------------------------
        call    tableau.refresh
        call    screenOff
        call    tilemap.refresh
        call    screenOn

        ; everything ready, set this as the current running game
        ld      HL,     game_id
        ld      [HL],   GAME_ACESUP

        ; move the cursor to the bottom card in the first depot pile
        ld      L,      INDEX_DEPOT1
        jp      tableau.pointToPile


tapCard:
;===============================================================================
; in:   L       index (`INDEX_*`) of pile pointed at
;       A       index of card pointed at in that pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; which pile was tapped?
        ;
        ; for Aces Up we happen to know that the only column
        ; piles are the depots and those are our main concern
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     tapCard_deck

        ; fall through to below for
        ; handling depots
        ;

tapCard_depot:
;===============================================================================
; in:   L       index (`INDEX_*`) of pile pointed at
;       A       index of card pointed at in that pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; tapped on a depot -- only the top-most
        ; card is enabled so auto-play that card:
        ;
        ; we need to compare our card with the
        ; other depots so put its value aside:
        rst     piles.rst_cardAddr      ; get addr (DE) of the card index (A)
        ld      H,      A               ; presere index (for moving cards)
        ld      A,      [DE]            ; get value of the card
        and     MASK_VALUE              ; isolate suit+rank bits
        ld      B,      A               ; B = tapped card value
        push    HL                      ; preserve pile (L) & card index (H)

        ; check the depots:
        ;-----------------------------------------------------------------------
        ; is our card lower than any other card of the same suit on top of
        ; the other depots? we don't make an effort to avoid checking the
        ; same depot as our card as it won't be considered lower
        ;
        ; since only Aces Up uses this type of validation (so far), we know
        ; we don't need to check the validation-type of every other pile;
        ; just the first four depots are relevant
        ;
        ; note that once a valid match has been found (c+),
        ; we skip checking the other depots (`call nc, ...`)
        ;
        ld      L,      INDEX_DEPOT1
        call            @cp
        ld      L,      INDEX_DEPOT2
        call    nc,     @cp
        ld      L,      INDEX_DEPOT3
        call    nc,     @cp
        ld      L,      INDEX_DEPOT4
        call    nc,     @cp

        ; if carry is set, the tapped card is the same suit
        ; and lower in rank than another card on the tableau
        ;
        ; TODO:
        pop     HL                      ; retrieve the source pile again
        ld      A,      H               ; card index was put in H
        ld      E,      INDEX_DISCARD
        call    tableau.movePile

        ; TODO: move the cursor to the new position

        ret

        ;-----------------------------------------------------------------------
        ; compare cards:
        ;
        ; given the pile to compare *against*,
        ; fetch the top card of *that* pile
        ;
@cp:    call    piles.getLastCard       ; addr of last card in search depot

        ; compare suits:
        ;
        ; we compare suits using XOR so that carry is
        ; unaffected. if the suits match, zero is set
        ;
        ld      A,      [DE]            ; read the last card in the pile
        xor     B                       ; combine with the tapped card
        and     MASK_SUIT               ; mask out irrelevant bits
        ret     nz                      ; exit (c-) if they don't match

        ; compare ranks:
        ;
        ; unfortunately we have our registers back-to-front so that,
        ; if were were to put the original rank in C, we'd be looking
        ; for the higher value, not the lower one. do some register
        ; juggling to get the comparison the right way around...
        ;
        ld      A,      [DE]            ; read the last depot card
        sub     2                       ; wrap A low to A high!
        and     MASK_RANK               ; (isolate the rank)
        ld      C,      A               ; swap sides

        ld      A,      B               ; get our original card again
        sub     2                       ; wrap A low to A high!
        and     MASK_RANK               ; (isolate the rank)
        cp      C                       ; if depot card is higher,
        ret                             ;  return carry!


tapCard_deck:
;===============================================================================
; in:   L       index (`INDEX_*`) of pile pointed at
;       A       index of card pointed at in that pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ret


;;validatePile:
;===============================================================================
; validate lowest rank of each suit:
;
; in:   L       pile index (`INDEX_*`)
; out:  L       (preserved)
;-----------------------------------------------------------------------------
;;        ; the routine must return the original pile index
;;        ; as it's being used as the counter over all piles
;;        push    HL
;;        
;;        ; validate top-card:
;;        ;=====================================================================
;;        ; since only the top-most card requires specific validation,
;;        ; we start with the last card in the pile
;;        rst     piles.rst_pileCount
;;        ld      C,      A               ; use card count as 1-based counter
;;        dec     A                       ; adjust index to 0-based for access
;;        rst     piles.rst_cardAddr      ; get address of last card into DE
;;
;;        ; we need to compare our card with the other depots;
;;        ; first extract the suit; we can't use the rank yet
;;        ld      A,      [DE]            ; get value of last card
;;        and     MASK_SUIT               ; isolate suit bits
;;        ld      B,      A               ; B = source suit
;;
;;        ; check the depots:
;;        ;---------------------------------------------------------------------
;;        ; is our card lower than any other card of the same suit on top of
;;        ; the other depots? we don't make an effort to avoid checking the
;;        ; same depot as our card as it won't be considered lower
;;        ;
;;        ; since only Aces Up uses this type of validation (so far), we know
;;        ; we don't need to check the validation-type of every other pile;
;;        ; just the first four depots are relevant
;;        ;
;;        ; note that once a valid match has been found (c+),
;;        ; we skip checking the other depots (`call nc, ...`)
;;        ld      L,      INDEX_DEPOT1
;;        call            @cp
;;        ld      L,      INDEX_DEPOT2
;;        call    nc,     @cp
;;        ld      L,      INDEX_DEPOT3
;;        call    nc,     @cp
;;        ld      L,      INDEX_DEPOT4
;;        call    nc,     @cp
;;
;;        ; read the source card value once more
;;        ld      A,      [DE]
;;        ; flip the carry due to the $80->$00
;;        ; ordering of the tiles in VRAM
;;        ccf
;;        ; shift the carry (result bit) into bit 0,
;;        ; pushing the old disabled bit off
;;        rla
;;        ; now rotate the byte back so that bit 0
;;        ; (the new disabled bit) becomes bit 7
;;        rrca
;;        ; finally, update the pile
;;        ; with the validation result
;;        ld      [DE],   A
;;
;;        ; all other cards in the pile are automatically invalid:
;;        ;=====================================================================
;;-       dec     C                       ; decrement card count
;;        jr      z,      +               ; stop once we hit zero
;;        dec     DE                      ; move to the previous card in RAM
;;        ld      A,      [DE]            ; read the card value
;;        or      CARD_DISABLED           ; set the disabled bit
;;        ld      [DE],   A               ; write back the updated card
;;        jr      -
;;
;;+       pop     HL                      ; return original pile index
;;        ret
;;
;;        ;=====================================================================
;;        ; compare cards:
;;        ;
;;        ; given the Pile to compare *against*, fetch the top card
;;        ; of *that* pile. we have to preserve DE whilst doing this
;;        ;
;;@cp:    rst     piles.rst_pileCount     ; number of cards in pile, 1-based
;;        ret     z                       ; skip depot if empty!
;;        dec     A                       ; correct count to 0-based
;;        push    AF
;;        ld      H,      FIELD_POOL_LO   ; switch field
;;        ld      A,      [HL]            ; read pool-addr lo-byte
;;        ld      H,      FIELD_POOL_HI   ; switch field
;;        ld      H,      [HL]            ; read pool-addr hi-byte
;;        ld      L,      A
;;        pop     AF
;;        add     A,      L
;;        ld      L,      A
;;        jr      nc,     +
;;        inc     H
;;+       ld      A,      [HL]            ; read the last card in the pile
;;
;;        ; compare suits:
;;        ;
;;        ; we compare suits using XOR so that carry is
;;        ; unaffected. if the suits match, zero is set
;;        and     MASK_SUIT
;;        xor     B                       ; compare suits
;;        ret     nz                      ; exit if they don't match
;;
;;        ; compare ranks:
;;        ;
;;        ; unfortunately we have our registers back-to-front so that,
;;        ; if were were to put the original rank in C, we'd be looking
;;        ; for the higher value, not the lower one. do some register
;;        ; juggling to get the comparison the right way around...
;;        ;
;;        push    BC
;;
;;        ld      A,      [HL]            ; read the last depot card
;;        sub     2                       ; wrap A low to A high!
;;        and     MASK_RANK               ; (isolate the rank)
;;        ld      C,      A               ; swap sides
;;
;;        ld      A,      [DE]            ; get our original card again
;;        sub     2                       ; wrap A low to A high!
;;        and     MASK_RANK               ; (isolate the rank)
;;
;;        cp      C                       ; if depot card is higher,
;;
;;        pop     BC
;;        ret                             ; return carry!

