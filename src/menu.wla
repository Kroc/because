; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; in-game menu:
;
;       +--------------------+
;       | IMPATIENCE         | <- current game name
;       |                    |
;       | @ CHANGE GAME      | <- change between games: Aces Up, Klondike &c.
;       |                    |
;       | @ RESTART          | <- replay the game using the same cards
;       |                    |
;       | @ OPTIONS          | <- configuration, about &c.
;       |                    |
;       +--------------------+
;
; game-over menu:
;
;       +--------------------+
;       |      GAME OVER     |
;       |                    |
;       | @ DEAL NEW         | <- start a new deal of the same game
;       |                    |
;       | @ RETRY SAME       | <- play the same deal (seed) again
;       |                    |
;       | @ CHANGE GAME      | <- change to a different card game
;       |                    |
;       +--------------------+
;
.DEF    MENU_WIDTH      TILEMAP_WIDTH
.DEF    MENU_HEIGHT     10
.DEF    MENU_ADDR       tilemap.front_buffer

.DEF    MENU_ITEM0_POS  (3 << 8) | 1    ; row & column of first menu item

.ENUMID 0
.ENUMID MENU_MAIN                       ; the main menu
.ENUMID MENU_GAMEOVER                   ; the game-over menu

.RAMSECTION "Menu"      RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        menu            BYTE            ; which menu is in use
        selected        BYTE            ; which menu item is currently selected
        items           BYTE            ; number of menu items (1-based)
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS


_strings:
;-------------------------------------------------------------------------------
; padding spaces are used to overwrite any previous string
; without leaving trailing garbage
@impatience:
        .str    "impatience  "
@change_game:
        .str    "change game "
@restart_game:
        .str    "restart game"
@options:
        .str    "options     "
@game_over:
        .str    "game over   "
@deal:
        .str    "deal new    "
@retry:
        .str    "retry same  "


clear:
;===============================================================================
; erase the menu area, leaving it blank:
;
; NOTE: does not refresh the screen; this routine only clears and redraws
;       the menu on the back-buffer. call `tilemap.update` to send the
;       changes to VRAM during the next v-blank
;
;-------------------------------------------------------------------------------
        ; reset menu state
        ld      A,              3       ; number of menu items, 1-based
        ld      [items],        A
        xor     A                       ; set A to zero
        ld      [selected],     A       ; select first menu item by default

        ; (menu background tile)
        ld      A,      TILE_MENU_BG
        ; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32
        ; scrollable region. since the tableu may need to scroll a bit,
        ; we place the menu above the playfield
        ld      HL,     tilemap.front_buffer

        ; even though the screen is 20 out of 32 tiles wide, we fill the whole
        ; width to ensure the menu area remains white if the tableu scrolls
        ;
        ; TODO: 10 rows is 320 tiles, so call fill (256), plus 64 remainder.
        ;       we should calculate this at assemble-time
        call    fill
        jp      fill@x64


setMainMenu:
;===============================================================================
; write the menu options for the main menu screen:
;-------------------------------------------------------------------------------
        call    clear

        ; record that we are using the main menu
        ;;ld      A,      MENU_MAIN
        xor     A                       ; (MENU_MAIN = 0)
        ld      [menu], A

        ; TODO: tilemap updates
        ;
        ; print the title:
        ld      HL,     MENU_ADDR + (1 * TILEMAP_WIDTH) + 1
        ld      DE,     _strings@impatience
        call    printStr

        ; change game:
        ld      HL,     MENU_ADDR + (3 * TILEMAP_WIDTH) + 3
        ld      DE,     _strings@change_game
        call    printStr

        ; restart game:
        ld      HL,     MENU_ADDR + (5 * TILEMAP_WIDTH) + 3
        ld      DE,     _strings@restart_game
        call    printStr

        ; options:
        ld      HL,     MENU_ADDR + (7 * TILEMAP_WIDTH) + 3
        ld      DE,     _strings@options
        jp      printStr


setGameOverMenu:
;===============================================================================
; write the menu options for the game-over menu screen:
;-------------------------------------------------------------------------------
        call    clear

        ; record that we are using the game-over menu
        ld      A,      MENU_GAMEOVER
        ld      [menu], A

        ; TODO: tilemap updates
        ;
        ; print the title:
        ld      HL,     MENU_ADDR + (1 * TILEMAP_WIDTH) + 1
        ld      DE,     _strings@game_over
        call    printStr

        ; deal new:
        ld      HL,     MENU_ADDR + (3 * TILEMAP_WIDTH) + 3
        ld      DE,     _strings@deal
        call    printStr

        ; retry same:
        ld      HL,     MENU_ADDR + (5 * TILEMAP_WIDTH) + 3
        ld      DE,     _strings@retry
        call    printStr

        ; change game:
        ld      HL,     MENU_ADDR + (7 * TILEMAP_WIDTH) + 3
        ld      DE,     _strings@change_game
        jp      printStr


show:
;===============================================================================
; switches control to the menu:
;-------------------------------------------------------------------------------
        ; wait for v-blank to change the screen scroll:
        ; TODO: shadow registers should be used for scrolling
        ;
        call    waitVBlank

        ; scroll to the top of the tilemap to reveal the menu
        ;
        xor     A                       ; set A to zero
        ldh     [<SCY], A
        ldh     [<SCX], A

        ; move the cursor to the first menu item
        ;
        xor     A
        call    pointToItem

        ;-----------------------------------------------------------------------
        ; wait for a button press. this will halt the CPU
        ; between vblanks until a new button is pressed
@wait:  call    getButton

        ; pressing START or A will close the menu
        ;
        bit     BUTTON_START,   A
        jr      nz,     hide
        bit     BUTTON_A,       A
        jr      nz,     hide

        ; handle cursor movement control
        call    handleControls
        jr      @wait


handleControls:
        ;=======================================================================
        ; d-pad up:
        ;-----------------------------------------------------------------------
        bit     BUTTON_UP,      A
        jr      z,      ++

        ld      A,      [selected]      ; currently selected menu item
        and     A                       ; set flags; =0?
        jr      nz,     +
        ld      A,      3               ; loop back to the last menu item
+       dec     A                       ; move to previous menu item
        jr      pointToItem             ;  and point to that

        ; d-pad down:
        ;-----------------------------------------------------------------------
++      bit     BUTTON_DOWN,    A
        ret     z

        ld      A,      [selected]      ; currently selected menu item
        inc     A                       ; move to next
        cp      3                       ; reached the end?
        jr      c,      pointToItem     ; if not, use the new index
        xor     A                       ; loop back to first menu item (0)
        
        ; and point to that
        ; (fallthrough)
        ; ...

pointToItem:
;===============================================================================
; in:   A       index of menu item to point to, 0 is first
;-------------------------------------------------------------------------------
        ld      [selected],     A       ; retain menu index

        ld      BC,     MENU_ITEM0_POS  ; start with first menu item X/Y
        sla     A                       ; 2 rows per menu item
        add     B                       ; add to row number
        ld      B,      A
        call    sprites.tilePosToScrXY  ; convert row/column to px
        dec     B
        dec     B
        call    cursor.moveToScrXY

        ld      A,      CURSOR_RIGHT
        call    cursor.setSprite
        jp      sprites.update


hide:
;===============================================================================
; relinquish control of the menu, returning to the tableau:
;===============================================================================
        ; wait for v-blank to change the screen scroll:
        ; TODO: shadow registers should be used for scrolling
        ;
        call    waitVBlank

        ; scroll to the top of the tableau to hide the menu
        ld      A,      8 * MENU_HEIGHT
        ldh     [<SCY], A
        xor     A
        ldh     [<SCX], A

        ret