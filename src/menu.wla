; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; menu-items:
;
;       +--------------------+
;       | IMPATIENCE         | <- current game name
;       |                    |
;       |   CHANGE GAME      | <- change between games Aces Up, Klondike &c.
;       |                    |
;       |   RESTART GAME     | <- replay the game using the same cards
;       |                    |
;       |   OPTIONS          | < - configuration, about &c.
;       |                    |
;       +--------------------+
;
.DEF    MENU_WIDTH      TILEMAP_WIDTH
.DEF    MENU_HEIGHT     10
.DEF    MENU_ADDR       tilemap.front_buffer


clear:
;===============================================================================
; clears the menu, setting it back to its default display:
;
; NOTE: does not refresh the screen; this routine only clears and redraws
;       the menu on the back-buffer. call `tilemap.update` to send the
;       changes to VRAM during the next v-blank
;
;-------------------------------------------------------------------------------
        ; (menu background tile)
        ld      A,      TILE_MENU_BG
        ; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32
        ; scrollable region. since the tableu may need to scroll a bit,
        ; we place the menu above the playfield
        ld      HL,     tilemap.front_buffer

        ; even though the screen is 20 out of 32 tiles wide, we fill the whole
        ; width to ensure the menu area remains white if the tableu scrolls
        ;
        ; TODO: 10 rows is 320 tiles, so call fill (256), plus 64 remainder.
        ;       we should calculate this at assemble-time
        call    fill
        call    fill@x64

        ; print the title:
        ld      HL,     MENU_ADDR + (1 * TILEMAP_WIDTH) + 1
        ld      DE,     @impatience
        call    printStr

        ; change game:
        ld      HL,     MENU_ADDR + (3 * TILEMAP_WIDTH) + 3
        ld      DE,     @change_game
        call    printStr

        ; restart game:
        ld      HL,     MENU_ADDR + (5 * TILEMAP_WIDTH) + 3
        ld      DE,     @restart_game
        call    printStr

        ; options:
        ld      HL,     MENU_ADDR + (7 * TILEMAP_WIDTH) + 3
        ld      DE,     @options
        call    printStr

        ret

; strings:
;-------------------------------------------------------------------------------
@impatience:
        .str    "impatience"
@change_game:
        .str    "change game"
@restart_game:
        .str    "restart game"
@options:
        .str    "options"


show:
;===============================================================================
; switches control to the menu:
;-------------------------------------------------------------------------------
        ; wait for v-blank to change the screen scroll:
        ; TODO: shadow registers should be used for scrolling
        ;
        call    waitVBlank

        ; scroll to the top of the tilemap to reveal the menu
        ;
        xor     A                       ; set A to zero
        ldh     [<SCY], A
        ldh     [<SCX], A

        ; move the cursor to the menu item
        ;
        ld      A,      CURSOR_RIGHT
        call    cursor.setSprite
        ld      BC,     (3 << 8) | 1
        call    sprites.tilePosToScrXY
        dec     B
        dec     B
        call    cursor.moveToScrXY

        ; fallthrough
        ; ...

handleControls:
;===============================================================================
        ; wait for a button press. this will halt the CPU
        ; between vblanks until a new button is pressed
        call    getButton

        bit     BUTTON_START,   A
        jp      nz,     hide

        jr      handleControls


hide:
;===============================================================================
; relinquishes control of the menu, returning to the tableau:
;===============================================================================
        ; wait for v-blank to change the screen scroll:
        ; TODO: shadow registers should be used for scrolling
        ;
        call    waitVBlank

        ; scroll to the top of the tableau to hide the menu
        ld      A,      8 * MENU_HEIGHT
        ldh     [<SCY], A
        xor     A
        ldh     [<SCX], A

        ret