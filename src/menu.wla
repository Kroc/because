; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; menu-items:
;
;       +--------------------+
;       | IMPATIENCE         | <- current game name
;       |                    |
;       | @ CHANGE GAME      | <- change between games: Aces Up, Klondike &c.
;       |                    |
;       | @ RESTART          | <- replay the game using the same cards
;       |                    |
;       | @ OPTIONS          | < - configuration, about &c.
;       |                    |
;       +--------------------+
;
;       +--------------------+
;       |      GAME OVER     |
;       |                    |
;       | @ PLAY             |
;       |                    |
;       | @ RETRY            |
;       |                    |
;       | @ CHANGE GAME      |
;       |                    |
;       +--------------------+
;
.DEF    MENU_WIDTH      TILEMAP_WIDTH
.DEF    MENU_HEIGHT     10
.DEF    MENU_ADDR       tilemap.front_buffer

.DEF    MENU_ITEM0_POS  (3 << 8) | 1    ; row & column of first menu item


.RAMSECTION "Menu"      RETURNORG
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
        selected        BYTE            ; which menu item is currently selected
        items           BYTE            ; number of menu items (0-based)
;:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
.ENDS


clear:
;===============================================================================
; clears the menu, setting it back to its default display:
;
; NOTE: does not refresh the screen; this routine only clears and redraws
;       the menu on the back-buffer. call `tilemap.update` to send the
;       changes to VRAM during the next v-blank
;
;-------------------------------------------------------------------------------
        ; rest menu state
        ld      A,              2       ; number of menu items
        ld      [items],        A
        xor     A                       ; set A to zero
        ld      [selected],     A       ; select first menu item by default

        ; (menu background tile)
        ld      A,      TILE_MENU_BG
        ; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32
        ; scrollable region. since the tableu may need to scroll a bit,
        ; we place the menu above the playfield
        ld      HL,     tilemap.front_buffer

        ; even though the screen is 20 out of 32 tiles wide, we fill the whole
        ; width to ensure the menu area remains white if the tableu scrolls
        ;
        ; TODO: 10 rows is 320 tiles, so call fill (256), plus 64 remainder.
        ;       we should calculate this at assemble-time
        call    fill
        call    fill@x64

        ; print the title:
        ld      HL,     MENU_ADDR + (1 * TILEMAP_WIDTH) + 1
        ld      DE,     @impatience
        call    printStr

        ; change game:
        ld      HL,     MENU_ADDR + (3 * TILEMAP_WIDTH) + 3
        ld      DE,     @change_game
        call    printStr

        ; restart game:
        ld      HL,     MENU_ADDR + (5 * TILEMAP_WIDTH) + 3
        ld      DE,     @restart_game
        call    printStr

        ; options:
        ld      HL,     MENU_ADDR + (7 * TILEMAP_WIDTH) + 3
        ld      DE,     @options
        call    printStr

        ret

; strings:
;-------------------------------------------------------------------------------
@impatience:
        .str    "impatience"
@change_game:
        .str    "change game"
@restart_game:
        .str    "restart game"
@options:
        .str    "options"


show:
;===============================================================================
; switches control to the menu:
;-------------------------------------------------------------------------------
        ; wait for v-blank to change the screen scroll:
        ; TODO: shadow registers should be used for scrolling
        ;
        call    waitVBlank

        ; scroll to the top of the tilemap to reveal the menu
        ;
        xor     A                       ; set A to zero
        ldh     [<SCY], A
        ldh     [<SCX], A

        ; move the cursor to the first menu item
        ;
        xor     A
        call    pointToItem

        ; wait for a button press. this will halt the CPU
        ; between vblanks until a new button is pressed
@wait:  call    getButton

        ; pressing START or A will close the menu
        ;
        bit     BUTTON_START,   A
        jr      nz,     hide
        bit     BUTTON_A,       A
        jr      nz,     hide

        ; handle cursor movement control
        call    handleControls
        jr      @wait


handleControls:
;===============================================================================
        ; d-pad up:
        ;-----------------------------------------------------------------------
        bit     BUTTON_UP,      A
        jr      z,      ++

        ld      A,      [selected]      ; currently selected menu item
        and     A                       ; set flags; =0?
        jr      nz,     +
        ld      A,      3               ; loop back to the last menu item
+       dec     A                       ; move to previous menu item
        jr      pointToItem             ;  and point to that

        ; d-pad down:
        ;-----------------------------------------------------------------------
++      bit     BUTTON_DOWN,    A
        ret     z

        ld      A,      [selected]      ; currently selected menu item
        inc     A                       ; move to next
        cp      3                       ; reached the end?
        jr      c,      pointToItem     ; if not, use the new index
        xor     A                       ; loop back to first menu item (0)
        
        ; and point to that
        ; (fallthrough)
        ; ...

pointToItem:
;===============================================================================
; in:   A       index of menu item to point to, 0 is first
;-------------------------------------------------------------------------------
        ld      [selected],     A       ; retain menu index

        ld      BC,     MENU_ITEM0_POS  ; start with first menu item X/Y
        sla     A                       ; 2 rows per menu item
        add     B                       ; add to row number
        ld      B,      A
        call    sprites.tilePosToScrXY  ; convert row/column to px
        dec     B
        dec     B
        call    cursor.moveToScrXY

        ld      A,      CURSOR_RIGHT
        call    cursor.setSprite
        jp      sprites.update


hide:
;===============================================================================
; relinquishes control of the menu, returning to the tableau:
;===============================================================================
        ; wait for v-blank to change the screen scroll:
        ; TODO: shadow registers should be used for scrolling
        ;
        call    waitVBlank

        ; scroll to the top of the tableau to hide the menu
        ld      A,      8 * MENU_HEIGHT
        ldh     [<SCY], A
        xor     A
        ldh     [<SCX], A

        ret