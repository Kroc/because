; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
.CODE

clear:
;===============================================================================
; clears the playfield area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ; the background tile indices are 'signed', so what we think of as
        ; the first tile, tile "0", is tile # "-128", i.e $80
        ld      A,      $80
        ; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32
        ; playfield. for our purposes we place the menu on the left and
        ; the playfield next to it, therefore the playfield begins at
        ; X = 12 and not the top-left (X = 0)
        ld      HL,     gfx.front_buffer + 12
        ; number of tiles to skip to next row
        ld      DE,     32-20

        ;-----------------------------------------------------------------------
        ld      C,      32      ; 32 rows
@row:   ld      B,      20      ; 20 columns (13...32)
@col:   ld      [HL+],  A       ; set cell to empty background tile
        dec     B
        jr      nz, @col
        
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


draw_deck:
;===============================================================================
; draws the deck on the back-buffer:
;
;-------------------------------------------------------------------------------
        ld      HL,     cards.deck.addr ; address of deck pile
        ld      E,      [HL]            ; read cards-address, lo-byte
        inc     L
        ld      D,      [HL]            ; read cards-address, hi-byte
        inc     L
        ld      B,      [HL]            ; read row
        inc     L
        ld      C,      [HL]            ; read column

        ; NOTE: by incrementing L here, we have automatically moved onto the
        ;       next Pile structure. by returning this HL value, the caller
        ;       can draw multiple piles that follow one another (e.g tableau)
        inc     L
        push    HL

        ; draw deck:
        ;-----------------------------------------------------------------------
        ; read the card-count from the first-byte in the pile's card pool.
        ; if the deck is empty, draw its outline instead
        ld      A,      [DE]
        and     A,      A               ; set flags!
        jr      z,      draw_empty
        
        ; get an address in the front-buffer for the X/Y co-ords
        dec     B
        call    gfx.get_buffer_addr
        ld      DE,     tilemap_deck     
        call    gfx.write_tiles_3wide_5rows

        ;-----------------------------------------------------------------------
        pop     HL
        ret


draw_empty:
;===============================================================================
        call    gfx.get_buffer_addr
        ld      DE,     tilemap_empty     
        call    gfx.write_tiles_3wide_4rows

        ;-----------------------------------------------------------------------
        pop     HL
        ret

draw_pile:
;===============================================================================
; draws a pile on the back-buffer:
;
; in:   HL      address of the Pile structure
;
; out:  HL      HL is moved forward on to the next Pile structure
;       DE      the front-buffer address of the row *below* the pile drawn
;-------------------------------------------------------------------------------
        inc     HL                      ; skip over the max-cards byte
        ld      E,      [HL]            ; read cards-address, lo-byte
        inc     L
        ld      D,      [HL]            ; read cards-address, hi-byte
        inc     L
        ld      B,      [HL]            ; read row
        inc     L
        ld      C,      [HL]            ; read column 

        ; NOTE: by incrementing L here, we have automatically moved onto the
        ;       next Pile structure. by returning this HL value, the caller
        ;       can draw multiple piles that follow one another (e.g tableau)
        inc     L
        push    HL

        ; draw pile:
        ;-----------------------------------------------------------------------
        ; read the card-count from the first-byte in the pile's card pool.
        ; if the pile is empty, draw its outline instead
        ld      A,      [DE]
        and     A,      A               ; set flags!
        jr      z,      draw_empty

        ; get an address in the front-buffer for the X/Y co-ords
        call    gfx.get_buffer_addr

        ; TODO: begin drawing cards
        ld      DE,     tilemap_back
        call    gfx.write_tiles_3wide_4rows
        
        ;-----------------------------------------------------------------------
        pop     HL                      ; return next Pile address
        ret