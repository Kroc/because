; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; for brevity, the undo buffer doesn't store every card moved but instead
; the source & destination pile indices and the starting card index; however
; the move required to undo the change is stored instead of the actual action
; taken -- therefore the undo buffer is a list of pile moves to do that reverse
; the actions that were taken by the player!
;
.RAMSECTION "Undo"      RETURNORG
        ;-----------------------------------------------------------------------
        moves           BYTE            ; current undo level (number of moves)

        ; we only want to record the card movements between piles, not the
        ; moves to/from the cursor's hand so we need somewhere to remember
        ; the details after picking up cards until the cards have been dropped
        tmp_src         BYTE
        tmp_dst         BYTE
        tmp_idx         BYTE

        disabled        BYTE            ; flag to ignore adding undo moves
.ENDS

.RAMSECTION "UndoBuff"  ALIGN 256 RETURNORG
        undo_src        DSB 256
        undo_dst        DSB 256
        undo_idx        DSB 256
.ENDS


init:
;===============================================================================
clear:
;===============================================================================
; clear the undo buffer:
;-------------------------------------------------------------------------------
        xor     A                       ; (set A to zero)
        ld      [moves],        A       ; reset number of undo moves
        ld      [tmp_src],      A
        ld      [tmp_dst],      A
        ld      [tmp_idx],      A
        ld      [disabled],     A       ; clear disabled flag

        ld      HL,     SECTIONSTART_undo.UndoBuff
        call    fill                    ; clear undo moves source piles
        call    fill                    ; clear undo moves dest. piles
        jp      fill                    ; clear undo moves card indices


enable:
;===============================================================================
; enable pushing/popping moves to/from the undo buffer:
;
; out:  *       (preserved)
;-------------------------------------------------------------------------------
        push    AF
        xor     A
        ld      [disabled],     A
        pop     AF
        ret


disable:
;===============================================================================
; surpress pushing/popping moves to/from the undo buffer:
;
; out:  *       (preserved)
;-------------------------------------------------------------------------------
        push    AF
        ld      A,      $ff
        ld      [disabled],     A
        pop     AF
        ret


push:
;===============================================================================
; adds a move to the undo buffer:
;
; the undo data must already be set in the variables
; `tmp_src`, `tmp_dst` & `tmp_idx`
;
; out:  HL      (preserved)
;       BC, DE  (preserved)
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        ; if undo is surpressed, do nothing:
        ;
        ld      A,      [disabled]      ; check undo-disabled flag
        and     A                       ; (set flags!)
        ret     nz                      ; exit if flag is non-zero

        ; sanity check: ignore if source & destination are the same;
        ; this can happen if you pick up cards from a pile and drop
        ; them back on the same pile
        ;
        ld      A,      [tmp_src]       ; undo source pile
        ld      L,      A
        ld      A,      [tmp_dst]       ; undo destination pile
        cp      L                       ; one and the same?
        ret     z                       ; return early if same

        ;----------------------------------------------------------------------
        push    HL                      ; preserve incoming HL

        ld      HL,     moves           ; increment the undo moves counter
        inc     [HL]

        ; TODO: when the buffer fills we need to shift it down

        ld      L,      [HL]
        ld      H,      >undo_src

        ld      A,      [tmp_src]
        ld      [HL],   A
        inc     H
        ld      A,      [tmp_dst]
        ld      [HL],   A
        inc     H
        ld      A,      [tmp_idx]
        ld      [HL],   A

        pop     HL                      ; restore HL
        ret


chain:
;===============================================================================
; links the previous undo move to the next one so that they undo together:
;
;-------------------------------------------------------------------------------
        ; if undo is surpressed, do nothing:
        ;
        ld      A,      [disabled]      ; check undo-disabled flag
        and     A                       ; (set flags!)
        ret     nz                      ; exit if flag is non-zero

        ; set the hi-bit on the undo move source index
        ; (indicates a chain of moves)
        ;-----------------------------------------------------------------------
        push    HL

        ld      HL,     moves
        ld      L,      [HL]
        ld      H,      >undo_src

        set     7,      [HL]

        pop     HL
        ret


isChained:
;===============================================================================
; is the current move atop the undo buffer chained?
;
; out:  z       zero-flag is CLEAR (`nz`) if move is chained
;       *       (preserved)
;-------------------------------------------------------------------------------
        push    HL

        ld      HL,     moves
        ld      L,      [HL]
        ld      H,      >undo_src
        bit     7,      [HL]

        pop     HL
        ret


pop:
;===============================================================================
; pops a move from the undo buffer:
;
; this doesn't move any cards (see "tableau.wla" instead),
; only returns the data and decrements the internal pointer
;
; out:  carry   clear = OK, set = buffer is empty
;       L       source pile index
;       E       destination pile index
;       A       card index in source pile
;       D       bit 7 is set if this move is chained with the next
;       BC      (preserved)
;       H       (clobbered)
;-------------------------------------------------------------------------------
        ; if undo is surpressed, do nothing:
        ;
        ld      A,      [disabled]      ; check undo-disabled flag
        and     A                       ; (set flags!)
        ret     nz                      ; exit if flag is non-zero

        ld      D,      A               ; A is zero so clear chain flag now

        ; get the current position in the undo buffer (and decrement it)
        ;-----------------------------------------------------------------------
        ld      A,      [moves]         ; undo buffer move count
        and     A,      A               ; check for zero; buffer empty?
        scf                             ; (return carry set for error)
        ret     z                       ; return with carry set
        ld      L,      A               ; set index into the buffer

        dec     A                       ; decremement the undo index
        ld      [moves],A               ; write back to the variable

        ; read the undo data:
        ;-----------------------------------------------------------------------
        ld      H,      >undo_dst
        ld      E,      [HL]
        ld      H,      >undo_idx
        ld      A,      [HL]
        ld      H,      >undo_src
        ld      L,      [HL]

        ; move the chain flag into D:
        ;-----------------------------------------------------------------------
        sla     L                       ; take bit-7 from source index
        rr      D                       ; shift carry into D, clear carry
        rr      L                       ; fix source index

        ;-----------------------------------------------------------------------
        ret                             ;  return carry clear = OK