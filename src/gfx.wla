; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt

; since we cannot modify VRAM during the display period,
; changes are queued up and then applied during vblank
;
.RAMSECTION     "tile_queue"    RETURNORG
        tile_queue      DSB 126
.ENDS

.RAMSECTION     "buffers"       ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        front_buffer    DSB 32*32
        back_buffer     DSB 32*32
.ENDS

.SECTION        "code"

init:
;===============================================================================
; to get this project started, this sample code taken from:
; https://gist.github.com/iamgreaser/9cccd24dd4519a0ae95240d8b8eeb252
; (will be replaced soon)
;
;-------------------------------------------------------------------------------
        ; configure LCD:
	ld 	A, 	[LCDC]		; read the current LCD config

	; we *MUST NOT* disable the LCD (bit7=1) outside of vblank!
	; even though we want the screen off during initialisation,
	; we must set the LCD enable bit to 1 at this time and instead
	; rely on a vblank routine to turn it on / off when desired
	;
	and 	LCDC.lcd_enable		; enable LCD
	or	LCDC.window_select	; use $9C00 for the window-map
	or  	LCDC.bg_display		; turn background on
	ld 	[LCDC],	A

	call screen_off

	; clear VRAM
        ;-----------------------------------------------------------------------
	ld 	HL, 	VRAM
	xor 	A
-	ld 	[HL], 	A
	inc 	HL
	bit 	5,	H
	jp 	z, -

        ;-----------------------------------------------------------------------
	call    clear_queue             ; clear the tile update queue
        call	copy_main_tileset	; copy main tileset from ROM to VRAM
        
	call	clear_playfield		; clear the playfield background
	call    clear_menu		; clear and draw the menu

        call    refresh_vram

	; set palette:
	ld	A,	%11000110
	ld 	[BGP], 	A

	call screen_on
	ret


clear_queue:
;===============================================================================
; empty the tile-update queue, used to defer VRAM changes to vblank:
;
;-------------------------------------------------------------------------------
        ; starting address of tile queue
        ld      C,      <tile_queue
        ld      B,      _sizeof_tile_queue+1

-       ldh     [C],    A               ; write 0 to queue
        inc     C                       ; move to next byte in queue
        dec     B                       ; one less byte to process
        jr      nz, -                   ; keep going?
        
        ret


wait_for_vblank:
;===============================================================================
; TODO: this is battery draining, keeping the CPU in spinlock;
;       replace this with a HALT & IRQ approach
;-------------------------------------------------------------------------------
-	ld	A,      [LY]
	cp	145
	jr 	nz, -

        ret


screen_on:
;===============================================================================
; turns the screen on; we do not have to wait for vblank to do this
;
; out:  A       (preserved)
;-------------------------------------------------------------------------------
	push	AF
	ld 	A,	[LCDC]
	set 	7,	A
	ld 	[LCDC], A

+	pop	AF
	ret


screen_off:
;===============================================================================
; turns the screen off, holding execution until safe to do so
;
;
; out:  A       (preserved)
;-------------------------------------------------------------------------------
	push 	AF
	ld 	A,	[LCDC]
	bit 	7,	A
	jr 	z, +
	
	call    wait_for_vblank

	ld	A,	[LCDC]
	res	7, 	A
	ld	[LCDC], A

+	pop 	AF
	ret


copy_main_tileset:
;===============================================================================
; copy the main tileset used throughout the game:
; TODO: check vblank/lcd-stat for safety
;       on CGB, we can use DMA to do this
;
;-------------------------------------------------------------------------------
        ld      HL,     tiles_main      ; set source address
        ld      DE,     VRAM_TILES2     ; set destination VRAM position

        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_main__size / 16) - 1


copy_tiles:
;===============================================================================
; copy a number of graphic tiles to VRAM:
;
; in:   HL      starting address of tiles
;       DE      VRAM destination, e.g. $8000
;       B       number of tiles to copy, 1-based
;               use "0" for 256 tiles
;
; TODO: on GBC we could do this using DMA?
;-------------------------------------------------------------------------------
@copy:  .REPEAT 16
                ld      A,      [HL+]
                ld      [DE],   A
                inc     DE
        .ENDR

        dec     B
        jr      nz, @copy
        
        ret


clear_menu:
;===============================================================================
; clears the menu, setting it back to its default display:
;
;-------------------------------------------------------------------------------
        ; "2nd" tile (the menu background)
        ld      A,      $81
        ; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32
        ; scrollable region. for our purposes we place the menu on
        ; the left of the playfield
        ld      HL,     front_buffer
        ; number of tiles to skip to next row
        ld      DE,     32-12

        ;-----------------------------------------------------------------------
        ld      C,      32      ; 32 rows
@row:   ld      B,      12      ; 12 columns
@col:   ld      [HL+],  A       ; set cell to menu background tile
        dec     B
        jr      nz, @col
        
        ; we only clear 12 out of 32 tiles,
        ; so move to the next row by skipping some
        add     HL,     DE

        dec     C
        jr      nz, @row

        ; print the title:
        ld      HL,     front_buffer + 32 + 1
        ld      DE,     @impatience
        call    print_str

        ; TODO: print the menu:

        ret

@impatience:
        .str    "impatience"


clear_playfield:
;===============================================================================
; clears the playfield area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ; the background tile indices are 'signed', so what we think of as
        ; the first tile, tile "0", is tile # "-128", i.e $80
        ld      A,      $80
        ; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32
        ; playfield. for our purposes we place the menu on the left and
        ; the playfield next to it, therefore the playfield begins at
        ; X = 12 and not the top-left (X = 0)
        ld      HL,     front_buffer + 12
        ; number of tiles to skip to next row
        ld      DE,     32-20

        ;-----------------------------------------------------------------------
        ld      C,      32      ; 32 rows
@row:   ld      B,      20      ; 20 columns (13...32)
@col:   ld      [HL+],  A       ; set cell to empty background tile
        dec     B
        jr      nz, @col
        
        ; we only clear 20 out of 32 tiles,
        ; so move to the next row by skipping some
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


refresh_vram:
;===============================================================================
; forces a full update of VRAM:
;
; normally updates to VRAM are done partially -- only the tiles that have
; changed between the front & back buffers are written during vblank
;
; a full update copies the current front buffer to the back buffer, then
; the full back buffer is copied to VRAM in one go. the screen cannot be
; on whilst this happens as writes to VRAM outside of vblank are ignored
;-------------------------------------------------------------------------------
        ; copy front buffer to back buffer:
        ;
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        call    @copy

        ; copy back buffer to VRAM:
        ;
        ; on the GameBoy, VRAM is memory-mapped,
        ; though it is inaccessible outside of vblank
        ;
        ld      HL,     back_buffer
        ld      DE,     VRAM_MAP1

        ;-----------------------------------------------------------------------
@copy:  ld      C,      0

-       ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     DE
        dec     C
        jr      nz, -

        ret


refresh_screen:
;===============================================================================
; compares the differences between the front & back buffers, and generates
; the list of VRAM changes (tile queue) to make during vblank
;
.ENDS