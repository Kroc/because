; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt

; since we cannot modify VRAM during the display period,
; changes are queued up and then applied during vblank
;
.RAMSECTION     "tile_queue"                    RETURNORG
        ;-----------------------------------------------------------------------
        queue_index     BYTE            ; current stack-level of the queue
        tile_queue      DSB 126
.ENDS

.RAMSECTION     "buffers"       ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        front_buffer    DSB 32*32
        back_buffer     DSB 32*32
.ENDS

.CODE

init:
;===============================================================================
; to get this project started, this sample code taken from:
; https://gist.github.com/iamgreaser/9cccd24dd4519a0ae95240d8b8eeb252
; (will be replaced soon)
;
;-------------------------------------------------------------------------------
        ; configure LCD:
	ld 	A, 	[LCDC]		; read the current LCD config

	; we *MUST NOT* disable the LCD (bit7=1) outside of vblank!
	; even though we want the screen off during initialisation,
	; we must set the LCD enable bit to 1 at this time and instead
	; rely on a vblank routine to turn it on / off when desired
	;
	and 	LCDC.lcd_enable		; enable LCD
	or	LCDC.window_select	; use $9C00 for the window-map
	or  	LCDC.bg_display		; turn background on
	ld 	[LCDC],	A               ; write settings to LCD register

	call screen_off

	; clear VRAM
        ;-----------------------------------------------------------------------
	ld 	HL, 	VRAM
	xor 	A                       ; (set A to 0)
-	ld 	[HL+],  A
	bit 	5,	H
	jr 	z, -

        ;-----------------------------------------------------------------------
	call    clear_queue             ; clear the tile update queue
        call	copy_main_tileset	; copy main tileset from ROM to VRAM
        
	call	playfield.clear		; clear the playfield background
	call    menu.clear		; clear and draw the menu

        call    refresh_vram

	; set palette:
	ld	A,	%11000110
	ld 	[BGP], 	A

	call screen_on
	ret


clear_queue:
;===============================================================================
; empty the tile-update queue, used to defer VRAM changes to vblank:
;
;-------------------------------------------------------------------------------
        ; starting address of tile queue
        ld      C,      <tile_queue
        ld      HL,     queue_index
        ld      [HL],   C

        ld      B,      _sizeof_tile_queue+1
-       ld      [$FF00+C],      A       ; write 0 to queue
        inc     C                       ; move to next byte in queue
        dec     B                       ; one less byte to process
        jr      nz, -                   ; keep going?
        
        ret


wait_for_vblank:
;===============================================================================
; TODO: this is battery draining, keeping the CPU in spinlock;
;       replace this with a HALT & IRQ approach
;-------------------------------------------------------------------------------
-	ld	A,      [LY]
	cp	145
	jr 	nz, -

        ret


screen_on:
;===============================================================================
; turns the screen on; we do not have to wait for vblank to do this
;
; out:  A       (preserved)
;-------------------------------------------------------------------------------
	push	AF
	ld 	A,	[LCDC]
	set 	7,	A
	ld 	[LCDC], A

+	pop	AF
	ret


screen_off:
;===============================================================================
; turns the screen off, holding execution until safe to do so
;
; out:  A       (preserved)
;-------------------------------------------------------------------------------
	push 	AF
	ld 	A,	[LCDC]
	bit 	7,	A
	jr 	z, +
	
	call    wait_for_vblank

	ld	A,	[LCDC]
	res	7, 	A
	ld	[LCDC], A

+	pop 	AF
	ret


copy_main_tileset:
;===============================================================================
; copy the main tileset used throughout the game:
;
; TODO: check vblank/lcd-stat for safety on CGB, we can use DMA to do this
;-------------------------------------------------------------------------------
        ld      HL,     tiles_main      ; set source address
        ld      DE,     VRAM_TILES2     ; set destination VRAM position

        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_main__size / 16) - 1


copy_tiles:
;===============================================================================
; copy a number of graphic tiles to VRAM:
;
; in:   HL      starting address of tiles
;       DE      VRAM destination, e.g. $8000
;       B       number of tiles to copy, 1-based
;               use "0" for 256 tiles
;
; TODO: on GBC we could do this using DMA?
;-------------------------------------------------------------------------------
@copy:  .REPEAT 16
                ld      A,      [HL+]
                ld      [DE],   A
                inc     DE
        .ENDR

        dec     B
        jr      nz, @copy
        
        ret


get_buffer_addr:
;===============================================================================
; given an X & Y co-ordinate, return an address in the front-buffer:
;
; in:   B       y-position (row) in the tile-map (32x32)
;       C       x-position (column) in the tile-map (32x32)
;
; out:  HL      address within the front-buffer                         
;       A, DE   (preserved)                                             
;       BC      (clobbered)                                             ;cycles
;-------------------------------------------------------------------------------
        ; we need to multiply Y (row) by 32                             ;   =24
        ld      H,      0               ; prepare HL,                   ;+ 8=32
        ld      L,      B               ; with row-number only          ;+ 4=36

        ; TODO: use a lookup table of rows (just 64 bytes!)
        ;
        add     HL,     HL              ; x2                            ;+ 8=44
        add     HL,     HL              ; x4                            ;+ 8=52
        add     HL,     HL              ; x8                            ;+ 8=60
        add     HL,     HL              ; x16                           ;+ 8=68
        add     HL,     HL              ; x32                           ;+ 8=76
        
        ld      B,      0               ; prepare BC with column only   ;+ 8=84
        add     HL,     BC              ; add the column                ;+ 8=92
        ld      BC,     front_buffer    ; get front-buffer address      ;+12=104
        add     HL,     BC              ; finally, add our offset       ;+ 8=112

        ret                                                             ;+16=128


write_tiles_3wide_5rows:
;===============================================================================
        ld      BC,     29
        call    write_tiles_3wide

write_tiles_3wide_4rows:
;===============================================================================
        ld      BC,     29
        call    write_tiles_3wide

write_tiles_3wide_3rows:
;===============================================================================
        ld      BC,     29
        call    write_tiles_3wide

write_tiles_3wide_2rows:
;===============================================================================
        ld      BC,     29
        call    write_tiles_3wide

write_tiles_3wide_1row:
;===============================================================================
        ld      BC,     29

write_tiles_3wide:
;===============================================================================
; in:   BC      number of tiles to skip for next row, should be set to 29
;       DE      address with tiles to read from
;       HL      address to write to, where 3 tiles are written and then
;               the address is moved to the next row of the tilemap
;-------------------------------------------------------------------------------
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        add     HL,     BC

        ret


refresh_vram:
;===============================================================================
; forces a full update of VRAM:
;
; normally updates to VRAM are done partially -- only the tiles that have
; changed between the front & back buffers are written during vblank
;
; a full update copies the current front buffer to the back buffer, then
; the full back buffer is copied to VRAM in one go. the screen cannot be
; on whilst this happens as writes to VRAM outside of vblank are ignored
;
; TODO: on GBC we can use DMA
;-------------------------------------------------------------------------------
        ; clear the update queue to prevent changes to VRAM during vblank
        call    clear_queue

        ; copy front buffer to back buffer:
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        call    @copy

        ; copy back buffer to VRAM:
        ;
        ; on the GameBoy, VRAM is memory-mapped,
        ; though it is inaccessible outside of vblank
        ;
        ld      HL,     back_buffer
        ld      DE,     VRAM_MAP1

        ; copy 1'024 bytes:
        ;-----------------------------------------------------------------------
@copy:  ld      C,      0

-       ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     DE
        dec     C
        jr      nz, -

        ret


refresh_screen:
;===============================================================================
; compares the differences between the front & back buffers, and generates
; the list of VRAM changes (tile queue) to make during vblank
;
;-------------------------------------------------------------------------------
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        ld      BC,     _sizeof_front_buffer+1

        ; (jump into the functional part of the loop)
        jr      @read
        
        ;-----------------------------------------------------------------------
@next:  dec     BC                      ; one less tile to process...
        ret     z                       ; all done? exit

        inc     DE                      ; move forward in the back-buffer
        inc     HL                      ; and keep the front-buffer in step 

        ; loop begins here...
        ;
@read:  ld      A,      [DE]            ; read tile from back-buffer
        cp      [HL]                    ; compare with front-buffer
        jr      z, @next                ; if they're the same, keep scanning

        ; there's a difference!
        ; queue the tile change:
        ;
        push    BC                      ; (backup current index)
        push    HL                      ; (backup front buffer position)

        push    AF                      ; backup the tile
        
        ; calculate the VRAM address from our current index
        ; in the front & back buffers...
        ld      HL,     VRAM_MAP1
        add     HL,     BC              ; (only HL can do 16-bit adds)
        push    HL

        ; disable vblank interrupts whilst we update the queue; we don't want
        ; the queue being emptied whilst we're writing to it!
        ;
        ld      A,      [INTERRUPT_ENABLE]
        and     IE.vblank^$ff           ; exclude the vblank bit
        ld      [INTERRUPT_ENABLE],     A

        ; get current update queue position:
        ; TODO: handle queue overflow. stop processing buffers, and wait
        ;       for vblank so that the queue can be refilled again?
        ld      HL,     queue_index
        inc     [HL]                    ; move to the next queue slot
        ld      C,      [HL]            ; read the current queue index

        ; we need to write three bytes to the queue:
        ;
        pop     HL                      ; retrieve VRAM address
        ld      A,              H 
        ld      [$FF00+C],      A       ; write hi-byte
        ld      A,              L
        ld      [$FF00+C],      A       ; write lo-byte

        pop     AF                      ; retrieve tile to draw
        ld      [$FF00+C],      A

        ; re-enable vblank interrupts:
        ;
        ld      A,      [INTERRUPT_ENABLE]
        or      IE.vblank
        ld      [INTERRUPT_ENABLE],     A

        pop     HL                      ; (restore front buffer position)
        pop     BC                      ; (restore current buffer position)
        jr      @next
