; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
.BANK 0

; a few bytes in HRAM need to be reserved to hold a wait loop
.RAMSECTION "DoDMA"     SLOT "HRAM"     RETURNORG
        doDMA           DSB 5
.ENDS

; since we cannot modify VRAM during the display period,
; changes are queued up and then applied during vblank
;
.STRUCT TileUpdate
        vram_addr       WORD
        tile            BYTE
        flags           BYTE
.ENDST

.DEF    QUEUE_SIZE      32

; (NOTE: we rely on this starting at an $xx00 address for optimisation)
.RAMSECTION "Queue"     ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        tile_queue      INSTANCEOF TileUpdate QUEUE_SIZE
.ENDS

.RAMSECTION "QReady"    SLOT "HRAM"     RETURNORG
        ; a flag to indicate that tiles are waiting to be processed
        queue_ready     BYTE
.ENDS

; these are the *logical* button constants for the game, not the ones used by
; the hardware, which are split across two bytes. these are `bit` numbers
;
.DEF    BUTTON_RIGHT            0
.DEF    BUTTON_LEFT             1
.DEF    BUTTON_UP               2
.DEF    BUTTON_DOWN             3
.DEF    BUTTON_A                4
.DEF    BUTTON_B                5
.DEF    BUTTON_SELECT           6
.DEF    BUTTON_START            7

; RAM for remembering joypad state:
;
.RAMSECTION "Joypad"            RETURNORG
        ;-----------------------------------------------------------------------
        joy_state               BYTE
.ENDS

.SECTION "z80_rst_00"   SIZE 8          RETURNORG
;###############################################################################

rst_waitVBlank:                                                         ;$00
;===============================================================================
; NOTE: this routine *must* be exactly 8-bytes -- no more, no less
;       -- due to the fall-through to the next routine                  ;bytes:
;-------------------------------------------------------------------------------
        ld      A,      [IRQ_ENABLE]                                    ;+3=3
        or      A,      IE.vblank                                       ;+2=5
        ld      [IRQ_ENABLE],   A                                       ;+3=8

;###############################################################################
.ENDS

.SECTION "z80_rst_08"   SIZE 8          RETURNORG
;###############################################################################

rst_haltVBlank:                                                         ;$08
;===============================================================================
        ;                                                               ; bytes:
        ; stop the CPU until an interrupt occurs!
        ; (this will save battery life)
-       halt                                                            ;+1=1
        ; read the IRQ flags register at $FF0F:
        ; (using HRAM instruction saves 1 byte over `ld A, [IRQ_FLAGS]`,
        ;  this is required to fit within the max. 8-bytes we have here!)
        ldh     A,      [<IRQ_FLAGS]                                    ;+2=3
        ; was it a v-blank interrupt? (bit 0)
        bit     0,      A                                               ;+2=5
        ; if not, wait again...
        jr      nz,     -                                               ;+2=7

        ; we are now in v-blank!
        ret                                                             ;+1=8

;###############################################################################
.ENDS

.SECTION "z80_rst_10"   SIZE 8          RETURNORG
;###############################################################################

rst_screenOn:                                                           ;$10
;===============================================================================
; turn the LCD on
;-------------------------------------------------------------------------------
        ; (using HRAM instruction saves 1 byte over `ld A, [LCDC]`,
        ldh     A,      [<LCDC]
        set     7,      A
        ldh     [<LCDC],A
        ret

;###############################################################################
.ENDS

.SECTION "z80_rst_18"   SIZE 8          RETURNORG
;###############################################################################

rst_screenOff:                                                          ;$18
;===============================================================================
; turn the LCD off. we must only do this during v-blank or risk damaging
; real hardware! therefore, we wait for v-blank to occur first:
;
;-------------------------------------------------------------------------------
        rst     rst_waitVBlank
        ldh     A,      [<LCDC]
        res     7,      A
        ldh     [<LCDC],A
        ret

;###############################################################################
.ENDS

; overwrite the GameBoy v-blank interrupt entry-point:
; this area only provides 8 bytes free before the next IRQ ($48),
; so we only have room to jump to a bigger routine
;
.SECTION "irq_vblank"                   RETURNORG
;###############################################################################
        ; various documentation says that an IRQ takes 20 cycles        ;+20=20
        ; (note the relative jump to save 4 cycles over JP)
        jp      irq_vblank                                              ;+12=34
;###############################################################################
.ENDS

.SECTION "interrupts"   FREE            RETURNORG
;###############################################################################

init_interrupts:
;===============================================================================
        ; clear the interrupt registers:
        ; we don't want unexpected interrupts firing due to
        ; dirty state (e.g. device was rebooted mid-game)
        ;
        xor     A                       ; (sets A to 0)
        ldh     [<IRQ_ENABLE],   A      ; disallow each type of interrupt
        ldh     [<IRQ_FLAGS],    A      ; clear any 'pending' interrupts

        ; clear interrupt handler work-RAM (note A = 0)
        ld      HL,     SECTIONSTART_Joypad
        ld      [HL+],  A

        ; write the DMA routine into HRAM:
        ;-----------------------------------------------------------------------
        ld      C,      <doDMA
        ld      B,      5               ; size of DMA routine
        ld      HL,     @dma
-       ld      A,      [HL+]
        ldh     [C],    A
        inc     C
        dec     B
        jr      nz, -

        ret

        ; this is the DMA routine in HRAM:
        ;=======================================================================
        ; send the lo-byte of the address to copy from (A)
        ; to the DMA register $FF00+C(=$46)
@dma:   ldh     [C],    A
        ; wait for DMA to complete...
-       dec     B                       ; decrement wait counter
        jr      nz, -                   ; keep waiting?
        ret


irq_vblank:                                                                ;=34
;===============================================================================
        ; * * * start of time-critical code * * *
        ;-----------------------------------------------------------------------
        push    AF                                                      ;+16=50
        push    BC                                                      ;+16=66
        push    HL                                                      ;+16=82

        ; any tile updates?
        ;=======================================================================
        ldh     A,      [<queue_ready]                                  ;+12=94
        and     A,      A               ; (set flags!)                  ;+4 =98
        jp      z,      @skip                                           ;+8 =106

        ; backup current stack pointer: we don't use HL during the
        ; tile-writing so we don't need to write the old SP to RAM!
        ld      HL,     SP+0                                            ;+12=118
        ld      SP,     tile_queue                                      ;+8 =126

        ;-----------------------------------------------------------------------
        ; read tiles and write to VRAM:
-       pop     BC                      ; pop VRAM address from queue   ;+12=12
        pop     AF                      ; pop tile / CPU flags          ;+12=24
        ld      [BC],   A               ; write tile to VRAM            ;+8 =32
        jr      z,      -               ; end of queue?                 ;+12=44

        ; restore original stack pointer
        ld      SP,     HL                                              ;+8
        ;-----------------------------------------------------------------------

        ; mark the queue as done
        ; (don't process the same tile-queue twice)
        xor     A                       ; (set A to zero)
        ldh     [<queue_ready], A

        ; DMA the sprite attributes from work RAM into OAM:
        ;=======================================================================
        ; the DMA register only accepts 8-bits, which will
        ; be the hi-byte of the address to copy from
@skip:  ld      A,      >sprites.attrs
        
        ; whilst the DMA is occuring the CPU can only access HRAM,
        ; therefore we must initialise the DMA and wait via a routine
        ; running from HRAM. the routine has been copied into HRAM during
        ; `init_interrupts`. B must be set to the number of loop iterations
        ; to wait and C is set to the lo-byte of the DMA register
        ;
        ; despite using the information given here,
        ; <https://gbdev.io/pandocs/OAM_DMA_Transfer.html>,
        ; the BGB emulator would break on bad access during DMA
        ; unless the wait was increased from 40 ($28) to 41!
        ;
        ld      BC,     (41<<8) + <DMA
        call    doDMA                   ; this is in HRAM!
        ;-----------------------------------------------------------------------
        ; * * * end of time-critical code * * *
        ;
        ; move the cursor one frame towards its destination
        call    cursor.update

        ; read the joypad:
        ;=======================================================================
        ; this is where the logical joypad state is stored that the game uses;
        ; the game code never talks directly to the joypad hardware
        ld      HL,     joy_state

        ; read d-pad state:
        ;-----------------------------------------------------------------------
        ; first we WRITE a bit to filter either dpad or buttons
        ld      A,      JOYP.dpad
        ldh     [<JOYP],        A
        ; READ to get the dpad state. an emulator will give you an instant
        ; result but real hardware is said to "take a few cycles" to settle;
        ; the original DMG bricks have *very* noisy circuits
        ;
        ; TODO: test on real hardware: DMG, GBC, GBA, DS
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        cpl     A
        and     A,      %00001111       ; mask out the other/unused bits
        ld      [HL],   A               ; store the dpad state (lo-nybble)

        ; read button state:
        ;-----------------------------------------------------------------------
        ; first we WRITE a bit to filter either dpad or buttons
        ld      A,      JOYP.buttons
        ldh     [<JOYP],        A
        ; READ to get the buttons state. an emulator will give you an instant
        ; result but real hardware is said to "take a few cycles" to settle;
        ; the original DMG bricks have *very* noisy circuits
        ;
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        cpl     A
        and     A,      %00001111       ; mask out the other/unused bits
        swap    A                       ; buttons go in the hi-nybble
        or      A,      [HL]            ; combine with the lo-nybble,
        ld      [HL],   A               ; and write back
        
        ;-----------------------------------------------------------------------
        ; no more work to be done,
        ; disable v-blank interrupts
        ;;ld	HL,	IRQ_ENABLE
        ;;res	0,	[HL]
        
        pop     HL
        pop     BC
        pop     AF
        reti

;###############################################################################
.ENDS


getButton:
;===============================================================================
; wait for a button press and return it:
;
; note that this waits first for any current buttons to be released
; before waiting again for a fresh button press
;
; out:  A       the current `joy_state` value
;       *       all other registers are preserved
;-------------------------------------------------------------------------------
        ; wait for button release; this game doesn't continue to move if you
        ; hold a button as the cursor snaps to cards and doesn't move freely
        ;
        ; stop the processor; the vblank will awaken it again, where upon
        ; the screen will be updated and the buttons will be read
-       rst     rst_waitVBlank
        ld      A,      [joy_state]
        and     A,      A               ; set flags!
        jr      nz,     -               ; spin for button pressed

        ; wait for a new button press:
-       rst     rst_waitVBlank
        ld      A,      [joy_state]
        and     A,      A               ; set flags!
        jr      z,     -                ; spin for no button pressed

        ret


clearQueue:
;===============================================================================
; empty the tile-update queue, used to defer VRAM changes to vblank:
;-------------------------------------------------------------------------------
        ; ready flag must be cleared first so that VRAM tile updates
        ; do not occur whilst we are erasing the tile queue!
        xor     A                       ; (set A to zero)
        ldh     [<queue_ready], A
        ; erase the queue
        ld      HL,     tile_queue
        ; because the number of bytes to clear is fixed,
        ; we can jump into `fill` at the exact place needed
        jp      fill@f{_sizeof_tile_queue}