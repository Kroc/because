; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
.BANK 0

; these are the *logical* button constants for the game, not the ones used by
; the hardware, which are split across two bytes. these are `bit` numbers
;
.DEF    BUTTON_RIGHT            0
.DEF    BUTTON_LEFT             1
.DEF    BUTTON_UP               2
.DEF    BUTTON_DOWN             3
.DEF    BUTTON_A                4
.DEF    BUTTON_B                5
.DEF    BUTTON_SELECT           6
.DEF    BUTTON_START            7

; RAM for remembering joypad state:
;
.RAMSECTION "Joypad"            RETURNORG
        ;-----------------------------------------------------------------------
        joy_state               BYTE
.ENDS

.SECTION "z80_rst_00"   SIZE 8
;###############################################################################

rst_waitVBlank:                                                         ;$00
;===============================================================================
; NOTE: this routine *must* be exactly 8-bytes -- no more, no less
;       -- due to the fall-through to the next routine                  ;bytes:
;-------------------------------------------------------------------------------
        ld      A,      [IRQ_ENABLE]                                    ;+3=3
        or      A,      IE.vblank                                       ;+2=5
        ld      [IRQ_ENABLE],   A                                       ;+3=8

;###############################################################################
.ENDS

.SECTION "z80_rst_08"   SIZE 8
;###############################################################################

rst_haltVBlank:                                                         ;$08
;===============================================================================
        ;                                                               ; bytes:
        ; stop the CPU until an interrupt occurs!
        ; (this will save battery life)
-       halt                                                            ;+1=1
        ; read the IRQ flags register at $FF0F:
        ; (using HRAM instruction saves 1 byte over `ld A, [IRQ_FLAGS]`,
        ;  this is required to fit within the max. 8-bytes we have here!)
        ldh     A,      [<IRQ_FLAGS]                                    ;+2=3
        ; was it a v-blank interrupt? (bit 0)
        bit     0,      A                                               ;+2=5
        ; if not, wait again...
        jr      nz,     -                                               ;+2=7

        ; we are now in v-blank!
        ret                                                             ;+1=8

;###############################################################################
.ENDS

.SECTION "z80_rst_10"   SIZE 8
;###############################################################################

rst_screenOn:                                                           ;$10
;===============================================================================
; turn the LCD on
;-------------------------------------------------------------------------------
        ; (using HRAM instruction saves 1 byte over `ld A, [LCDC]`,
        ldh     A,      [<LCDC]
        set     7,      A
        ldh     [<LCDC],A
        ret

;###############################################################################
.ENDS

.SECTION "z80_rst_18"   SIZE 8
;###############################################################################

rst_screenOff:                                                          ;$18
;===============================================================================
; turn the LCD off. we must only do this during v-blank or risk damaging
; real hardware! therefore, we wait for v-blank to occur first:
;
;-------------------------------------------------------------------------------
        rst     rst_waitVBlank
        ldh     A,      [<LCDC]
        res     7,      A
        ldh     [<LCDC],A
        ret

;###############################################################################
.ENDS

; overwrite the GameBoy v-blank interrupt entry-point:
; this area only provides 8 bytes free before the next IRQ ($48),
; so we only have room to jump to a bigger routine
;
.SECTION "irq_vblank"
;###############################################################################
        jp      irq_vblank
;###############################################################################
.ENDS

.SECTION "interrupts"   FREE
;###############################################################################

init_interrupts:
;===============================================================================
        ; clear the interrupt registers:
        ; we don't want unexpected interrupts firing due to
        ; dirty state (e.g. device was rebooted mid-game)
        ;
        xor     A                       ; (sets A to 0)
        ldh     [<IRQ_ENABLE],   A      ; disallow each type of interrupt
        ldh     [<IRQ_FLAGS],    A      ; clear any 'pending' interrupts

        ; clear interrupt handler work-RAM (note A = 0)
        ; TODO: This should validate its size against the RAMSECTION,
        ;       and/or use a generic zeroing routine
        ld      HL,     SECTIONSTART_Joypad
        ld      [HL+],  A

        ; write the DMA routine into HRAM:
        ;-----------------------------------------------------------------------
        ld      C,      <sprites.doDMA
        ld      B,      5               ; size of DMA routine
        ld      HL,     @dma
-       ld      A,      [HL+]
        ldh     [C],    A
        inc     C
        dec     B
        jr      nz, -

        ret

        ; this is the DMA routine in HRAM:
        ;
        ; send the lo-byte of the address to copy from (A)
        ; to the DMA register $FF00+C(=$46)
@dma:   ldh     [C],    A
        ; wait for DMA to complete...
-       dec     B                       ; decrement wait counter
        jr      nz, -                   ; keep waiting?
        ret


irq_vblank:
;===============================================================================
        push    AF
        push    BC
        push    HL

        ; TODO: any tile updates?
        ; update the sprites:
        call    sprites.update

        ; read the joypad:
        ;=======================================================================
        ; this is where the logical joypad state is stored that the game uses;
        ; the game code never talks directly to the joypad hardware
        ld      HL,     joy_state

        ; read d-pad state:
        ;-----------------------------------------------------------------------
        ; first we WRITE a bit to filter either dpad or buttons
        ld      A,      JOYP.dpad
        ldh     [<JOYP],        A
        ; READ to get the dpad state. an emulator will give you an instant
        ; result but real hardware is said to "take a few cycles" to settle;
        ; the original DMG bricks have *very* noisy circuits
        ;
        ; TODO: test on real hardware: DMG, GBC, GBA
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        cpl     A
        and     A,      %00001111       ; mask out the other/unused bits
        ld      [HL],   A               ; store the dpad state (lo-nybble)

        ; read button state:
        ;-----------------------------------------------------------------------
        ; first we WRITE a bit to filter either dpad or buttons
        ld      A,      JOYP.buttons
        ldh     [<JOYP],        A
        ; READ to get the buttons state. an emulator will give you an instant
        ; result but real hardware is said to "take a few cycles" to settle;
        ; the original DMG bricks have *very* noisy circuits
        ;
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        ldh     A,      [<JOYP]
        cpl     A
        and     A,      %00001111       ; mask out the other/unused bits
        swap    A                       ; buttons go in the hi-nybble
        or      A,      [HL]            ; combine with the lo-nybble,
        ld      [HL],   A               ; and write back
        
        ;-----------------------------------------------------------------------
        ; no more work to be done,
        ; disable v-blank interrupts
        ;;ld	HL,	IRQ_ENABLE
        ;;res	0,	[HL]
        
        pop     HL
        pop     BC
        pop     AF
        reti


getButton:
;===============================================================================
; wait for a button press and return it:
;
; note that this waits first for any current buttons to be released
; before waiting again for a fresh button press
;
; out:  A       the current `joy_state` value
;       *       all other registers are preserved
;-------------------------------------------------------------------------------
        ; wait for button release; this game doesn't continue to move if you
        ; hold a button as the cursor snaps to cards and doesn't move freely
        ;
        ; stop the processor; the vblank will awaken it again, where upon
        ; the screen will be updated and the buttons will be read
-       rst     rst_waitVBlank
        ld      A,      [joy_state]
        and     A,      A               ; set flags!
        jr      nz,     -               ; spin for button pressed

        ; wait for a new button press:
-       rst     rst_waitVBlank
        ld      A,      [joy_state]
        and     A,      A               ; set flags!
        jr      z,     -                ; spin for no button pressed

        ret

;###############################################################################
.ENDS