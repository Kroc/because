; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; GameBoy hardware definitions
.INC    "gb/gb_cpu.wla"         NAMESPACE "gb"

.INC    "strings.wla"           ; string & text routines
.INC    "interrupts.wla"
.INC    "tilemap.wla"           NAMESPACE "tilemap"
.INC    "sprites.wla"           NAMESPACE "sprites"


init:
;===============================================================================
        di                              ; disable interrupts
        ld      SP,     $dff0           ; locate the stack

        call    init_interrupts

        ; configure LCD:
        ;-----------------------------------------------------------------------
        ld      HL,     LCDC            ; LCD config register;
        ld      A,      [HL]            ; read the current value

        ; we *MUST NOT* disable the LCD (bit7=1) outside of vblank!
        ; even though we want the screen off during initialisation,
        ; we must set the LCD enable bit to 1 at this time and
        ; then wait for vblank to turn it off!
        ;
        ;               %1-------       ; LCD enable
        ;               %--0-----       ; window disabled
        ;               %------0-       ; sprites disabled
        ;               %-------0       ; background disabled 
        ld      A,      %10000000
        ld      [HL],   A               ; write settings to LCD register

        ; since interrupts are currently disabled we'll spin in place until
        ; the LCD status register indicates that we've reached vblank
        ;
-       ldh     A,      [<STAT]         ; read current LCD state
        and     %11                     ; bottom-two bits determine mode
        dec     A                       ; 1 = vblank; -1 and check for 0
        jr      nz,     -               ; not vblank, keep spinning

        ; turn the LCD off
        res     7,      [HL]            ; (this is why we load HL with LCDC)

        ; clear VRAM:
        ld      HL,     VRAM
        ld      BC,     8192
        call    zero

        ; clear sprite registers (OAM)
        ld      HL,     OAM
        ld      BC,     (40 * 4)
        call    zero

        ei

        ; begin initialising the game:
        ;-----------------------------------------------------------------------
        call    sprites.init
        call    tilemap.init
        call    acesup.init
        
-       rst     rst_waitVBlank
        jr      -


zero:
;===============================================================================
; zero-out any area of RAM:
;
; in:   HL      starting address to zero
;       BC      number of bytes to clear (1-based)
;
; out:  HL, BC  (clobbered)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        ; if the hi-byte is non-zero it's guaranteed that >255 bytes
        ; remain and we can simply zero 255 bytes at a time!
        xor     A                       ; (set A to zero)
        cp      B                       ; (set flags!)
        jp      z,      +

        ; since the auto-incrementing `ldi` instruction is only 1 byte,
-       ; this is very memory efficient for the speed it provides
.REPEAT 256
        ld      [HL+],  A
.ENDR
        dec     B                       ; one page copied, any remain?
        jp      nz,     -               ; keep copying until B=0

        ; if the lo-byte is $00 then there are no individual
        ; bytes left to copy, we can exit early
        cp      C
        ret     z

        ; <256 bytes remain:
        ;
        ; we try zero 8 bytes at a time for speed, thus we have
        ; to check for when there's less than 8 bytes remaining
        ;
-       ld      A,      8               ; more than 8-bytes remaining?
        cp      C
        jr      c,      +               ; zero only one byte at a time

        ; zero 8 bytes at a time
        xor     A                       ; (set A to zero)
        ld      [HL+],  A
        ld      [HL+],  A
        ld      [HL+],  A
        ld      [HL+],  A
        ld      [HL+],  A
        ld      [HL+],  A
        ld      [HL+],  A
        ld      [HL+],  A

        dec     C
        jr      nz,     -

        ret

+       xor     A                       ; (set A to zero)
        ld      [HL+],  A
        dec     C
        jr      nz,     -
        ret

;===============================================================================
.INC    "menu.wla"              NAMESPACE "menu"
.INC    "tableau.wla"           NAMESPACE "tableau"
.INC    "playfield.wla"         NAMESPACE "playfield"
.INC    "game_acesup.wla"       NAMESPACE "acesup"