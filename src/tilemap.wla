; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; since we cannot modify VRAM during the display period,
; changes are queued up and then applied during vblank
;
.RAMSECTION "tile_queue"                RETURNORG
        ;-----------------------------------------------------------------------
        queue_index     BYTE            ; current stack-level of the queue
        tile_queue      DSB 121
.ENDS

.RAMSECTION "buffers"   ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        front_buffer    DSB 32*32
        back_buffer     DSB 32*32
.ENDS

; include the tile graphics and map the various pieces of the card graphics
; to some constants so that we don't have to tweak tile numbers throughout
; the code-base. we want this aligned to one-tile (16-bytes) for some
; tile-copying micro-optimisations
;
.SECTION "tiles_cards"  ALIGN 16        RETURNORG
;///////////////////////////////////////////////////////////////////////////////

.DEF    TILE_PALETTE    %01111000

tiles_main:
;===============================================================================
.INCBIN "build/tiles.2bpp"              FSIZE tiles_main__size

; define the conversion from ASCII to the tile-numbers in our tileset:
;
.ASCIITABLE
        ;-----------------------------------------------------------------------
        MAP   0 TO 127  = $80
        MAP 128 TO 255  = $00

        MAP     "0"     = $00+$70
        MAP     "1"     = $00+$71
        MAP     "2"     = $00+$72
        MAP     "3"     = $00+$73
        MAP     "4"     = $00+$74
        MAP     "5"     = $00+$75
        MAP     "6"     = $00+$76
        MAP     "7"     = $00+$77
        MAP     "8"     = $00+$78
        MAP     "9"     = $00+$79

        MAP     "S"     = $00+$7a       ; spades symbol
        MAP     "C"     = $00+$7b       ; clubs symbol
        MAP     "H"     = $00+$7c       ; hearts symbol
        MAP     "D"     = $00+$7d       ; diamonds symbol

        MAP     " "     = $80+$60
        MAP     "a"     = $80+$61
        MAP     "b"     = $80+$62
        MAP     "c"     = $80+$63
        MAP     "d"     = $80+$64
        MAP     "e"     = $80+$65
        MAP     "f"     = $80+$66
        MAP     "g"     = $80+$67
        MAP     "h"     = $80+$68
        MAP     "i"     = $80+$69
        MAP     "j"     = $80+$6a
        MAP     "k"     = $80+$6b
        MAP     "l"     = $80+$6c
        MAP     "m"     = $80+$6d
        MAP     "n"     = $80+$6e
        MAP     "o"     = $80+$6f
        MAP     "p"     = $80+$70
        MAP     "q"     = $80+$71
        MAP     "r"     = $80+$72
        MAP     "s"     = $80+$73
        MAP     "t"     = $80+$74
        MAP     "u"     = $80+$75
        MAP     "v"     = $80+$76
        MAP     "w"     = $80+$77
        MAP     "x"     = $80+$78
        MAP     "y"     = $80+$79
        MAP     "z"     = $80+$7a
        MAP     "!"     = $80+$7b
        MAP     ","     = $80+$7c
        MAP     "."     = $80+$7d
        MAP     "A"     = $80+$7e       ; GameBoy button "A"
        MAP     "B"     = $80+$7f       ; GameBoy button "B"
.ENDA

; 3x4 cards:
;===============================================================================
; foundation:
;-------------------------------------------------------------------------------
; a foundation is a blank space on the playfield where cards are
; "played off", into their final destination
;
.DEF    TILE3X4_FNDT_1X1        $00+$3d ; foundation, top-left
.DEF    TILE3X4_FNDT_1X2        $00+$3e ; foundation, top-centre
.DEF    TILE3X4_FNDT_1X3        $00+$3f ; foundation, top-right
.DEF    TILE3X4_FNDT_2X1        $00+$4d ; foundation, upper-middle left
.DEF    TILE3X4_FNDT_2X2        $00+$4e ; foundation, upper-middle centre
.DEF    TILE3X4_FNDT_2X3        $00+$4f ; foundation, upper-middle right
.DEF    TILE3X4_FNDT_3X1        $00+$5d ; foundation, lower-middle left
.DEF    TILE3X4_FNDT_3X2        $00+$5e ; foundation, lower-middle centre
.DEF    TILE3X4_FNDT_3X3        $00+$5f ; foundation, lower-middle right
.DEF    TILE3X4_FNDT_4X1        $00+$6d ; foundation, bottom-left
.DEF    TILE3X4_FNDT_4X2        $00+$6e ; foundation, bottom-centre
.DEF    TILE3X4_FNDT_4X3        $00+$6f ; foundation, bottom-right

; deck:
;-------------------------------------------------------------------------------
; a deck is a pile of face-down cards
;
.DEF    TILE3X4_DECK_0X1        $80+$0d ; deck, top-left
.DEF    TILE3X4_DECK_0X2        $80+$0e ; deck, top-centre
.DEF    TILE3X4_DECK_0X3        $80+$0f ; deck, top-right

; the middle three rows of the deck repeat
;
.DEF    TILE3X4_DECK_1X1        $80+$2d ; deck, middle-left (row 2)
.DEF    TILE3X4_DECK_1X2        $80+$2e ; deck, middle-centre (row 2)
.DEF    TILE3X4_DECK_1X3        $80+$2f ; deck, middle-right (row 2)
.DEF    TILE3X4_DECK_2X1        $80+$2d ; deck, middle-left (row 3)
.DEF    TILE3X4_DECK_2X2        $80+$2e ; deck, middle-centre (row 3)
.DEF    TILE3X4_DECK_2X3        $80+$2f ; deck, middle-right (row 3)
.DEF    TILE3X4_DECK_3X1        $80+$2d ; deck, bottom-left (row 4)
.DEF    TILE3X4_DECK_3X2        $80+$2e ; deck, bottom-centre (row 4)
.DEF    TILE3X4_DECK_3X3        $80+$2f ; deck, bottom-right (row 4)

; bottom-row of the deck
.DEF    TILE3X4_DECK_4X1        $80+$4d ; deck, pile-left
.DEF    TILE3X4_DECK_4X2        $80+$4e ; deck, pile-centre
.DEF    TILE3X4_DECK_4X3        $80+$4f ; deck, pile-right

; back:
;-------------------------------------------------------------------------------
; a card, face-down:
;
.DEF    TILE3X4_BACK_1X1        $80+$1d ; back, top-left
.DEF    TILE3X4_BACK_1X2        $80+$1e ; back, top-centre
.DEF    TILE3X4_BACK_1X3        $80+$1f ; back, top-right
.DEF    TILE3X4_BACK_2X1        $80+$2d ; back, middle-left (row 2)
.DEF    TILE3X4_BACK_2X2        $80+$2e ; back, middle-centre (row 2)
.DEF    TILE3X4_BACK_2X3        $80+$2f ; back, middle-right (row 2)
.DEF    TILE3X4_BACK_3X1        $80+$2d ; back, middle-left (row 3)
.DEF    TILE3X4_BACK_3X2        $80+$2e ; back, middle-centre (row 3)
.DEF    TILE3X4_BACK_3X3        $80+$2f ; back, middle-right (row 3)
.DEF    TILE3X4_BACK_4X1        $80+$3d ; back, bottom-left
.DEF    TILE3X4_BACK_4X2        $80+$3e ; back, bottom-centre
.DEF    TILE3X4_BACK_4X3        $80+$3f ; back, bottom-right

; face-up:
;-------------------------------------------------------------------------------
; the top-left corner of a face-up card has the
; ordinal (number) of the card, Ace through King:
;
.DEF    TILE3X4_CARD_1X1        $80+$00
.DEF    TILE3X4_CARD_1X1_A      $80+$00 ; Ace
.DEF    TILE3X4_CARD_1X1_2      $80+$01 ; Two
.DEF    TILE3X4_CARD_1X1_3      $80+$02 ; Three
.DEF    TILE3X4_CARD_1X1_4      $80+$03 ; Four
.DEF    TILE3X4_CARD_1X1_5      $80+$04 ; Five
.DEF    TILE3X4_CARD_1X1_6      $80+$05 ; Six
.DEF    TILE3X4_CARD_1X1_7      $80+$06 ; Seven
.DEF    TILE3X4_CARD_1X1_8      $80+$07 ; Eight
.DEF    TILE3X4_CARD_1X1_9      $80+$08 ; Nine
.DEF    TILE3X4_CARD_1X1_10     $80+$09 ; Ten
.DEF    TILE3X4_CARD_1X1_J      $80+$0a ; Jack
.DEF    TILE3X4_CARD_1X1_Q      $80+$0b ; Queen
.DEF    TILE3X4_CARD_1X1_K      $80+$0c ; King

; the top-centre of a face-up card is blank
.DEF    TILE3X4_CARD_1X2        $80+$20

; the top-right of a face-up card has the suit:
;
.DEF    TILE3X4_CARD_1X3        $80+$39
.DEF    TILE3X4_CARD_1X3_SPD    $80+$39 ; Spades
.DEF    TILE3X4_CARD_1X3_CLB    $80+$3a ; Clubs
.DEF    TILE3X4_CARD_1X3_HRT    $80+$3b ; Hearts
.DEF    TILE3X4_CARD_1X3_DMD    $80+$3c ; Diamonds

; the left, centre and right of the middle
; portion of the card (two-rows) is blank:
;
.DEF    TILE3X4_CARD_2X1        $80+$10
.DEF    TILE3X4_CARD_2X2        $80+$30
.DEF    TILE3X4_CARD_2X3        $80+$40
.DEF    TILE3X4_CARD_3X1        $80+$10
.DEF    TILE3X4_CARD_3X2        $80+$30
.DEF    TILE3X4_CARD_3X3        $80+$40

; the bottom-left of a face-up card has the suit:
;
.DEF    TILE3X4_CARD_4X1        $80+$2a
.DEF    TILE3X4_CARD_4X1_SPD    $80+$29 ; Spades
.DEF    TILE3X4_CARD_4X1_CLB    $80+$2a ; Clubs
.DEF    TILE3X4_CARD_4X1_HRT    $80+$2b ; Hearts
.DEF    TILE3X4_CARD_4X1_DMD    $80+$2c ; Diamonds

; the bottom-centre is blank
.DEF    TILE3X4_CARD_4X2        $80+$31

; the bottom-right of a face-up card has the ordinal:
;
.DEF    TILE3X4_CARD_4X3        $80+$50
.DEF    TILE3X4_CARD_4X3_A      $80+$50 ; Ace
.DEF    TILE3X4_CARD_4X3_2      $80+$51 ; Two
.DEF    TILE3X4_CARD_4X3_3      $80+$52 ; Three
.DEF    TILE3X4_CARD_4X3_4      $80+$53 ; Four
.DEF    TILE3X4_CARD_4X3_5      $80+$54 ; Five
.DEF    TILE3X4_CARD_4X3_6      $80+$55 ; Six
.DEF    TILE3X4_CARD_4X3_7      $80+$56 ; Seven
.DEF    TILE3X4_CARD_4X3_8      $80+$57 ; Eight
.DEF    TILE3X4_CARD_4X3_9      $80+$58 ; Nine
.DEF    TILE3X4_CARD_4X3_10     $80+$59 ; Ten
.DEF    TILE3X4_CARD_4X3_J      $80+$5a ; Jack
.DEF    TILE3X4_CARD_4X3_Q      $80+$5b ; Queen
.DEF    TILE3X4_CARD_4X3_K      $80+$5c ; King

; card tilemaps:
;===============================================================================
tilemap_empty:
        ;-----------------------------------------------------------------------
        ; this is the dotted-outline used for showing an empty pile,
        ; such as the deck, hand, or foundation
        ;
@row1:  .byte   TILE3X4_FNDT_1X1, TILE3X4_FNDT_1X2, TILE3X4_FNDT_1X3
@row2:  .byte   TILE3X4_FNDT_2X1, TILE3X4_FNDT_2X2, TILE3X4_FNDT_2X3
@row3:  .byte   TILE3X4_FNDT_3X1, TILE3X4_FNDT_3X2, TILE3X4_FNDT_3X3
@row4:  .byte   TILE3X4_FNDT_4X1, TILE3X4_FNDT_4X2, TILE3X4_FNDT_4X3

tilemap_deck:
        ;-----------------------------------------------------------------------
        ; a full deck
        ;
@row0:  .byte   TILE3X4_DECK_0X1, TILE3X4_DECK_0X2, TILE3X4_DECK_0X3
@row1:  .byte   TILE3X4_DECK_1X1, TILE3X4_DECK_1X2, TILE3X4_DECK_1X3
@row2:  .byte   TILE3X4_DECK_2X1, TILE3X4_DECK_2X2, TILE3X4_DECK_2X3
@row3:  .byte   TILE3X4_DECK_3X1, TILE3X4_DECK_3X2, TILE3X4_DECK_3X3
@row4:  .byte   TILE3X4_DECK_4X1, TILE3X4_DECK_4X2, TILE3X4_DECK_4X3


tilemap_back:
        ;-----------------------------------------------------------------------
        ; the back of a card
        ;
@row1:  .byte   TILE3X4_BACK_1X1, TILE3X4_BACK_1X2, TILE3X4_BACK_1X3
@row2:  .byte   TILE3X4_BACK_2X1, TILE3X4_BACK_2X2, TILE3X4_BACK_2X3
@row3:  .byte   TILE3X4_BACK_3X1, TILE3X4_BACK_3X2, TILE3X4_BACK_3X3
@row4:  .byte   TILE3X4_BACK_4X1, TILE3X4_BACK_4X2, TILE3X4_BACK_4X3

;///////////////////////////////////////////////////////////////////////////////
.ENDS


init:
;===============================================================================
        ldh     A,      [<LCDC]
        or      LCDC.window_select      ; use $9C00 for the window-map
        or      LCDC.bg_display         ; turn background on
        ldh     [<LCDC],        A

        call    clearQueue              ; clear the tile update queue
        call    copyMainTileset         ; copy main tileset from ROM to VRAM

        call    tableau.clearTiles      ; clear the tableau (playing space)
        call    menu.clear              ; clear and draw the menu

        call    refresh

        ; set palette:
        ld      A,      TILE_PALETTE
        ld      [BGP],  A

        rst     rst_screenOn
        ret


clearQueue:
;===============================================================================
; empty the tile-update queue, used to defer VRAM changes to vblank:
;
;-------------------------------------------------------------------------------
        ; starting address of tile queue
        ld      C,      <tile_queue
        ld      HL,     queue_index
        ld      [HL],   C

        ld      B,      _sizeof_tile_queue
-       ldh     [C],    A               ; write 0 to queue
        inc     C                       ; move to next byte in queue
        dec     B                       ; one less byte to process
        jr      nz, -                   ; keep going?
        
        ret


copyMainTileset:
;===============================================================================
; copy the main tileset used throughout the game:
;
; TODO: check vblank/lcd-stat for safety on CGB, we can use DMA to do this
;-------------------------------------------------------------------------------
        ld      HL,     tiles_main      ; set source address
        ld      DE,     VRAM_TILES2     ; set destination VRAM position

        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_main__size / 16) - 1


copyTiles:
;===============================================================================
; copy a number of graphic tiles to VRAM:
;
; in:   HL      starting address of tiles
;       DE      VRAM destination, e.g. $8000
;       B       number of tiles to copy, 1-based
;               use "0" for 256 tiles
;
; TODO: on GBC we could do this using DMA?
;-------------------------------------------------------------------------------
.REPEAT 15
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E   
.ENDR
        ld      A,      [HL+]
        ld      [DE],   A
        inc     DE
        
        dec     B
        jr      nz, copyTiles
        
        ret


getBufferAddr:
;===============================================================================
; given an X & Y tile co-ordinate, return an address in the screen-buffer:
;
; in:   B       y-position (row) in the tile-map (32x32)
;       C       x-position (column) in the tile-map (32x32)
;
; out:  HL      address within the screen-buffer                         
;       A, DE   (preserved)                                             
;       BC      (clobbered)                                             ;cycles
;-------------------------------------------------------------------------------
        ; we need to multiply Y (row) by 32
        ld      H,      0               ; prepare HL,
        ld      L,      B               ; with row-number only

        ; TODO: use a lookup table of rows (just 64 bytes!)
        ;       also, we could use SWAP to partially multiply by 4,
        ;       but this requires the A register which we need to preserve
        ;       <github.com/pret/pokecrystal/wiki/Optimizing-assembly-code>
        ;
        add     HL,     HL              ; x2
        add     HL,     HL              ; x4
        add     HL,     HL              ; x8
        add     HL,     HL              ; x16
        add     HL,     HL              ; x32

        ld      B,      0               ; prepare BC with column only
        add     HL,     BC              ; add the column
        ld      BC,     front_buffer    ; get screen-buffer address
        add     HL,     BC              ; finally, add our offset

        ret


writeTiles_3wide_5rows:
;===============================================================================
        call    writeTiles_3wide

writeTiles_3wide_4rows:
;===============================================================================
        call    writeTiles_3wide

writeTiles_3wide_3rows:
;===============================================================================
        call    writeTiles_3wide

writeTiles_3wide_2rows:
;===============================================================================
        call    writeTiles_3wide

writeTiles_3wide_1row:
;===============================================================================
writeTiles_3wide:
;===============================================================================
; in:   DE      address with tiles to read from
;       HL      address to write to, where 3 tiles are written and then
;               the address is moved to the next row of the tilemap
;-------------------------------------------------------------------------------
        ld      BC,     29

        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        rla                             ; preserve carry flag!
        add     HL,     BC
        rra                             ; restore carry flag!

        ret


refresh:
;===============================================================================
; forces a full update of the background tilemap:
;
; normally updates to the tilemap are done partially -- only the tiles that
; have changed between the front & back buffers are written during vblank
;
; a full update copies the current front buffer to the back buffer, then
; the full back buffer is copied to VRAM in one go. the screen cannot be
; on whilst this happens as writes to VRAM outside of vblank are ignored
;
; TODO: on GBC we can use DMA
;-------------------------------------------------------------------------------
        ; clear the update queue to prevent changes to VRAM during vblank
        call    clearQueue

        ; copy front buffer to back buffer:
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        call    @copy

        ; copy back buffer to VRAM:
        ;
        ; on the GameBoy, VRAM is memory-mapped,
        ; though it is inaccessible outside of vblank
        ;
        ld      HL,     back_buffer
        ld      DE,     VRAM_MAP1

        ; copy 1'024 bytes:
        ;-----------------------------------------------------------------------
@copy:  ld      C,      0

-       ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     DE
        dec     C
        jr      nz, -

        ret


update:
;===============================================================================
; compares the differences between the front & back buffers and generates
; the list of VRAM changes (tile queue) to make during vblank
;
;-------------------------------------------------------------------------------
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        ld      BC,     _sizeof_front_buffer+1

        ; (jump into the functional part of the loop)
        jr      @read
        
        ;-----------------------------------------------------------------------
@next:  dec     BC                      ; one less tile to process...
        ret     z                       ; all done? exit

        inc     DE                      ; move forward in the back-buffer
        inc     HL                      ; and keep the front-buffer in step 

        ; loop begins here...
        ;
@read:  ld      A,      [DE]            ; read tile from back-buffer
        cp      [HL]                    ; compare with front-buffer
        jr      z, @next                ; if they're the same, keep scanning

        ; there's a difference!
        ; queue the tile change:
        ;
        push    BC                      ; (backup current index)
        push    HL                      ; (backup front buffer position)

        push    AF                      ; backup the tile
        
        ; calculate the VRAM address from our current index
        ; in the front & back buffers...
        ld      HL,     VRAM_MAP1
        add     HL,     BC              ; (only HL can do 16-bit adds)
        push    HL

        ; disable vblank interrupts whilst we update the queue; we don't want
        ; the queue being emptied whilst we're writing to it!
        ;
        ld      A,      [IRQ_ENABLE]
        and     IE.vblank^$ff           ; exclude the vblank bit
        ld      [IRQ_ENABLE],   A

        ; get current update queue position:
        ; TODO: handle queue overflow. stop processing buffers, and wait
        ;       for vblank so that the queue can be refilled again?
        ld      HL,     queue_index
        inc     [HL]                    ; move to the next queue slot
        ld      C,      [HL]            ; read the current queue index

        ; we need to write three bytes to the queue:
        ;
        pop     HL                      ; retrieve VRAM address
        ld      A,              H 
        ld      [$FF00+C],      A       ; write hi-byte
        ld      A,              L
        ld      [$FF00+C],      A       ; write lo-byte

        pop     AF                      ; retrieve tile to draw
        ld      [$FF00+C],      A

        ; re-enable vblank interrupts:
        ;
        ld      A,      [IRQ_ENABLE]
        or      IE.vblank
        ld      [IRQ_ENABLE],   A

        pop     HL                      ; (restore front buffer position)
        pop     BC                      ; (restore current buffer position)
        jr      @next
