; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; since we cannot modify VRAM during the display period,
; changes are queued up and then applied during vblank
;
.RAMSECTION "Queue"     ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        ; (NOTE: we rely on this starting at an $xx00 address for optimisation)
        tile_queue      DSB 128
        ; temporary address (lo-byte) used whilst pushing tiles to the queue
        _queue_index    BYTE
.ENDS

.RAMSECTION "Buffers"   ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        front_buffer    DSB TILEMAP_WIDTH*TILEMAP_HEIGHT
        back_buffer     DSB TILEMAP_WIDTH*TILEMAP_HEIGHT
.ENDS

; include the tile graphics and map the various pieces of the card graphics
; to some constants so that we don't have to tweak tile numbers throughout
; the code-base. we want this aligned to one-tile (16-bytes) for some
; tile-copying micro-optimisations
;
.SECTION "TilesCards"   ALIGN 16        RETURNORG
;###############################################################################

.DEF    TILE_PALETTE    %11010010

tiles_main:
;===============================================================================
.INCBIN "build/tiles.2bpp"              FSIZE tiles_main__size

; define the conversion from ASCII to the tile-numbers in our tileset:
;
.ASCIITABLE
        ;-----------------------------------------------------------------------
        ;;MAP   0 TO 127  = $80
        ;;MAP 128 TO 255  = $00

        MAP     " "     = $50
        MAP     "a"     = $51
        MAP     "b"     = $52
        MAP     "c"     = $53
        MAP     "d"     = $54
        MAP     "e"     = $55
        MAP     "f"     = $56
        MAP     "g"     = $57
        MAP     "h"     = $58
        MAP     "i"     = $59
        MAP     "j"     = $5a
        MAP     "k"     = $5b
        MAP     "l"     = $5c
        MAP     "m"     = $5d
        MAP     "n"     = $5e
        MAP     "o"     = $5f
        MAP     "p"     = $60
        MAP     "q"     = $61
        MAP     "r"     = $62
        MAP     "s"     = $63
        MAP     "t"     = $64
        MAP     "u"     = $65
        MAP     "v"     = $66
        MAP     "w"     = $67
        MAP     "x"     = $68
        MAP     "y"     = $69
        MAP     "z"     = $6a
        MAP     "!"     = $6b
        MAP     ","     = $6c
        MAP     "."     = $6d
        MAP     "A"     = $6e           ; GameBoy button "A"
        MAP     "B"     = $6f           ; GameBoy button "B"

        MAP     "0"     = $70
        MAP     "1"     = $71
        MAP     "2"     = $72
        MAP     "3"     = $73
        MAP     "4"     = $74
        MAP     "5"     = $75
        MAP     "6"     = $76
        MAP     "7"     = $77
        MAP     "8"     = $78
        MAP     "9"     = $79

        MAP     "S"     = $7a           ; spades symbol
        MAP     "C"     = $7b           ; clubs symbol
        MAP     "H"     = $7c           ; hearts symbol
        MAP     "D"     = $7d           ; diamonds symbol
.ENDA

; 3x4 cards:
;===============================================================================
; foundation:
;-------------------------------------------------------------------------------
; a foundation is a blank space on the playfield where cards are
; "played off", into their final destination
;
.DEF    TILE_FNDT_1X1           $da     ; foundation, top-left
.DEF    TILE_FNDT_1X2           $ea     ; foundation, top-centre
.DEF    TILE_FNDT_1X3           $fa     ; foundation, top-right
.DEF    TILE_FNDT_2X1           $db     ; foundation, upper-middle left
.DEF    TILE_FNDT_2X2           $eb     ; foundation, upper-middle centre
.DEF    TILE_FNDT_2X3           $fb     ; foundation, upper-middle right
.DEF    TILE_FNDT_3X1           $dc     ; foundation, lower-middle left
.DEF    TILE_FNDT_3X2           $ec     ; foundation, lower-middle centre
.DEF    TILE_FNDT_3X3           $fc     ; foundation, lower-middle right
.DEF    TILE_FNDT_4X1           $dd     ; foundation, bottom-left
.DEF    TILE_FNDT_4X2           $ed     ; foundation, bottom-centre
.DEF    TILE_FNDT_4X3           $fd     ; foundation, bottom-right

; deck:
;-------------------------------------------------------------------------------
; a deck is a pile of face-down cards
;
.DEF    TILE_DECK_0X1           $d1     ; deck, top-left
.DEF    TILE_DECK_0X2           $e1     ; deck, top-centre
.DEF    TILE_DECK_0X3           $f1     ; deck, top-right

; the middle three rows of the deck repeat
;
.DEF    TILE_DECK_1X1           $d3     ; deck, middle-left (row 2)
.DEF    TILE_DECK_1X2           $e3     ; deck, middle-centre (row 2)
.DEF    TILE_DECK_1X3           $f3     ; deck, middle-right (row 2)
.DEF    TILE_DECK_2X1           $d3     ; deck, middle-left (row 3)
.DEF    TILE_DECK_2X2           $e3     ; deck, middle-centre (row 3)
.DEF    TILE_DECK_2X3           $f3     ; deck, middle-right (row 3)
.DEF    TILE_DECK_3X1           $d3     ; deck, bottom-left (row 4)
.DEF    TILE_DECK_3X2           $e3     ; deck, bottom-centre (row 4)
.DEF    TILE_DECK_3X3           $f3     ; deck, bottom-right (row 4)

; bottom-row of the deck
.DEF    TILE_DECK_4X1           $d6     ; deck, pile-left
.DEF    TILE_DECK_4X2           $e6     ; deck, pile-centre
.DEF    TILE_DECK_4X3           $f6     ; deck, pile-right

; back:
;-------------------------------------------------------------------------------
; a card, face-down:
;
.DEF    TILE_BACK_1X1           $d2     ; back, top-left
.DEF    TILE_BACK_1X2           $e2     ; back, top-centre
.DEF    TILE_BACK_1X3           $f2     ; back, top-right
.DEF    TILE_BACK_2X1           $d3     ; back, middle-left (row 2)
.DEF    TILE_BACK_2X2           $e3     ; back, middle-centre (row 2)
.DEF    TILE_BACK_2X3           $f3     ; back, middle-right (row 2)
.DEF    TILE_BACK_3X1           $d4     ; back, middle-left (row 3)
.DEF    TILE_BACK_3X2           $e4     ; back, middle-centre (row 3)
.DEF    TILE_BACK_3X3           $f4     ; back, middle-right (row 3)
.DEF    TILE_BACK_4X1           $d5     ; back, bottom-left
.DEF    TILE_BACK_4X2           $e5     ; back, bottom-centre
.DEF    TILE_BACK_4X3           $f5     ; back, bottom-right

; face-up:
;-------------------------------------------------------------------------------
; the top-left corner of a face-up card has the
; ordinal (number) of the card, Ace through King:
;
.DEF    TILE_CARD_1X1           $80
.DEF    TILE_CARD_1X1_A         $80     ; Ace
.DEF    TILE_CARD_1X1_2         $82     ; Two
.DEF    TILE_CARD_1X1_3         $84     ; Three
.DEF    TILE_CARD_1X1_4         $86     ; Four
.DEF    TILE_CARD_1X1_5         $88     ; Five
.DEF    TILE_CARD_1X1_6         $8a     ; Six
.DEF    TILE_CARD_1X1_7         $8c     ; Seven
.DEF    TILE_CARD_1X1_8         $8e     ; Eight
.DEF    TILE_CARD_1X1_9         $90     ; Nine
.DEF    TILE_CARD_1X1_10        $92     ; Ten
.DEF    TILE_CARD_1X1_J         $94     ; Jack
.DEF    TILE_CARD_1X1_Q         $96     ; Queen
.DEF    TILE_CARD_1X1_K         $98     ; King

; the top-centre of a face-up card is blank
.DEF    TILE_CARD_1X2           $9a

; the top-right of a face-up card has the suit:
;
.DEF    TILE_CARD_1X3           $c0
.DEF    TILE_CARD_1X3_SPD       $c2     ; Spades
.DEF    TILE_CARD_1X3_CLB       $c4     ; Clubs
.DEF    TILE_CARD_1X3_HRT       $c6     ; Hearts
.DEF    TILE_CARD_1X3_DMD       $c8     ; Diamonds

; the left, centre and right of the middle
; portion of the card (two-rows) is blank:
;
.DEF    TILE_CARD_2X1           $81
.DEF    TILE_CARD_2X2           $9b
.DEF    TILE_CARD_2X3           $a0
.DEF    TILE_CARD_3X1           $81
.DEF    TILE_CARD_3X2           $9b
.DEF    TILE_CARD_3X3           $a0

; the bottom-left of a face-up card has the suit:
;
.DEF    TILE_CARD_4X1           $c9
.DEF    TILE_CARD_4X1_SPD       $c9     ; Spades
.DEF    TILE_CARD_4X1_CLB       $cb     ; Clubs
.DEF    TILE_CARD_4X1_HRT       $cd     ; Hearts
.DEF    TILE_CARD_4X1_DMD       $cf     ; Diamonds

; the bottom-centre is blank
.DEF    TILE_CARD_4X2           $9d

; the bottom-right of a face-up card has the ordinal:
;
.DEF    TILE_CARD_4X3           $a1
.DEF    TILE_CARD_4X3_A         $a1     ; Ace
.DEF    TILE_CARD_4X3_2         $a3     ; Two
.DEF    TILE_CARD_4X3_3         $a5     ; Three
.DEF    TILE_CARD_4X3_4         $a7     ; Four
.DEF    TILE_CARD_4X3_5         $a9     ; Five
.DEF    TILE_CARD_4X3_6         $ab     ; Six
.DEF    TILE_CARD_4X3_7         $ad     ; Seven
.DEF    TILE_CARD_4X3_8         $af     ; Eight
.DEF    TILE_CARD_4X3_9         $b1     ; Nine
.DEF    TILE_CARD_4X3_10        $b3     ; Ten
.DEF    TILE_CARD_4X3_J         $b5     ; Jack
.DEF    TILE_CARD_4X3_Q         $b7     ; Queen
.DEF    TILE_CARD_4X3_K         $b9     ; King

; card tilemaps:
;===============================================================================
tilemap_empty:
        ;-----------------------------------------------------------------------
        ; this is the dotted-outline used for showing an empty pile,
        ; such as the deck, hand, or foundation
        ;
@row1:  .byte   TILE_FNDT_1X1, TILE_FNDT_1X2, TILE_FNDT_1X3
@row2:  .byte   TILE_FNDT_2X1, TILE_FNDT_2X2, TILE_FNDT_2X3
@row3:  .byte   TILE_FNDT_3X1, TILE_FNDT_3X2, TILE_FNDT_3X3
@row4:  .byte   TILE_FNDT_4X1, TILE_FNDT_4X2, TILE_FNDT_4X3

tilemap_deck:
        ;-----------------------------------------------------------------------
        ; a full deck
        ;
@row0:  .byte   TILE_DECK_0X1, TILE_DECK_0X2, TILE_DECK_0X3
@row1:  .byte   TILE_DECK_1X1, TILE_DECK_1X2, TILE_DECK_1X3
@row2:  .byte   TILE_DECK_2X1, TILE_DECK_2X2, TILE_DECK_2X3
@row3:  .byte   TILE_DECK_3X1, TILE_DECK_3X2, TILE_DECK_3X3
@row4:  .byte   TILE_DECK_4X1, TILE_DECK_4X2, TILE_DECK_4X3


tilemap_back:
        ;-----------------------------------------------------------------------
        ; the back of a card
        ;
@row1:  .byte   TILE_BACK_1X1, TILE_BACK_1X2, TILE_BACK_1X3
@row2:  .byte   TILE_BACK_2X1, TILE_BACK_2X2, TILE_BACK_2X3
@row3:  .byte   TILE_BACK_3X1, TILE_BACK_3X2, TILE_BACK_3X3
@row4:  .byte   TILE_BACK_4X1, TILE_BACK_4X2, TILE_BACK_4X3

;###############################################################################
.ENDS


init:
;===============================================================================
        ldh     A,      [<LCDC]
        or      LCDC.window_select      ; use $9C00 for the window-map
        or      LCDC.bg_display         ; turn background on
        ldh     [<LCDC],        A

        call    clearQueue              ; clear the tile update queue
        call    copyMainTileset         ; copy main tileset from ROM to VRAM

        call    tableau.clearTiles      ; clear the tableau (playing space)
        call    menu.clear              ; clear and draw the menu

        call    refresh

        ; set palette:
        ld      A,      TILE_PALETTE
        ld      [BGP],  A

        rst     rst_screenOn
        ret


clearQueue:
;===============================================================================
; empty the tile-update queue, used to defer VRAM changes to vblank:
;
;-------------------------------------------------------------------------------
        ld      HL,     tile_queue
        ld      BC,     _sizeof_tile_queue
        jp      zero


copyMainTileset:
;===============================================================================
; copy the main tileset used throughout the game:
;
; TODO: check vblank/lcd-stat for safety on CGB, we can use DMA to do this
;-------------------------------------------------------------------------------
        ld      HL,     tiles_main      ; set source address
        ld      DE,     VRAM_TILES2     ; set destination VRAM position

        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_main__size / 16) - 1


copyTiles:
;===============================================================================
; copy a number of graphic tiles to VRAM:
;
; in:   HL      starting address of tiles
;       DE      VRAM destination, e.g. $8000
;       B       number of tiles to copy, 1-based
;               use "0" for 256 tiles
;
; TODO: on GBC we could do this using DMA?
;-------------------------------------------------------------------------------
.REPEAT 15
        ld      A,      [HL+]                                           ;+8
        ld      [DE],   A                                               ;+8
        inc     E                                                       ;+4
.ENDR
        ld      A,      [HL+]                                           ;+8
        ld      [DE],   A                                               ;+8
        inc     DE                                                      ;+8
        
        dec     B
        jr      nz, copyTiles
        
        ret


getBufferAddr:
;===============================================================================
; given an X & Y tile co-ordinate, return an address in the screen-buffer:
;
; in:   B       y-position (row) in the tile-map (32x32)
;       C       x-position (column) in the tile-map (32x32)
;
; out:  HL      address within the screen-buffer                         
;       A, DE   (preserved)                                             
;       BC      (clobbered)                                             ;cycles
;-------------------------------------------------------------------------------
        ; we need to multiply Y (row) by 32
        ld      H,      0               ; prepare HL,
        ld      L,      B               ; with row-number only

        ; TODO: use a lookup table of rows (just 64 bytes!)
        ;       also, we could use SWAP to partially multiply by 4,
        ;       but this requires the A register which we need to preserve
        ;       <github.com/pret/pokecrystal/wiki/Optimizing-assembly-code>
        ;
        add     HL,     HL              ; x2
        add     HL,     HL              ; x4
        add     HL,     HL              ; x8
        add     HL,     HL              ; x16
        add     HL,     HL              ; x32

        ld      B,      0               ; prepare BC with column only
        add     HL,     BC              ; add the column
        ld      BC,     front_buffer    ; get screen-buffer address
        add     HL,     BC              ; finally, add our offset

        ret


writeTiles_5rows:
;===============================================================================
        call    writeTiles

writeTiles_4rows:
;===============================================================================
        call    writeTiles

writeTiles_3rows:
;===============================================================================
        call    writeTiles

writeTiles_2rows:
;===============================================================================
        call    writeTiles

writeTiles_1row:
;===============================================================================
writeTiles:
;===============================================================================
; in:   DE      address with tiles to read from
;       HL      address to write to, where 3 tiles are written and then
;               the address is moved to the next row of the tilemap
;-------------------------------------------------------------------------------
        ld      BC,     29

        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        rla                             ; preserve carry flag!
        add     HL,     BC
        rra                             ; restore carry flag!

        ret


refresh:
;===============================================================================
; forces a full update of the background tilemap:
;
; normally updates to the tilemap are done partially -- only the tiles that
; have changed between the front & back buffers are written during vblank
;
; a full update copies the current front buffer to the back buffer, then
; the full back buffer is copied to VRAM in one go. the screen cannot be
; on whilst this happens as writes to VRAM outside of vblank are ignored
;
; TODO: on GBC we can use DMA
;-------------------------------------------------------------------------------
        ; clear the update queue to prevent changes to VRAM during vblank
        call    clearQueue

        ; copy front buffer to back buffer:
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        call    @copy

        ; copy back buffer to VRAM:
        ;
        ; on the GameBoy, VRAM is memory-mapped,
        ; though it is inaccessible outside of vblank
        ;
        ld      HL,     back_buffer
        ld      DE,     VRAM_MAP1

        ; copy 1'024 bytes:
        ;-----------------------------------------------------------------------
@copy:  ld      C,      0

-       ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     DE
        dec     C
        jr      nz, -

        ret


update:
;===============================================================================
; compares the differences between the front & back buffers and generates
; the list of VRAM changes (tile queue) to make during vblank:
;
;-------------------------------------------------------------------------------
        ; disable vblank interrupts whilst we update the queue;
        ; we don't want the queue being emptied whilst we're writing to it!
        ; TODO: we could use a flag to deny tile updates during vblank
        ld      HL,     IRQ_ENABLE
        res     0,      [HL]            ; turn off vblank interrupts (bit 0)
        
        ; set the position in the tile queue to the top;
        ; entries will be written backward to be able to
        ; make use of POP when reading!
        ld      A,      _sizeof_tile_queue
        ld      [_queue_index], A

        ; start walking the buffers
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        ld      BC,     _sizeof_front_buffer+1

        ; (jump into the functional part of the loop)
        jr      @read
        
        ;-----------------------------------------------------------------------
@next:  dec     BC                      ; one less tile to process...
        jr      z,      @exit           ; all done? exit

        inc     DE                      ; move forward in the back-buffer
        inc     HL                      ; and keep the front-buffer in step

        ; loop begins here...
        ;
@read:  ld      A,      [DE]            ; read tile from back-buffer
        cp      [HL]                    ; compare with front-buffer
        jr      z,      @next           ; if they're the same, keep scanning

        ; there's a difference!
        ; queue the tile change:
        ;-----------------------------------------------------------------------
        push    DE                      ; (backup back-buffer position)
        push    HL                      ; (backup front-buffer position)

        ; calculate the VRAM address from our current
        ; index in the front & back buffers...
        ld      HL,     VRAM_MAP1
        add     HL,     BC              ; (only HL can do 16-bit adds)
        ld      D,      H               ; put aside in DE; this is still
        ld      E,      L               ; faster than `PUSH HL, POP DE`

        ; get current update queue position:
        ;
        ; note that the queue index starts at the end of the queue memory
        ; and works backwards due to the use of POP to read the queue!
        ;
        ; TODO: handle queue overflow. stop processing buffers, and wait
        ;       for vblank so that the queue can be refilled again?
        ;
        ld      HL,     _queue_index
        dec     [HL]
        ld      L,      [HL]            ; read the current queue index
        ld      H,      >tile_queue     ; set hi-byte, HL = free queue address

        ; write the data to the queue:
        ; TODO: has to be reversed for POPing
        ;
        ld      [HL],   D               ; write hi-byte
        dec     L
        ld      [HL],   E               ; write lo-byte
        dec     L
        ; the tile data is written as two bytes even though we only use one;
        ; surprisingly, this is for a critical optimisation during vblank
        ;
        ld      [HL-],  A               ; write tile to draw
        ld      [HL],   %10000000       ; write flags with zero-flag unset!
        
        ; write back the updated queue index
        ld      A,      L
        ld      [_queue_index], A

        pop     HL                      ; (restore front buffer position)
        push    DE                      ; (restore back-buffer position)
        jr      @next

        ;-----------------------------------------------------------------------
        ; the last entry in the queue must be zero-terminated
@exit:  ld      HL,     _queue_index
        ld      L,      [HL]
        ld      H,      >tile_queue
        ld      [HL],   0               ; write a zero to mark the end

        ; re-enable vblank interrupts
        ld      HL,     IRQ_ENABLE
        set     0,      [HL]
        ret

;;        ; normal way to write a queue of disparate tiles:
;;        ; data is VRAM:HI, LO, TILE where HL is current
;;        ; address in queue and B is a counter:
;;        ;
;;-       ld      A,      [HL+]   ;+8 =8
;;        ld      D,      A       ;+4 =12
;;        ld      A,      [HL+]   ;+8 =20
;;        ld      E,      A       ;+4 =24
;;        ld      A,      [HL+]   ;+8 =32
;;        ld      [DE],   A       ;+8 =40
;;        dec     B               ;+4 =44
;;        jr      nz,     -       ;+12=56
;;
;;        ; faster method using the stack to POP from the
;;        ; queue instead. SP = queue address! note that
;;        ; the tile is 2-bytes in the queue so that
;;        ; `pop AF` can be used -- each queue entry
;;        ; sets the flags with this byte; the end
;;        ; of the queue is marked by a zero-byte!
;;        ;
;;-       pop     HL              ;+12=12
;;        pop     AF              ;+12=24
;;        ld      [HL],   A       ;+8 =32
;;        jr      nz,     -       ;+12=44