; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; since we cannot modify VRAM during the display period,
; changes are queued up and then applied during vblank
;
.STRUCT TileUpdate
        vram_addr       WORD
        tile            BYTE
        flags           BYTE
.ENDST

; (NOTE: we rely on this starting at an $xx00 address for optimisation)
.RAMSECTION "Queue"     ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        tile_queue      INSTANCEOF TileUpdate 32
        ; a flag to indicate that tiles are waiting to be processed
        queue_ready     BYTE
        ; temporary address (lo-byte) used whilst pushing tiles to the queue
        queue_index     BYTE
.ENDS

.RAMSECTION "Buffers"   ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        front_buffer    DSB TILEMAP_WIDTH*TILEMAP_HEIGHT
        back_buffer     DSB TILEMAP_WIDTH*TILEMAP_HEIGHT
.ENDS

; include the tile graphics and map the various pieces of the card graphics
; to some constants so that we don't have to tweak tile numbers throughout
; the code-base. we want this aligned to one-tile (16-bytes) for some
; tile-copying micro-optimisations
;
.SECTION "TilesCards"   ALIGN 16        RETURNORG
;###############################################################################
.DEF    TILE_PALETTE    %11010010

tiles_main:
;===============================================================================
.INCBIN "build/tiles.2bpp"              FSIZE tiles_main__size

; define the conversion from ASCII to the tile-numbers in our tileset:
;
.ASCIITABLE
        ;-----------------------------------------------------------------------
        ;;MAP   0 TO 127  = $80
        ;;MAP 128 TO 255  = $00

        MAP     " "     = $50
        MAP     "a"     = $51
        MAP     "b"     = $52
        MAP     "c"     = $53
        MAP     "d"     = $54
        MAP     "e"     = $55
        MAP     "f"     = $56
        MAP     "g"     = $57
        MAP     "h"     = $58
        MAP     "i"     = $59
        MAP     "j"     = $5a
        MAP     "k"     = $5b
        MAP     "l"     = $5c
        MAP     "m"     = $5d
        MAP     "n"     = $5e
        MAP     "o"     = $5f
        MAP     "p"     = $60
        MAP     "q"     = $61
        MAP     "r"     = $62
        MAP     "s"     = $63
        MAP     "t"     = $64
        MAP     "u"     = $65
        MAP     "v"     = $66
        MAP     "w"     = $67
        MAP     "x"     = $68
        MAP     "y"     = $69
        MAP     "z"     = $6a
        MAP     "!"     = $6b
        MAP     ","     = $6c
        MAP     "."     = $6d
        MAP     "A"     = $6e           ; GameBoy button "A"
        MAP     "B"     = $6f           ; GameBoy button "B"

        MAP     "0"     = $70
        MAP     "1"     = $71
        MAP     "2"     = $72
        MAP     "3"     = $73
        MAP     "4"     = $74
        MAP     "5"     = $75
        MAP     "6"     = $76
        MAP     "7"     = $77
        MAP     "8"     = $78
        MAP     "9"     = $79

        MAP     "S"     = $7a           ; spades symbol
        MAP     "C"     = $7b           ; clubs symbol
        MAP     "H"     = $7c           ; hearts symbol
        MAP     "D"     = $7d           ; diamonds symbol
.ENDA

; cards:
;===============================================================================
; foundation:
;-------------------------------------------------------------------------------
; a foundation is a blank space on the playfield where cards
; are "played off", into their final destination
;
.DEF    TILE_FNDT_1X1           $da     ; foundation, top-left
.DEF    TILE_FNDT_1X2           $ea     ; foundation, top-centre
.DEF    TILE_FNDT_1X3           $fa     ; foundation, top-right
.DEF    TILE_FNDT_2X1           $db     ; foundation, upper-middle left
.DEF    TILE_FNDT_2X2           $eb     ; foundation, upper-middle centre
.DEF    TILE_FNDT_2X3           $fb     ; foundation, upper-middle right
.DEF    TILE_FNDT_3X1           $dc     ; foundation, lower-middle left
.DEF    TILE_FNDT_3X2           $ec     ; foundation, lower-middle centre
.DEF    TILE_FNDT_3X3           $fc     ; foundation, lower-middle right
.DEF    TILE_FNDT_4X1           $dd     ; foundation, bottom-left
.DEF    TILE_FNDT_4X2           $ed     ; foundation, bottom-centre
.DEF    TILE_FNDT_4X3           $fd     ; foundation, bottom-right

; deck:
;-------------------------------------------------------------------------------
; a deck is a pile of face-down cards
;
.DEF    TILE_DECK_0X1           $d1     ; deck, top-left
.DEF    TILE_DECK_0X2           $e1     ; deck, top-centre
.DEF    TILE_DECK_0X3           $f1     ; deck, top-right

; the middle three rows of the deck repeat
.DEF    TILE_DECK_1X1           $d3     ; deck, middle-left (row 2)
.DEF    TILE_DECK_1X2           $e3     ; deck, middle-centre (row 2)
.DEF    TILE_DECK_1X3           $f3     ; deck, middle-right (row 2)
.DEF    TILE_DECK_2X1           $d3     ; deck, middle-left (row 3)
.DEF    TILE_DECK_2X2           $e3     ; deck, middle-centre (row 3)
.DEF    TILE_DECK_2X3           $f3     ; deck, middle-right (row 3)
.DEF    TILE_DECK_3X1           $d3     ; deck, bottom-left (row 4)
.DEF    TILE_DECK_3X2           $e3     ; deck, bottom-centre (row 4)
.DEF    TILE_DECK_3X3           $f3     ; deck, bottom-right (row 4)

; bottom-row of the deck
.DEF    TILE_DECK_4X1           $d6     ; deck, pile-left
.DEF    TILE_DECK_4X2           $e6     ; deck, pile-centre
.DEF    TILE_DECK_4X3           $f6     ; deck, pile-right

; back:
;-------------------------------------------------------------------------------
; a card, face-down:
;
.DEF    TILE_BACK_1X1           $d2     ; back, top-left
.DEF    TILE_BACK_1X2           $e2     ; back, top-centre
.DEF    TILE_BACK_1X3           $f2     ; back, top-right
.DEF    TILE_BACK_2X1           $d3     ; back, middle-left (row 2)
.DEF    TILE_BACK_2X2           $e3     ; back, middle-centre (row 2)
.DEF    TILE_BACK_2X3           $f3     ; back, middle-right (row 2)
.DEF    TILE_BACK_3X1           $d4     ; back, middle-left (row 3)
.DEF    TILE_BACK_3X2           $e4     ; back, middle-centre (row 3)
.DEF    TILE_BACK_3X3           $f4     ; back, middle-right (row 3)
.DEF    TILE_BACK_4X1           $d5     ; back, bottom-left
.DEF    TILE_BACK_4X2           $e5     ; back, bottom-centre
.DEF    TILE_BACK_4X3           $f5     ; back, bottom-right

; face-up:
;-------------------------------------------------------------------------------
; the top-left corner of a face-up card has the
; ordinal (number) of the card, Ace through King:
;
.DEF    TILE_CARD_1X1           $80
.DEF    TILE_CARD_1X1_A         $80     ; Ace
.DEF    TILE_CARD_1X1_2         $82     ; Two
.DEF    TILE_CARD_1X1_3         $84     ; Three
.DEF    TILE_CARD_1X1_4         $86     ; Four
.DEF    TILE_CARD_1X1_5         $88     ; Five
.DEF    TILE_CARD_1X1_6         $8a     ; Six
.DEF    TILE_CARD_1X1_7         $8c     ; Seven
.DEF    TILE_CARD_1X1_8         $8e     ; Eight
.DEF    TILE_CARD_1X1_9         $90     ; Nine
.DEF    TILE_CARD_1X1_10        $92     ; Ten
.DEF    TILE_CARD_1X1_J         $94     ; Jack
.DEF    TILE_CARD_1X1_Q         $96     ; Queen
.DEF    TILE_CARD_1X1_K         $98     ; King

; the top-centre of a face-up card is blank
.DEF    TILE_CARD_1X2           $9a

; the top-right of a face-up card has the suit:
.DEF    TILE_CARD_1X3           $c0
.DEF    TILE_CARD_1X3_SPD       $c2     ; Spades
.DEF    TILE_CARD_1X3_CLB       $c4     ; Clubs
.DEF    TILE_CARD_1X3_HRT       $c6     ; Hearts
.DEF    TILE_CARD_1X3_DMD       $c8     ; Diamonds

; the left, centre and right of the middle
; portion of the card (two-rows) is blank:
.DEF    TILE_CARD_2X1           $81
.DEF    TILE_CARD_2X2           $9b
.DEF    TILE_CARD_2X3           $a0
.DEF    TILE_CARD_3X1           $81
.DEF    TILE_CARD_3X2           $9b
.DEF    TILE_CARD_3X3           $a0

; the bottom-left of a face-up card has the suit:
.DEF    TILE_CARD_4X1           $c9
.DEF    TILE_CARD_4X1_SPD       $c9     ; Spades
.DEF    TILE_CARD_4X1_CLB       $cb     ; Clubs
.DEF    TILE_CARD_4X1_HRT       $cd     ; Hearts
.DEF    TILE_CARD_4X1_DMD       $cf     ; Diamonds

; the bottom-centre is blank
.DEF    TILE_CARD_4X2           $9d

; the bottom-right of a face-up card has the ordinal:
.DEF    TILE_CARD_4X3           $a1
.DEF    TILE_CARD_4X3_A         $a1     ; Ace
.DEF    TILE_CARD_4X3_2         $a3     ; Two
.DEF    TILE_CARD_4X3_3         $a5     ; Three
.DEF    TILE_CARD_4X3_4         $a7     ; Four
.DEF    TILE_CARD_4X3_5         $a9     ; Five
.DEF    TILE_CARD_4X3_6         $ab     ; Six
.DEF    TILE_CARD_4X3_7         $ad     ; Seven
.DEF    TILE_CARD_4X3_8         $af     ; Eight
.DEF    TILE_CARD_4X3_9         $b1     ; Nine
.DEF    TILE_CARD_4X3_10        $b3     ; Ten
.DEF    TILE_CARD_4X3_J         $b5     ; Jack
.DEF    TILE_CARD_4X3_Q         $b7     ; Queen
.DEF    TILE_CARD_4X3_K         $b9     ; King

; card tilemaps:
;===============================================================================
tilemap_empty:
        ;-----------------------------------------------------------------------
        ; this is the dotted-outline used for showing an empty pile,
        ; such as the deck, hand, or foundation
        ;
@row1:  .byte   TILE_FNDT_1X1, TILE_FNDT_1X2, TILE_FNDT_1X3
@row2:  .byte   TILE_FNDT_2X1, TILE_FNDT_2X2, TILE_FNDT_2X3
@row3:  .byte   TILE_FNDT_3X1, TILE_FNDT_3X2, TILE_FNDT_3X3
@row4:  .byte   TILE_FNDT_4X1, TILE_FNDT_4X2, TILE_FNDT_4X3

tilemap_deck:
        ;-----------------------------------------------------------------------
        ; a full deck
        ;
@row0:  .byte   TILE_DECK_0X1, TILE_DECK_0X2, TILE_DECK_0X3
@row1:  .byte   TILE_DECK_1X1, TILE_DECK_1X2, TILE_DECK_1X3
@row2:  .byte   TILE_DECK_2X1, TILE_DECK_2X2, TILE_DECK_2X3
@row3:  .byte   TILE_DECK_3X1, TILE_DECK_3X2, TILE_DECK_3X3
@row4:  .byte   TILE_DECK_4X1, TILE_DECK_4X2, TILE_DECK_4X3


tilemap_back:
        ;-----------------------------------------------------------------------
        ; the back of a card
        ;
@row1:  .byte   TILE_BACK_1X1, TILE_BACK_1X2, TILE_BACK_1X3
@row2:  .byte   TILE_BACK_2X1, TILE_BACK_2X2, TILE_BACK_2X3
@row3:  .byte   TILE_BACK_3X1, TILE_BACK_3X2, TILE_BACK_3X3
@row4:  .byte   TILE_BACK_4X1, TILE_BACK_4X2, TILE_BACK_4X3

;###############################################################################
.ENDS


init:
;===============================================================================
        ldh     A,      [<LCDC]
        or      LCDC.window_select      ; use $9C00 for the window-map
        or      LCDC.bg_display         ; turn background on
        ldh     [<LCDC],        A

        call    clearQueue              ; clear the tile update queue
        call    copyMainTileset         ; copy main tileset from ROM to VRAM

        call    tableau.clearTiles      ; clear the tableau (playing space)
        call    menu.clear              ; clear and draw the menu
        call    refresh                 ; do a full screen refresh

        ; set palette:
        ld      A,      TILE_PALETTE
        ld      [BGP],  A

        rst     rst_screenOn
        ret


clearQueue:
;===============================================================================
; empty the tile-update queue, used to defer VRAM changes to vblank:
;-------------------------------------------------------------------------------
        ; ready flag must be cleared first so that VRAM tile updates
        ; do not occur whilst we are erasing the tile queue!
        xor     A                       ; (set A to zero)
        ld      [queue_ready],  A
        ; erase the queue
        ld      HL,     tile_queue
        ld      BC,     _sizeof_tile_queue
        jp      zero


copyMainTileset:
;===============================================================================
; copy the main tileset used throughout the game:
;
; TODO: check vblank/lcd-stat for safety on CGB, we can use DMA to do this
;-------------------------------------------------------------------------------
        ld      HL,     tiles_main      ; set source address
        ld      DE,     VRAM_TILES2     ; set destination VRAM position

        ; number of tiles to copy, 0-based
        ; (each tile is 16-bytes)
        ld      B,      (tiles_main__size / 16) - 1

copyTiles:
;===============================================================================
; copy a number of graphic tiles to VRAM:
;
; in:   HL      starting address of tiles
;       DE      VRAM destination, e.g. $8000
;       B       number of tiles to copy, 1-based
;               use "0" for 256 tiles
;
; TODO: on GBC we could do this using DMA?
;-------------------------------------------------------------------------------
.REPEAT 15
        ld      A,      [HL+]                                           ;+8
        ld      [DE],   A                                               ;+8
        inc     E                                                       ;+4
.ENDR
        ld      A,      [HL+]                                           ;+8
        ld      [DE],   A                                               ;+8
        inc     DE                                                      ;+8
        
        dec     B
        jr      nz, copyTiles
        
        ret


getBufferAddr:
;===============================================================================
; given an X & Y tile co-ordinate, return an address in the screen-buffer:
;
; in:   B       y-position (row) in the tile-map (32x32)
;       C       x-position (column) in the tile-map (32x32)
;
; out:  HL      address within the screen-buffer
;       A, DE   (preserved)
;       BC      (clobbered)
;-------------------------------------------------------------------------------
        ; we need to multiply Y (row) by 32
        ld      H,      0               ; prepare HL,
        ld      L,      B               ; with row-number only

        ; TODO: use a lookup table of rows (just 64 bytes!)
        ;       also, we could use SWAP to partially multiply by 4,
        ;       but this requires the A register which we need to preserve
        ;       <github.com/pret/pokecrystal/wiki/Optimizing-assembly-code>
        ;
        add     HL,     HL              ; x2
        add     HL,     HL              ; x4
        add     HL,     HL              ; x8
        add     HL,     HL              ; x16
        add     HL,     HL              ; x32

        ld      B,      0               ; prepare BC with column only
        add     HL,     BC              ; add the column
        ld      BC,     front_buffer    ; get screen-buffer address
        add     HL,     BC              ; finally, add our offset

        ret


writeTiles_5rows:
;===============================================================================
        call    writeTiles

writeTiles_4rows:
;===============================================================================
        call    writeTiles

writeTiles_3rows:
;===============================================================================
        call    writeTiles

writeTiles_2rows:
;===============================================================================
        call    writeTiles

writeTiles_1row:
;===============================================================================
writeTiles:
;===============================================================================
; in:   DE      address with tiles to read from
;       HL      address to write to, where 3 tiles are written and then
;               the address is moved to the next row of the tilemap
; out: carry    (preserved)
;-------------------------------------------------------------------------------
        ; number of bytes to add to the address to skip to the next screen row
        ld      BC,     TILEMAP_WIDTH-3

        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        ld      A,      [DE]
        inc     DE
        ld      [HL+],  A
        rla                             ; preserve carry flag!
        add     HL,     BC
        rra                             ; restore carry flag!

        ret


refresh:
;===============================================================================
; forces a full update of the background tilemap:
;
; SCREEN MUST BE OFF WHEN CALLING THIS ROUTINE!
; (use `rst rst_screenOff`)
;
; normally updates to the tilemap are done partially -- only the tiles that
; have changed between the front & back buffers are written during vblank
;
; a full update copies the current front buffer to the back buffer, then
; the full back buffer is copied to VRAM in one go. the screen cannot be
; on whilst this happens as writes to VRAM outside of vblank are ignored
;
; TODO: on GBC we can use DMA
;-------------------------------------------------------------------------------
        ; clear the update queue to prevent changes to VRAM during vblank
        call    clearQueue

        ; copy front buffer to back buffer:
        ld      HL,     front_buffer
        ld      DE,     back_buffer
        call    @copy

        ; copy back buffer to VRAM:
        ;
        ; on the GameBoy, VRAM is memory-mapped,
        ; though it is inaccessible outside of vblank
        ;
        ld      HL,     back_buffer
        ld      DE,     VRAM_MAP1

        ; copy 1'024 bytes:
        ;-----------------------------------------------------------------------
@copy:  ld      C,      0

-       ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     E
        ld      A,      [HL+]
        ld      [DE],   A
        inc     DE
        dec     C
        jr      nz, -

        ret


update:
;===============================================================================
; compares the differences between the front & back buffers and generates
; the list of VRAM changes (tile queue) to make during vblank:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        xor     A                       ; (set A to 0)
        ld      [queue_ready],  A       ; disable tile updates during vblank
        ld      [queue_index],  A       ; begin at start of queue

        ; start walking the buffers
        ld      HL,     back_buffer
        ld      DE,     front_buffer
        ld      BC,     0

        ; (jump into the functional part of the loop)
        jr      @read
        
        ;-----------------------------------------------------------------------
@next:  inc     BC                      ; one less tile to process...
        bit     2,      B
        jr      nz,     @exit           ; all done? exit

        inc     DE                      ; move forward in the front-buffer
        inc     HL                      ; and keep the back-buffer in step

        ; loop begins here...
        ;
@read:  ld      A,      [DE]            ; read tile from front-buffer
        cp      [HL]                    ; compare with back-buffer
        jr      z,      @next           ; if they're the same, keep scanning

        ; there's a difference! update the back-buffer
        ; to match the front (for future comparisions)
        ld      [HL],   A

        ; queue the tile update:
        ;-----------------------------------------------------------------------
        push    DE                      ; (backup front-buffer position)
        push    HL                      ; (backup back-buffer position)

        ; calculate the VRAM address from our current
        ; index in the front & back buffers...
        ld      HL,     VRAM_MAP1
        add     HL,     BC              ; (only HL can do 16-bit adds)
        ld      D,      H               ; put aside in DE; this is still
        ld      E,      L               ; faster than `PUSH HL, POP DE`

        ; get current update queue position:
        ;
        ; note that the queue index starts at the end of the queue memory
        ; and works backwards due to the use of POP to read the queue!
        ;
        ; TODO: handle queue overflow. stop processing buffers, and wait
        ;       for vblank so that the queue can be refilled again?
        ;
        ld      HL,     queue_index
        ld      L,      [HL]            ; read the current queue index
        ld      H,      >tile_queue     ; set hi-byte, HL = free queue address

        ; write the data to the queue:
        ; these bytes need to be written in the order that POP would read them
        ;
        ld      [HL],   E               ; write lo-byte
        inc     L
        ld      [HL],   D               ; write hi-byte
        inc     L
        ; the tile data is written as two bytes even though we only use one;
        ; surprisingly, this is for a critical optimisation during vblank.
        ; when this value is POPed, the first byte will become the cpu flags!
        ;
        ld      [HL],   %10000000       ; write cpu flags!
        inc     L
        ld      [HL+],  A               ; write tile to draw
        
        ; write back the updated queue index
        ld      A,      L
        ld      [queue_index],  A

        pop     HL                      ; (restore back-buffer position)
        pop     DE                      ; (restore front-buffer position)
        jr      @next

        ;-----------------------------------------------------------------------
        ; the last entry in the queue must be zero-terminated
        ;
@exit:  xor     A                       ; (set A to zero)
        ld      HL,     queue_index
        ld      L,      [HL]
        ld      H,      >tile_queue
        dec     L                       ; move past tile,
        dec     L                       ; to cpu flags
        ld      [HL],   A               ; write a zero to mark the end

        ; queue is ready, allow tile updates from vblank
        dec     A                       ; (set A to $FF)
        ld      [queue_ready],  A
        ret