; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 playfield.
; for our purposes we place the menu on the left and the playfield next to it,
; therefore the playfield begins at X = 12 and not the top-left (X = 0)
.DEF    TABLEAU_TOP     0
.DEF    TABLEAU_LEFT    MENU_WIDTH
.DEF    TABLEAU_ADDR    \
        tilemap.front_buffer + (TABLEAU_TOP * TILEMAP_WIDTH) + TABLEAU_LEFT
.DEF    TABLEAU_WIDTH   TILEMAP_WIDTH - MENU_WIDTH
.DEF    TABLEAU_HEIGHT  TILEMAP_HEIGHT


.RAMSECTION "Cursor"    RETURNORG
        ;-----------------------------------------------------------------------
        ; the index of the Pile struct that the cursor is pointing to;
        ; e.g. deck / depot
        pile_point      BYTE
        ; the number of the card in the pile the cursor is pointing at.
        ; note that this is 0-based and not 1-based like the pile size!
        card_point      BYTE
        ;-----------------------------------------------------------------------
        ; when the cursor picks up a pile of cards, they are removed from
        ; the original pile and have to be stored elsewhere, so this pool
        ; exists specifically for the cards in the cursor's hand. the storage
        ; pool is not used so that the cursor's pool has a fixed address
        ; that makes it easier to work with
        ;
        ; TODO: is 13 cards enough? what's the largest pile
        ;       (note sprites limit us to 12 cards!)
        hand_cards      DSB 13+1         ; +1 for zero-terminator!
.ENDS

; the pile used to hold cards in the cursor's hand needs a template;
; force this template to use the fixed pool address!
.REDEF  __pool_addr             tableau.hand_cards

        ; label,                type, max-cards,
        ; row,                  col,
        ; pile-left,            pile-right,
        ; pile-up,              pile-down
piles.Define \
        pile_template,          TYPE_COLUMN | TYPE_HORZ, 13, \
        TILEMAP_HEIGHT-4,       TABLEAU_LEFT + 1, \
        0,                      0, \
        0,                      0


init:
;===============================================================================
        ; configure the pile for holding cards in the cursor hand
        ;-----------------------------------------------------------------------
        ld      BC,     pile_template   ; the ROM template to copy from
        ld      L,      INDEX_CURSOR    ; which pile to allocate
        jp      piles.allocate


clearTiles:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ld      A,      TILE_TABLEAU_BG
        ; starting address of the tableau in the *front buffer*
        ld      HL,     TABLEAU_ADDR
        ; (number of tiles to skip to next row)
        ld      DE,     TILEMAP_WIDTH - SCREEN_WIDTH

        ld      C,      TABLEAU_HEIGHT
@row:   ;-----------------------------------------------------------------------
.REPEAT TABLEAU_WIDTH
        ld      [HL+],  A       ; set cell to empty background tile
.ENDR
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


clearCursorCards:
;===============================================================================
; removes the cards from the cursor hand / pile:
;
; WARNING: the cards should be "dropped" on to another pile
; before calling this otherwise they will be permenantly lost!
;
; out:  DE      (preserved) -- required for `pickPile`
;       BC      (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; set the size of the cursor's pile to zero
        xor     A                       ; (set A to zero)
        ld      HL,     piles.count+INDEX_CURSOR
        ld      [HL],   A

        ; zero out the list of cards in the private cursor pool
        ld      HL,     hand_cards
        call    fill@x{_sizeof_hand_cards}
        jp      cursor.clearSprites


refresh:
;===============================================================================
; redraw the tableau:
;-------------------------------------------------------------------------------
        ; we're going to redraw all piles,
        ; so clear the tabelau of tiles first
        call    clearTiles
        ; evaluate which cards are available for play and which are not,
        ; marking cards as enabled or disabled as appropriate. when the
        ; piles are drawn, disabled cards will be drawn 'greyed-out'
        call    piles.checkPiles

        ; redraw each pile:
        ld      L,      INDEX_DECK
        call    drawPile
        ld      L,      INDEX_DISCARD
        call    drawPile
        ld      L,      INDEX_HAND
        call    drawPile
        ld      L,      INDEX_FOUNDATION1
        call    drawPile
        ld      L,      INDEX_FOUNDATION2
        call    drawPile
        ld      L,      INDEX_FOUNDATION3
        call    drawPile
        ld      L,      INDEX_FOUNDATION4
        call    drawPile
        ld      L,      INDEX_DEPOT1
        call    drawPile
        ld      L,      INDEX_DEPOT2
        call    drawPile
        ld      L,      INDEX_DEPOT3
        call    drawPile
        ld      L,      INDEX_DEPOT4
        call    drawPile
        ld      L,      INDEX_DEPOT5
        call    drawPile
        ld      L,      INDEX_DEPOT6
        call    drawPile
        ld      L,      INDEX_DEPOT7
        call    drawPile
        ld      L,      INDEX_DEPOT8
        call    drawPile
        ld      L,      INDEX_DEPOT9
        call    drawPile
        ld      L,      INDEX_DEPOT10
        call    drawPile
        ld      L,      INDEX_DEPOT11
        call    drawPile
        ld      L,      INDEX_DEPOT12
        
        ; just fall through to routine below
        ;

drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; in:   L       index (`INDEX_*`) of the pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; we automatically skip unallocated piles (type is 0):
        ; this is because the tableau attempts to draw all piles
        ; and only those a particular game uses should be drawn
        ;
        ld      H,      FIELD_TYPE
        ld      A,      [HL]            ; read pile type
        and     A,      A               ; (set flags!)
        ret     z                       ; if pile is unallocated, quit

        call    piles.getPos            ; get pile row & col (BC)

        ; is the pile empty?
        rst     piles.rst_pileCount     ; (get pile count, set flags)
        jr      z,      @empty          ; if zero, draw empty space

        ; check the specific type of pile:
        ; (note that A, card-count, is preserved through this)
        ;
        ld      H,      FIELD_TYPE      ; switch field back again
        bit     BIT_SQUARE,     [HL]    ; is it a stack?
        jr      nz,     @stack          ; -> handle stack-type piles
        bit     BIT_HORZ,       [HL]    ; is it a horizontal pile?
        jr      nz,     @row            ; -> handle horizontal spreads

        ; column:
        ;=======================================================================
@col:   rst     piles.rst_poolAddr      ; get card pool address (DE)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr

        ; retain the card-count for iterating through the pile;
        ; we will be counting toward zero, even though we will
        ; be drawing cards in order from index 0 upwards
        ld      C,      A
        ; subtract one because we want to draw the tops of all but the last
        ; card. once we've looped through the covered cards, we draw the
        ; top-most card separately
        dec     C
        ; of course, if there's only one card in the pile,
        ; just skip to drawing that in whole
        jr      z,      @@last
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)
        call    drawCardEdgeTop         ; draw only the first line of tiles
        pop     DE
        inc     DE                      ; move to next card in pile
        dec     C
        jr      nz,     -
        ;-----------------------------------------------------------------------
@@last  ld      A,      [DE]            ; read the top-most card
        jp      drawCard                ; draw it whole (and return)

        ;=======================================================================
        ; row:
        ;
@row:   rst     piles.rst_poolAddr      ; get card pool address (DE)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr
        
        ; retain the card-count for iterating through the pile;
        ; we will be counting toward zero, even though we will
        ; be drawing cards in order from index 0 upwards
        ld      C,      A
        ; subtract one because we want to draw the sides of all but the last
        ; card. once we've looped through the covered cards, we draw the
        ; top-most card separately
        dec     C
        ; of course, if there's only one card in the pile,
        ; just skip to drawing that in whole
        jr      z,      @@last
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)
        call    drawCardEdgeLeft        ; draw only the first column of tiles
        pop     DE
        inc     DE                      ; move to next card in pile
        dec     C
        jr      nz,     -
        ;-----------------------------------------------------------------------
@@last  ld      A,      [DE]            ; read the top-most card
        jp      drawCard                ; draw it whole (and return)

        ;=======================================================================
        ; empty pile:
        ;
@empty: call    tilemap.getBufferAddr   ; translate row/col to buffer address

        ; draw the pre-baked empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_4rows

        ;=======================================================================
        ; stacks:
        ;
        ; is it a face-down stack (e.g. deck),
        ; or face-up stack (e.g. foundation)?
@stack: bit     BIT_FACE,       [HL]
        jr      nz,     @face

        ; read the top-most card in the pile
        call    piles.getLastCard
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_5rows

        ;=======================================================================
        ; stack with face-up card:
        ;
@face:  call    piles.getLastCard
        call    tilemap.getBufferAddr   ; translate to a buffer address

        ; fall through to below to draw
        ; the singular face-up card!
        ;

drawCard:
;===============================================================================
; draws a card, handling all of its different properties:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  BC      (preserved)
;       DE, HL  (clobbered)
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; draw the card in full
        jp      tilemap.writeTiles_4rows

        ;=======================================================================
        ; face-up:
        ;
@face:  push    AF

        call    drawCardEdgeTop

        pop     AF
        ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside

        ;-----------------------------------------------------------------------
        ; middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y2X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y2X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y2X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        call    drawCardEdgeTop@next    ; move to the next row
        ld      A,      TILE_CARD_Y3X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y3X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y3X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-left: suit
        ;-----------------------------------------------------------------------
        call    drawCardEdgeTop@next    ; move to the next row
        ld      A,      D               ; retrieve card value once again
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y4X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y4X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-right: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; retrieve ordinal from earlier
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y4X3-1        ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ret


drawCardEdgeTop:
;===============================================================================
; for cards in a column where one card covers another,
; and we need to draw only the top edge of a card:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  HL      the buffer address is advanced to the next tilemap row
;       BC      (preserved)
;       AF, DE  (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; draw only the first line of the tiles
        jp      tilemap.writeTiles_1row

        ;=======================================================================
        ; face-up:
        ;
@face:  ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y1X1-1        ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y1X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-right corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y1X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ; fall through to automatically
        ; move to the next tilemap row
        ;

        ;=======================================================================
        ; move to the next tilemap row:
        ;-----------------------------------------------------------------------
        ; we could use `add HL, BC` but we want to preserve BC
        ;
@next:  ld      A,      TILEMAP_WIDTH-3 ; number of tiles to skip to next row
        add     A,      L               ; add this to the address lo-byte
        jr      nc,     +               ; did that overflow?
        inc     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret


drawCardEdgeLeft:
;===============================================================================
; for cards in a row where one card covers another,
; and we need to draw only the left edge of a card:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  HL      the buffer address is advanced to the next tilemap column
;       BC      (preserved)
;       AF, DE  (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back_left
        ; draw only the first line of the tiles
        jp      tilemap.writeTiles_1col

        ;=======================================================================
        ; face-up:
        ;
@face:  ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y1X1-1        ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ;-----------------------------------------------------------------------
        ; middle-left:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y2X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ld      A,      TILE_CARD_Y3X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ;-----------------------------------------------------------------------
        ; bottom-left corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y4X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile

        ; move front-buffer address to the next column;
        ; this involves moving up by 3 tilemap rows
        ;
        ld      A,      L
        sub     (TILEMAP_WIDTH*3)-1     ; (less one tile, to move right a col)
        jr      nc,     +               ; did that underflow?
        dec     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret

        ;=======================================================================
        ; move to the next tilemap row:
        ;-----------------------------------------------------------------------
        ; we could use `add HL, BC` but we want to preserve BC
        ;
@next:  ld      A,      L
        add     TILEMAP_WIDTH           ; number of tiles to skip to next row
        jr      nc,     +               ; did that overflow?
        inc     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret


doAction:
;===============================================================================
; button pressed; pick up a pile / drop held cards
; or auto-play, according to context:
;
;-------------------------------------------------------------------------------
        ld      HL,     game_id         ; ID of game currently running
        ld      C,      [HL]            ; (we will need to reuse HL & A)

        ; retrieve the pile being pointed at (L)
        ; and the card-index (A) in that pile
        call    cursor.getPointPile

        ; which game is currently running?
        dec     C                       ; was it `1`?
        jp      z,      acesup.tapCard

        ;-----------------------------------------------------------------------
        ld      A,      [cursor.mode]   ; get cursor mode
        and     A,      A               ; (set flags!)

        ; retrieve current pile index (L) and the card index (A)
        ; being pointed at -- note this routine will not change the flags!
        call    cursor.getPointPile

        ; if the cursor is free (not holding any cards),
        ; attempt to pick up the pile being pointed at
        jp      z,      pickPile
        ; the cursor is holding cards, try dropping them
        jp      dropPile


pickPile:
;===============================================================================
; pick up a pile:
;
; this will pick up all the cards in the specified pile,
; from the specified index, down to the top of the pile
;
; in:   L       index (`INDEX_*`) of the source pile
;       A       index of the card in the pile to start from (0-based)
;-------------------------------------------------------------------------------
        ld      C,      A               ; put aside card index for later

        ; is the pile empty?
        rst     piles.rst_pileCount     ; (get pile card count, set flags)
        jp      z,      @err            ; if pile is empty, exit

        ; move cards to cursor's pile:
        ;-----------------------------------------------------------------------
        ; move all the cards in the source pile, from
        ; the index card down, to the cursor's pile:
        ld      E,      INDEX_CURSOR    ; destination pile
        ld      A,      C               ; card index to start from
        call    piles.move

        ; after the move, the destination pile's index is returned in L.
        ; get the destination pile's pool address in DE, which is where
        ; we want to start creating sprites from
        rst     piles.rst_poolAddr

        ; initialise sprites:
        ;-----------------------------------------------------------------------
        ld      A,      MODE_HOLD       ; change the cursor to the holding hand
        call    cursor.setMode

        ; set our starting X/Y position for building card sprites:
        ld      A,      [cursor.ypos]
        ld      B,      A               ; B will be the Y-position (px)
        ld      A,      [cursor.xpos]
        add     A,      8               ; add 8 to X to fit in the cursor hand
        ld      C,      A               ; C will be the X-position (px)

        ; because all sprites are in 8x16 mode, we will need to overlap
        ; sprites where cards stack in a pile and due to sprite-priority,
        ; we have to assign sprites from the top of memory, downards
        ; (literally writing the sprite attributes backwards)
        ld      HL,     sprites.attrs.40.attr

        ; convert cards to sprites:
        ld      A,      [DE]            ; seed loop with first card value
        ;-----------------------------------------------------------------------
        ; create sprites for the top half of each card:
        ; (only the last card has a bottom half)
@loop:  call    sprites.cardToSprites_Top

        ; read a card value from the pool; if this is the
        ; zero terminator, we've reached the end of the pile
        ;
        inc     DE                      ; move to next card
        ld      A,      [DE]
        and     A,      A               ; (set flags!)
        jr      nz,     @loop           ; keep looping until last card
        ;-----------------------------------------------------------------------

        ; bottom half of last card:
        dec     DE                      ; rewind before the zero-terminator
        ld      A,      [DE]            ; re-read last card value
        call    sprites.cardToSprites_Bottom

        ; set the update flag to upload the sprite
        ; changes to VRAM during the next v-blank
        ld      HL,     update_sprites
        set     0,      [HL]

        ; because the card being pointed to was removed, we need to move the
        ; cursor (and all the cards now in the cursor's hand) to the card above
        ;-----------------------------------------------------------------------
        call    cursor.getPointPile     ; get the old pile / card index
        and     A,      A               ; (set flags!)
        jr      z,      +               ; is the pile empty?
        dec     A                       ; if not, move to previous card
+       call    cursor.pointToCard      ; tell the cursor to move

        ; redraw the entire tableau; this may seem overkill but the removal
        ; of one card may affect the validation of other piles which would
        ; also need redrawing
        call    refresh

        ; compare the display buffers and queue
        ; the changes to be made during vblank
        jp      tilemap.update

        ; cannot pick this pile:
        ;=======================================================================
        ; TODO: we should implement a sound / cursor shake
@err:   ret


dropPile:
;===============================================================================
; drop the cards in the cursor's hand onto the specified pile:
;
; in:   L       index (`INDEX_*`) of the pile to drop the cards on
;-------------------------------------------------------------------------------
        push    HL                      ; preserve destination pile index
        call    cursor.clearSprites     ; remove cards in cursor's hand!
        pop     DE                      ; retrieve destination pile into E

        ; move the pile of cards in the cursor's hand
        ; on to the top of the destination pile
        ld      L,      INDEX_CURSOR    ; source pile index, the cursor
        xor     A                       ; A = 0, move all cards in hand
        call    piles.move

        ; with the pile changed, the cursor needs
        ; to be moved again to the top of the pile
        rst     piles.rst_pileCount
        jr      z,      +
        dec     A
+       call    cursor.pointToCard

        ; redraw the entire tableau; this may seem overkill but the removal
        ; of one card may affect the validation of other piles which would
        ; also need redrawing
        call    refresh
        ; compare the display buffers and queue
        ; the changes to be made during vblank
        jp      tilemap.update


moveCard:
;===============================================================================
; visually moves a card from one pile to another:
; the move takes multiple frames to complete
;
;-------------------------------------------------------------------------------
        ret