; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; card bytes:
;===============================================================================
; this section defines how we store cards in memory, one byte per card
;
; %bissnnnn     b     = "back" (back is visible)
;               i     = "inactive", 0=active, 1=inactive (unplayable card)
;               ss    = suit, 0-3,  0=spades, 1=clubs, 2=hearts, 3=diamonds
;               nnnn  = number, 1 (A), 2-9, 10 (J), 11 (Q), 12 (K),
;                       13-15 unused. 0 = no-card / null
;
.DEF    CARD_NONE       %00000000

.DEF    CARD_FRONT      %00000000       ; face-up card
.DEF    CARD_BACK       %10000000       ; face-down card

.DEF    CARD_ACTIVE     %00000000       ; card is playable
.DEF    CARD_INACTIVE   %01000000       ; card is disabled

; suits:                %--0----- = black
.DEF    SUIT_SPADE      %00000000
.DEF    SUIT_CLUB       %00010000
;                       %--1----- = red
.DEF    SUIT_HEART      %00100000
.DEF    SUIT_DIAMOND    %00110000

.DEF    CARD_A          %00000001
.DEF    CARD_2          %00000010
.DEF    CARD_3          %00000011
.DEF    CARD_4          %00000100
.DEF    CARD_5          %00000101
.DEF    CARD_6          %00000110
.DEF    CARD_7          %00000111
.DEF    CARD_8          %00001000
.DEF    CARD_9          %00001001
.DEF    CARD_X          %00001010
.DEF    CARD_J          %00001011
.DEF    CARD_Q          %00001100
.DEF    CARD_K          %00001101

; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 playfield.
; for our purposes we place the menu on the left and the playfield next to it,
; therefore the playfield begins at X = 12 and not the top-left (X = 0)
.DEF    TABLEAU_TOP     0
.DEF    TABLEAU_LEFT    MENU_WIDTH
.DEF    TABLEAU_ADDR    \
        tilemap.front_buffer + (TABLEAU_TOP * TILEMAP_WIDTH) + TABLEAU_LEFT
.DEF    TABLEAU_WIDTH   TILEMAP_WIDTH - MENU_WIDTH
.DEF    TABLEAU_HEIGHT  TILEMAP_HEIGHT

; cursor:
;===============================================================================
; (musn't cross an 8-bit boundary for a micro-optinmisation)
;
.RAMSECTION "Cursor"    BITWINDOW 8     RETURNORG
        ;-----------------------------------------------------------------------
        ; the address of the Pile struct that the cursor is pointing to;
        ; e.g. deck / depot; $0000 if cursor is free
        cursor_pile     WORD
        ; the number of the card in the pile the cursor is pointing at.
        ; note that this is 0-based and not 1-based like the pile size!
        cursor_card     BYTE
.ENDS

; tableau piles:
;===============================================================================
; an unasigned pile is not drawn
.DEF    PILE_NONE       %00000000
; regardless of the number of cards in a "deck" pile,
; it always displays as one face-down card
.DEF    PILE_DECK       %00000001
; like a "deck", the foundation does not spread,
; but differs by displaying the top card face-up
.DEF    PILE_FOUNDATION %00000010
; a downward spread of cards as you would typically see in Klondike
.DEF    PILE_COLUMN     %00000100

; for piles that spread to the right, instead of down the screen
; this flag can be added to the pile type
.DEF    PILE_HORZ       %10000000
.DEF    PILE_ROW        PILE_COLUMN | PILE_HORZ

.STRUCT Pile
        ;-----------------------------------------------------------------------
        ; we place the card count byte first so that we can easily identify
        ; empty piles first as all empty piles tend to look the same
        ; regardless of type
        ;
        count           BYTE    ; number of cards in the pile, 1-based!
        type            BYTE    ; type of pile, i.e. deck, hand, foundation &c.
        limit           BYTE    ; max.number of cards allowed in pile, 1-based!
        pool            WORD    ; address of storage for card pile
        row             BYTE    ; row position on the tilemap (not pixels!)
        col             BYTE    ; column position on the tilemap (not pixels!)
        left            BYTE    ; pile to the left of this one (lo-byte)
        right           BYTE    ; pile to the right of this one (lo-byte)
        up              BYTE    ; pile above this one (lo-byte)
        down            BYTE    ; pile below this one (lo-byte)
.ENDST

; define some RAM to hold cards during a game:
;
; the list of piles must not exceed 256 bytes
; as we increment only one register for speed!
.RAMSECTION "Layout"    ALIGN 256 SIZE 256 RETURNORG
        ;-----------------------------------------------------------------------
        ; a deck, where cards are drawn from
        deck            INSTANCEOF Pile
        ; a "discard" pile, where cards are thrown away
        discard         INSTANCEOF Pile
        ; a "hand" for cards to be played from, e.g. three-card-draw
        hand            INSTANCEOF Pile
        ; up to four foundation piles, where cards are stacked in order
        foundation1     INSTANCEOF Pile
        foundation2     INSTANCEOF Pile
        foundation3     INSTANCEOF Pile
        foundation4     INSTANCEOF Pile
        ; up to twelve depot piles, where cards are sorted and sorted
        depot1          INSTANCEOF Pile
        depot2          INSTANCEOF Pile
        depot3          INSTANCEOF Pile
        depot4          INSTANCEOF Pile
        depot5          INSTANCEOF Pile
        depot6          INSTANCEOF Pile
        depot7          INSTANCEOF Pile
        depot8          INSTANCEOF Pile
        depot9          INSTANCEOF Pile
        depot10         INSTANCEOF Pile
        depot11         INSTANCEOF Pile
        depot12         INSTANCEOF Pile
.ENDS

.RAMSECTION "Storage"   SIZE 1024       RETURNORG
        ;-----------------------------------------------------------------------
        storage         DSB 1024
.ENDS

.DEF    __pool_addr     tableau.storage

; use this macro before defining a set of piles in ROM
; in order to reset the starting pool address
;
.MACRO  BeginPiles
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.REDEF  __pool_addr     tableau.storage
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; this macro simplifies writing a pre-defined Pile of cards into ROM
;
.MACRO  DefinePile
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.DSTRUCT \1 INSTANCEOF Pile VALUES
        count:          .BYTE   0       ; (assigned at run-time)
        type:           .BYTE   \2
        limit:          .BYTE   \3
        pool:           .WORD   __pool_addr
        row:            .BYTE   \4
        col:            .BYTE   \5
        left:           .BYTE   <\6
        right:          .BYTE   <\7
        up:             .BYTE   <\8
        down:           .BYTE   <\9
.ENDST

.REDEF  __pool_addr     __pool_addr+\3

;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM


clearTiles:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ld      A,      $7e
        ; starting address of the tableau in the *front buffer*
        ld      HL,     TABLEAU_ADDR
        ; (number of tiles to skip to next row)
        ld      DE,     TILEMAP_WIDTH - SCREEN_WIDTH

        ;-----------------------------------------------------------------------
        ld      C,      TABLEAU_HEIGHT
@row:
.REPEAT TABLEAU_WIDTH
        ld      [HL+],  A       ; set cell to empty background tile
.ENDR
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


clearPiles:
;===============================================================================
; clear all piles, card storage:
;
; out:  DE      first address of the card storage pool
;       BC, A   set to zero, by nature of looping
;       HL      (clobbered)
;-------------------------------------------------------------------------------
        ld      HL,     SECTIONSTART_tableau.Layout
        ld      BC,     (SECTIONEND_tableau.Layout-SECTIONSTART_tableau.Layout)+1
        call    zero
        ld      HL,     SECTIONSTART_tableau.Storage
        ld      BC,     (SECTIONEND_tableau.Storage-SECTIONSTART_tableau.Storage)+1
        call    zero

        ; return the starting address of the card pool
        ; (used for allocating piles)
        ld      DE,     storage
        ret


allocateDeck:
;===============================================================================
; allocates the deck: (this is always 52 cards in size)
; the deck is populated with cards, but not shuffled
;
; in:   BC      address to a Pile structure (in ROM) to copy from
;-------------------------------------------------------------------------------
        ; HL    address of Pile structure (`deck`)
        ; BC    address of template Pile in ROM
        ld      HL,     deck
        call    allocatePile

        push    BC                      ; preserve new ROM address
        
        ; fill the deck with cards:
        ;-----------------------------------------------------------------------
        ; calling `addCard` 52 times would be needlessly slow,
        ; so we're going to manually write the pile size
        ld      A,      52
        ld      [deck.count],   A
        
        ; C will be our suit counter;
        ; 0=spades, 1=clubs, 2=hearts, 3=diamonds
        ld      C,      0

@next:  ld      B,      1               ; B = our ordinal counter, 1 to 13
-       ld      A,      C               ; begin with the suit 0-3
        swap    A                       ; suit bits go in the upper nybble
        or      B                       ; add the ordinal (1-13)
        or      CARD_BACK               ; flip the card over!
        ld      [DE],   A               ; store card and move to next slot
        inc     DE

        inc     B                       ; move to the next ordinal
        ld      A,      B               ; (need to use A for comparison)
        cp      CARD_K                  ; have we gone past the king?
        jr      nc,     -               ; no, continue adding cards

        inc     C                       ; move to the next suit
        bit     3,      C               ; have we hit 4?
        jr      z,      @next           ; no, do next suit

        ;-----------------------------------------------------------------------
        pop     BC                      ; restore new ROM address
        ret


allocatePile:
;===============================================================================
; allocates a pile where cards will be stored:
; e.g. a deck, hand, foundation or depot, etc.
;
; in:   HL      address of the working Pile structure in RAM;
;               this consists of a set of properties that will be filled out
;
;       BC      address of the template Pile structure (in ROM) to copy
;
; out:  HL      the structure address is moved forward over the Pile
;               structure. useful if you are allocating multiple piles
;               that directly follow each other in RAM
;
;       DE      address of the card pool for the pile, i.e. where the "cards",
;               each a byte, will be stored. this area will already have been
;               cleared according to the limit set in the template Pile
;
;       BC      the ROM address will have been moved over the Pile struct
;               allowing you to automatically use the next template in ROM
;
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        ; copy the Pile template (in ROM) over the working Pile in RAM:
        ;
        ; first byte is number of cards in the pile (defaults to 0)
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; next byte is the type of the Pile
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; then the maximum number of cards in the pile (1-based)
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; (put aside max pile size until we clear the Pile's card pool)
        push    AF
        
        ; next two bytes are the storage address;
        ; we put this aside in DE for later
        ld      A,      [BC]
        ld      E,      A               ; lo-byte first
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]
        ld      D,      A               ; hi-byte next
        ld      [HL+],  A
        inc     C

        ; next is the row/column position on the tilemap
        ld      A,      [BC]            ; read row (Y) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C
        ld      A,      [BC]            ; read column (X) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C

        ; positional data:
        ld      A,      [BC]            ; pile left
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile right
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile top
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile down
        ld      [HL+],  A
        inc     C

        ; clear the allocated card storage:
        ;-----------------------------------------------------------------------
        pop     AF                      ; retrieve max. card count
        push    BC                      ; preserve current ROM address
        push    DE                      ; keep original pool address

        ld      B,      A               ; copy card-limit to counter
        xor     A                       ; (write zeroes)

-       ld      [DE],   A               ; clear one byte
        inc     DE                      ; move to the next byte
        dec     B                       ; one less byte to fill
        jr      nz, -                   ; have we done all of them?

        pop     DE                      ; restore original pool address
        pop     BC                      ; restore current ROM address
        
        ret


refresh:
;===============================================================================
; redraw the tableau:
;-------------------------------------------------------------------------------
        ; we're going to redraw all piles,
        ; so clear the tabelau of tiles first
        call    clearTiles
        
        ld      HL,     deck
        call    drawPile
        ld      HL,     discard
        call    drawPile
        ld      HL,     hand
        call    drawPile
        ld      HL,     foundation1
        call    drawPile
        ld      HL,     foundation2
        call    drawPile
        ld      HL,     foundation3
        call    drawPile
        ld      HL,     foundation4
        call    drawPile
        ld      HL,     depot1
        call    drawPile
        ld      HL,     depot2
        call    drawPile
        ld      HL,     depot3
        call    drawPile
        ld      HL,     depot4
        call    drawPile
        ld      HL,     depot5
        call    drawPile
        ld      HL,     depot6
        call    drawPile
        ld      HL,     depot7
        call    drawPile
        ld      HL,     depot8
        call    drawPile
        ld      HL,     depot9
        call    drawPile
        ld      HL,     depot10
        call    drawPile
        ld      HL,     depot11
        call    drawPile
        ld      HL,     depot12
        jp      drawPile


addCard:
;===============================================================================
; add a card to a pile:
;
; in:   A       card to add (see CARD_* constants)
;       HL      address to the Pile structure, *not* the Pile's storage
;
; out:  HL      preserved, to allow adding multiple cards in row
;       carry   if the pile is full (card cannot be added), carry will be set
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve original HL for return
        ld      B,      A               ; put aside card to add for later

        ; read number of cards in the pile:
        ld      A,      [HL+]
        inc     L                       ; (skip pile type field)
        ; read the max. number of cards allowed in the pile:
        ld      C,      [HL]
        
        ; compare number of cards in pile, with max (1-based)
        cp      C
        jr      nc,      @full

        ; add card:
        ;-----------------------------------------------------------------------
        ; write the card to the card pool;
        ; begin by reading the storage address:
@add:   inc     L
        ld      E,      [HL]            ; lo-byte first
        inc     L
        ld      D,      [HL]            ; then hi-byte

        ; move to the empty-slot at the end of the pile's card pool
        ;
        add     A,      E               ; add number of cards to pile addr.
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A

        ld      A,      B               ; retrieve card to add
        ld      [DE],   A               ; write to pile
        
        ; increase the card count:
        ; since this is the first byte in the Pile struct, and we need to
        ; return the address of the Pile struct in HL, we can kill two birds
        ; with one stone!
        pop     HL                      ; retrieve Pile addr
        inc     [HL]                    ; increase number of cards in pile

        scf
        ccf
        ret

        ; pile is full!
        ;-----------------------------------------------------------------------
@full:  scf

        ld      B,      B               ; DEBUG

        pop     HL                      ; return original HL
        ret


getCard:
;===============================================================================
; gets the value of a specific card in a pile:
;
; in:   HL      address of a Pile structure
;       A       index (0-based) of the card to return
;
; out:  A       value of card
;       DE      address of the card pool for the pile
;       HL      (preserved)
;-------------------------------------------------------------------------------
        ; get the pile's pool address (DE)
        call    getPilePool
        push    DE
        ; add the card index:
        add     A,      E               ; add card index to addr lo-byte
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A
        
        ld      A,      [DE]            ; read the card value from the pool

        pop     DE
        ret


removeCard:
;===============================================================================
; removes a card from a pile:
; the value of the card removed is returned
;
; note that it is up to the caller to ensure
; that there are no holes left in the pile!
;
; removing a card will NOT change the screen;
; call `tilemap.refresh` to redraw any modified piles
;
; in:   HL      address of the Pile
;       A       index (0-based) of the card to remove
;
; out:  A       value of card
;       DE      address of the card pool for the pile
;       HL      (preserved)
;-------------------------------------------------------------------------------
        ; reduce the number of cards in the pile first
        ; as that's the first byte in the Pile structure
        dec     [HL]

        ; get the pile's pool address (DE)
        call    getPilePool
        push    DE
        ; add the card index:
        add     A,      E               ; add card index to addr lo-byte
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A
        ; read and erase the card:
        ld      A,      [DE]            ; read the card value from the pool
        push    AF                      ; keep card value
        xor     A                       ; set A to zero
        ld      [DE],   A               ; erase the card

        pop     AF                      ; return the card value
        pop     DE                      ; return the (starting) pool address
        ret


getPilePool:
;===============================================================================
; given a Pile struct address, returns the address
; in the card pool where the pile's cards are stored
;
; in:   HL      address of a Pile structure (e.g. `deck`, `depot`)
;
; out:  DE      address of the pile's card pool
;       HL, A   (preserved)
;-------------------------------------------------------------------------------
        inc     L                       ; skip the `count` field
        inc     L                       ; skip the `type` field
        inc     L                       ; skip the `limit` field
        ld      E,      [HL]            ; read the pool address, lo-byte
        inc     L
        ld      D,      [HL]            ; read the pool address, hi-byte

        dec     L                       ; restore HL:
        dec     L                       ;  this is still faster than
        dec     L                       ;  PUSH and POPing HL
        dec     L

        ret


getPilePos:
;===============================================================================
; retrieve the row & column co-ordinates (on the tile-map) of a pile:
; these are tile co-ordinates, NOT pixels!
;
; in:   HL      address of the Pile structure
;               (NOT the pile pool address)
;
; out:  B       row number of the pile on the tile-map
;       C       column number of the pile on-screen
;               (note that these two disregard scroll position!)
;
;       HL, DE  (preserved)
;       A       (preserved)
;-------------------------------------------------------------------------------
        ; this routine merely returns the X & Y tile co-ordinates stored
        ; in the Pile structure. the lack of index registers on the SM83
        ; is excruciating...
        ;
        push    HL

        ld      B,      0
        ld      C,      Pile.row
        add     HL,     BC
        
        ld      B,      [HL]
        inc     L
        ld      C,      [HL]
        
        pop     HL
        ret


drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; in:   HL      address of the Pile structure
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; TODO: should probably swap type/count bytes? (AGAIN)
        inc     L
        ld      A,      [HL-]
        ret     z
        
        ld      A,      [HL+]           ; read number of cards in pile
        and     A,      A               ; (set flags!)
        jr      z,      @empty          ; if zero, draw empty space

        ; check the type of pile (note, preserving A)
        bit     0,      [HL]            ; is it a deck?
        jr      nz,     @deck

        ; column:
        ;-----------------------------------------------------------------------
        ; get the pile's row & col (BC), and the card pool address (DE)
@col:   call    @pos
        ; get screen-buffer address for the X/Y co-ords. note that this returns
        ; the address in HL, but clobbers BC. we depend upon it preserving A
        ; (our card count) and DE (the card pool address)
        call    tilemap.getBufferAddr
        ; retain the card-count for iterating through the pile
        ld      C,      A
        ; begin the pile at the first card
        ld      B,      0

        ; when a pile has multiple cards, the cards below only have their
        ; top row drawn, but the last card has to be drawn whole; the carry
        ; flag indicates this to the `draw_card` routine
        ;
-       inc     B                       ; (pre-increment our counter)
        ld      A,      B               ; compare current & total cards --
        cp      C                       ; carry is set, except the last card!
        push    BC                      ; (preserve when drawing)

        ld      A,      [DE]            ; read a card value
        inc     DE                      ; move to next card in pile
                                        ; NOTE: does not change carry!
        push    DE                      ; (preserve when drawing)

        call    drawCard
        pop     DE
        pop     BC
        jr      c,      -

        ret

        ; deck:
        ;-----------------------------------------------------------------------
        ; get the pile's row & col
@deck:  call    @pos
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_5rows

        ; empty pile:
        ;-----------------------------------------------------------------------
        ; draw an empty pile on the buffer:
        ; first get the pile's row & col
@empty: call    @pos
        ; translate to an address on the buffer
        call    tilemap.getBufferAddr
        ; draw the empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_4rows

        ; get the position of the pile:
        ;-----------------------------------------------------------------------
@pos:   inc     L                       ; skip over card count byte
        inc     L                       ; skip over max-cards byte
        ld      E,      [HL]            ; read pool-address, lo-byte
        inc     L
        ld      D,      [HL]            ; read pool-address, hi-byte
        inc     L
        ld      B,      [HL]            ; read row
        inc     L
        ld      C,      [HL]            ; read column
        ret


drawCard:
;===============================================================================
; draws a card, handling all of its different properties:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
;       carry   if carry is set, only the first row will be drawn
;               (this is for drawing down-stacking piles)
;
; out:  carry   (preserved)
;       BC, DE  (clobbered)
;
; TODO: inactive
;-------------------------------------------------------------------------------
        bit     7,      A               ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;-----------------------------------------------------------------------
        ; face-down cards do not differ between active & inactive
        ld      DE,     tilemap.tilemap_back
        ; if carry is set, we want to draw only one row
        jp      c,      tilemap.writeTiles_1row
        ; otherwise draw the full card back
        jp              tilemap.writeTiles_4rows

        ; face-up:
        ;-----------------------------------------------------------------------
        ; remember the state of the carry flag;
        ; if set, we draw only the first row
@face:  push    AF
        ld      BC,     32-3            ; amount to skip to next row
        
        ; top-left corner: ordinal
        ld      D,      A               ; make a copy of the original value
        and     %00001111               ; trim out the other bits
        rlca
        add     TILE_CARD_1X1-2         ; offset the tile with the ordinal
        ld      [HL+],  A               ; write the tile and advance

        ; top-middle:
        ld      A,      TILE_CARD_1X2
        ld      [HL+],  A

        ; top-right corner: suit
        ld      A,      D
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca
        ld      E,      A               ; remember the suit for later too
        add     TILE_CARD_1X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; should we only draw the first row?
        pop     AF                      ; restore carry
        ret     c                       ; return now if carry-set

        ; middle:
        ld      A,      TILE_CARD_2X1
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X2
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row
        ld      A,      TILE_CARD_2X1
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X2
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; bottom-left: suit
        ld      A,      E               ; retrieve suit from earlier
        add     TILE_CARD_4X1
        ld      [HL+],  A

        ; bottom-middle:
        ld      A,      TILE_CARD_4X2
        ld      [HL+],  A

        ; bottom-right: ordinal
        ld      A,      D               ; retrieve ordinal from earlier
        and     %00001111               ; trim out the other bits
        rlca
        add     TILE_CARD_4X3-2         ; offset the tile with the ordinal
        ld      [HL+],  A               ; write the tile and advance

        ret


getCursorPile:
;===============================================================================
; returns the address of the Pile struct the cursor is pointing to:
;
; out:  HL      ; address of the Pile the cursor is pointing at
;       A       ; card number being pointed to, 0-based
;       DE      ; (clobbered)
;-------------------------------------------------------------------------------
        ; retrieve current pile location into DE
        ld      HL,     cursor_pile
        ld      E,      [HL]            ; pool address, lo-byte
        inc     L
        ld      D,      [HL]            ; pool address, hi-byte
        inc     L

        ; retrieve card number being pointed to
        ld      A,      [HL+]
        
        ld      H,      D
        ld      L,      E
        
        ret


pointToPile:
;===============================================================================
; move the cursor to a specific pile, pointing to the default card,
; e.g. on columns this is the face-up card furthest down the screen
;
; in:   HL      address of the Pile structure
;-------------------------------------------------------------------------------
        ; if there are zero cards in the pile, the default card is 0
        ld      A,      [HL]            ; first byte is number of cards in pile
        and     A,      A               ; (set flags!)
        jr      z,      pointToCard     ; =0? point to it

        ; for non-empty piles, the type of the Pile
        ; determines where the default card will be:
        inc     L
        ld      A,      [HL-]           ; read pile type
        ; (note how we've moved HL back to the beginning!)

        ; squared piles that don't show each card (e.g. deck, foundation)
        ; always point to the "first" card:
        and     PILE_DECK | PILE_FOUNDATION
        jr      nz,     @first

        ; column piles must point to the last card:
        ld      A,      [HL]            ; retrieve card count
        dec     A                       ; (adjust to 0-based)

        .byte   $fe

@first: xor    A

pointToCard:
;===============================================================================
; move the cursor to a specific card in a pile:
;
; in:   HL      address of the Pile structure
;       A       number of the card in the pile, 0-based!
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; update the record of which pile/card is currently being pointed to.
        ; if a pile has multiple cards, then pushing up/down will go through
        ; the cards before leaving the pile
        ;
        ; (put aside card number to point to)
        ld      C,      A
        ; save the address of the pile to point to:
        ld      DE,     cursor_pile
        ld      A,      L
        ld      [DE],   A
        inc     E
        ld      A,      H
        ld      [DE],   A
        inc     E
        ; save the card number to point to: (0-based)
        ; note that DE remains on this variable
        ld      A,      C
        ld      [DE],   A
        
        ; is the pile empty?
        ld      A,      [HL+]           ; read pile count
        and     A,      A               ; (set flags)
        jr      z,      @empty

        ; check the type of the pile, which will determine
        ; where the cursor will point more specifically
        ; (note that A is untouched here!)
        bit     0,      [HL]            ; deck?
        jr      nz,     @empty          ; TODO: the deck is slightly raised
        bit     1,      [HL]            ; foundation?
        jr      nz,     @empty

        ; for a column, the cursor will be positioned
        ; differently for the top card, vs the spread
        ;-----------------------------------------------------------------------
        ; compare the number of cards in the pile to the target card
        ; (empty has already been checked so A must be > 0)
@col:   dec     A                       ; (adjust for 0-based)
        cp      C                       ; compare against target card
        jr      z,      @top

        call    @pos
        call    @stack

        call    sprites.tilePosToScrXY
        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        jp      sprites.moveCursorToScrXY

        ; retrieve the row/column of the pile
        ;-----------------------------------------------------------------------
@pos:   dec     L                       ; (move HL back to Pile start)
        call    getPilePos              ; get Pile row (B) & col (C)

        ; we will always be pointing to the horizontal middle of the card;
        ; in the case of face-up cards, we want to point to the space
        ; between the suit / number so as not to obscure either
        inc     C
        ret

        ; offset the cursor according to the card number in the stack
        ;-----------------------------------------------------------------------
@stack: ; add the card number to the row number as
        ; each card in a pile adds another tile's height
        ld      A,      [DE]            ; retrieve card number to point to
        add     A,      B
        ld      B,      A
        ret

        ; top card:
        ;-----------------------------------------------------------------------
@top:   call    @pos
        call    @stack
        inc     B

        call    sprites.tilePosToScrXY
        dec     C
        dec     C
        jp      sprites.moveCursorToScrXY

        ; empty pile:
        ;-----------------------------------------------------------------------
        ; for empty piles, we want to point to the centre of the space
        ;
@empty: call    @pos                    ; get Pile row/col
        inc     B                       ; move down one row, to the middle
        jp      sprites.moveCursorToTile


moveCursorDown:
;===============================================================================
; move the cursor down, either going through a pile of cards,
; or downward to the nearest pile below the current one
;-------------------------------------------------------------------------------
        call    getCursorPile           ; retrieve current pile location
        ld      B,      A               ; card number pointed at (0-based)

        ; first byte is the number of cards in the pile
        ld      A,      [HL+]
        and     A,      A               ; (set flags!)
        ; if there are no cards in the pile we can move to the pile below
        ret     z                       ; TODO: move to next pile below

        ; next byte is the type of Pile
        ld      A,      [HL-]           ; (return HL to card-count)
        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile:
        and     PILE_DECK | PILE_FOUNDATION
        ret     nz                      ; TODO: move to next pile below

        ; have we reached the bottom of the column?
        ;-----------------------------------------------------------------------
        ; retrieve the card count again
@col:   ld      A,      [HL]
        ; compare A (number of cards) with B (current card)
        dec     A                       ; pile-size is 1-based,
        cp      B                       ; but current card is 0-based
        
        ; if they are not equal, the pointer has not reached
        ; the top of the pile (visually, bottom on screen)
        ret     z

        ; move down one card
@card:  ld      A,      B
        inc     A
        jp      pointToCard


moveCursorUp:
;===============================================================================
; move the cursor up, either going through a pile of cards,
; or upwards to the nearest pile above the current one
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL),
        ; and the card index being pointed at (A)
        call    getCursorPile
        and     A,      A               ; (set flags!)
        
        ; is the current position 0? i.e. at the
        ; bottom (top, visually) of the pile?
        ret     z

        dec     A
        jp      pointToCard


moveCursorLeft:
;===============================================================================
; move the cursor left
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL)
        call    getCursorPile

        ; move to the field that contains the pile to the left
        ld      B,      0
        ld      C,      Pile.left
        add     HL,     BC
        ; read the lo-byte of the address of the pile to the left
        ld      L,      [HL]
        ; set the hi-byte for the piles
        ld      H,      >SECTIONSTART_tableau.Layout
        
        ; move to the default card in the next pile
        jp      pointToPile


moveCursorRight:
;===============================================================================
; move the cursor right
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL)
        call    getCursorPile

        ; move to the field that contains the pile to the right
        ld      B,      0
        ld      C,      Pile.right
        add     HL,     BC
        ; read the lo-byte of the address of the pile to the right
        ld      L,      [HL]
        ; set the hi-byte for the piles
        ld      H,      >SECTIONSTART_tableau.Layout
        
        ; move to the default card in the next pile
        jp      pointToPile


pickCard:
;===============================================================================
; attempt to pick up a card:
;
; the card will be validated and, if it can be picked,
; it will be removed from the pile and placed in the cursor
;
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL),
        ; and the card index being pointed at (A)
        call    getCursorPile
        ; remove the card from the pile
        ; (this also returns the value)
        ; TODO: this will need to re-validate the cards; potentially across
        ; all Piles, as with Aces Up where validation of cards depends upon
        ; the cards atop the other piles
        call    removeCard

        ; create a sprite copy of the card(s)
        call    sprites.cardToSprite

        ; redraw the entire tableau; this may seem overkill but the removal
        ; of one card may affect the validation of other piles which would
        ; also need redrawing
        call    tableau.refresh
        ; compare the display buffers and queue up
        ; the changes to be made during vblank
        call    tilemap.update

        ret