; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 scrollable
; region. since the tableu may need to scroll a bit, we place the menu above
; the playfield, therefore the playfield does not begin at Y = 0!
;
.DEF    TABLEAU_TOP     MENU_HEIGHT
.DEF    TABLEAU_LEFT    0
.DEF    TABLEAU_ADDR    \
        tilemap.front_buffer + (TABLEAU_TOP * TILEMAP_WIDTH) + TABLEAU_LEFT
.DEF    TABLEAU_WIDTH   TILEMAP_WIDTH
.DEF    TABLEAU_HEIGHT  TILEMAP_HEIGHT-TABLEAU_TOP

.DEF    MODE_AUTO       0               ; cursor is under game control
.DEF    MODE_USER       1               ; cursor is under user control

.RAMSECTION "Cursor"    RETURNORG
        ;-----------------------------------------------------------------------
        mode            BYTE            ; to control different cursor behaviour
        ;-----------------------------------------------------------------------
        ; the pile index that the cursor is pointing to; e.g. deck / depot
        pile_point      BYTE
        ; the number of the card in the pile the cursor is pointing at.
        ; note that this is 0-based and not 1-based like the pile size!
        card_point      BYTE
        ;-----------------------------------------------------------------------
        ; when the cursor picks up a pile of cards, they are removed from
        ; the original pile and have to be stored elsewhere, so this pool
        ; exists specifically for the cards in the cursor's hand. the storage
        ; pool is not used so that the cursor's pool has a fixed address
        ; that makes it easier to work with
        ;
        ; TODO: is 13 cards enough? what's the largest pile
        ;       (note sprites limit us to 12 cards!)
        hand_cards      DSB 13+1         ; +1 for zero-terminator!
.ENDS

; the pile used to hold cards in the cursor's hand needs a template;
; force this template to use the fixed pool address!
.REDEF  __pool_addr             tableau.hand_cards

        ; label,                type, max-cards,
        ; row,                  col,
        ; pile-left,            pile-right,
        ; pile-up,              pile-down
piles.Define \
        pile_template,          TYPE_ROW, 13, \
        TILEMAP_HEIGHT-4,       TABLEAU_LEFT + 1, \
        0,                      0, \
        0,                      0


init:
;===============================================================================
; clear the tableau of cards and tiles:
; NOTE: does *not* refresh the screen
;-------------------------------------------------------------------------------
        ; remove all piles and cards in memory
        call    piles.clear
        ; the undo data will no longer be valid,
        ; so clear that too
        call    undo.clear

        ; next, clear the graphics
        ; ...

clearTiles:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
; NOTE: does *not* refresh the screen
;-------------------------------------------------------------------------------
        ; starting address of the tableau in the *front buffer*
        ld      HL,     TABLEAU_ADDR
        ld      A,      TILE_TABLEAU_BG ; tile index to write

        ; TODO: 22 rows is 704 tiles, so call fill (256) twice, plus 192
        ;       remainder. we should calculate this at assemble-time
        call    fill
        call    fill
        jp      fill@x192


allocateCursorPile:
;===============================================================================
; configure the pile for holding cards in the cursor hand:
;-------------------------------------------------------------------------------
        ld      BC,     pile_template   ; the ROM template to copy from
        ld      L,      INDEX_CURSOR    ; which pile to allocate
        jp      piles.allocate


clearCursorCards:
;===============================================================================
; removes the cards from the cursor hand / pile:
;
; WARNING: the cards should be "dropped" on to another pile
; before calling this otherwise they will be permenantly lost!
;
; out:  DE      (preserved) -- required for `pickPile`
;       BC      (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; set the size of the cursor's pile to zero
        xor     A                       ; (set A to zero)
        ld      HL,     piles.count+INDEX_CURSOR
        ld      [HL],   A

        ; zero out the list of cards in the private cursor pool
        ld      HL,     hand_cards
        call    fill@x{_sizeof_hand_cards}
        jp      cursor.clearCards


resetCursorMode:
;===============================================================================
        ld      A,      [mode]

        ; fallthrough
        ; ...

setCursorMode:
;===============================================================================
; set the cursor mode manually:
;
; in:   A       cursor mode constant, `MODE_*`
; out:  A       (preserved)
;-------------------------------------------------------------------------------
        and     A,      A               ; (set flags)
        jr      nz,     setCursorModeUser

        ; fall through for auto-mode
        ; ...

setCursorModeAuto:
;===============================================================================
; out:  AF      (preserved)
;-------------------------------------------------------------------------------
        push    AF

        ; hide the cursor, only the card(s) will be visible
        ;
        xor     A                       ; (set A to zero)
        ld      [mode], A               ; record mode change
        call    cursor.setSprite        ; change the cursor sprites

        pop     AF
        ret


setCursorModeUser:
;===============================================================================
; out:  AF      (preserved)
;-------------------------------------------------------------------------------
        push    AF

        ld      A,      MODE_USER
        ld      [mode], A               ; record the mode change

        ; reset the hand sprite to the default cursor
        call    cursor.setSprite

        pop     AF
        ret


update:
;===============================================================================
; queue changes to the tableau to be drawn during v-blank:
; (i.e. a partial-redraw)
;
;-------------------------------------------------------------------------------
        ; redraw the entire tableau; this may seem overkill but the removal
        ; of one card may affect the validation of other piles which would
        ; also need redrawing
        call    refresh
        ; compare the display buffers and queue
        ; the changes to be made during vblank
        jp      tilemap.update


refresh:
;===============================================================================
; redraw the tableau:
;-------------------------------------------------------------------------------
        ; we're going to redraw all piles,
        ; so clear the tabelau of tiles first
        call    clearTiles
        ; evaluate which cards are available for play and which are not,
        ; marking cards as enabled or disabled as appropriate. when the
        ; piles are drawn, disabled cards will be drawn 'greyed-out'
        call    piles.checkPiles

        ; redraw each pile:
        ld      L,      INDEX_DECK
        call    drawPile
        ld      L,      INDEX_DISCARD
        call    drawPile
        ld      L,      INDEX_HAND
        call    drawPile
        ld      L,      INDEX_FOUNDATION1
        call    drawPile
        ld      L,      INDEX_FOUNDATION2
        call    drawPile
        ld      L,      INDEX_FOUNDATION3
        call    drawPile
        ld      L,      INDEX_FOUNDATION4
        call    drawPile
        ld      L,      INDEX_DEPOT1
        call    drawPile
        ld      L,      INDEX_DEPOT2
        call    drawPile
        ld      L,      INDEX_DEPOT3
        call    drawPile
        ld      L,      INDEX_DEPOT4
        call    drawPile
        ld      L,      INDEX_DEPOT5
        call    drawPile
        ld      L,      INDEX_DEPOT6
        call    drawPile
        ld      L,      INDEX_DEPOT7
        call    drawPile
        ld      L,      INDEX_DEPOT8
        call    drawPile
        ld      L,      INDEX_DEPOT9
        call    drawPile
        ld      L,      INDEX_DEPOT10
        call    drawPile
        ld      L,      INDEX_DEPOT11
        call    drawPile
        ld      L,      INDEX_DEPOT12
        
        ; just fall through to routine below
        ; ...

drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; in:   L       index (`INDEX_*`) of the pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; we automatically skip unallocated piles (type is 0):
        ; this is because the tableau attempts to draw all piles
        ; and only those a particular game uses should be drawn
        ;
        ld      H,      FIELD_TYPE
        ld      A,      [HL]            ; read pile type
        and     A,      A               ; (set flags!)
        ret     z                       ; if pile is unallocated, quit

        call    piles.getPos            ; get pile row & col (B, C)

        ; is the pile empty?
        rst     piles.rst_pileCount     ; (get pile count, set flags)
        jr      z,      @empty          ; if zero, draw empty space

        ; check the specific type of pile:
        ; (note that A, card-count, is preserved through this)
        ;
        ld      H,      FIELD_TYPE      ; switch field back again
        bit     BIT_SQUARE,     [HL]    ; is it a stack?
        jr      nz,     @stack          ; -> handle stack-type piles
        bit     BIT_HORZ,       [HL]    ; is it a horizontal pile?
        jr      nz,     @row            ; -> handle horizontal spreads

        ; column:
        ;=======================================================================
@col:   rst     piles.rst_poolAddr      ; get card pool address (DE)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr

        ; retain the card-count for iterating through the pile;
        ; we will be counting toward zero, even though we will
        ; be drawing cards in order from index 0 upwards
        ld      C,      A
        ; subtract one because we want to draw the tops of all but the last
        ; card. once we've looped through the covered cards, we draw the
        ; top-most card separately
        dec     C
        ; of course, if there's only one card in the pile,
        ; just skip to drawing that in whole
        jr      z,      @@last
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)
        call    drawCardEdgeTop         ; draw only the first line of tiles
        pop     DE
        inc     DE                      ; move to next card in pile
        dec     C
        jr      nz,     -
        ;-----------------------------------------------------------------------
@@last  ld      A,      [DE]            ; read the top-most card
        jp      drawCard                ; draw it whole (and return)

        ;=======================================================================
        ; row:
        ;
@row:   rst     piles.rst_poolAddr      ; get card pool address (DE)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr
        
        ; retain the card-count for iterating through the pile;
        ; we will be counting toward zero, even though we will
        ; be drawing cards in order from index 0 upwards
        ld      C,      A
        ; subtract one because we want to draw the sides of all but the last
        ; card. once we've looped through the covered cards, we draw the
        ; top-most card separately
        dec     C
        ; of course, if there's only one card in the pile,
        ; just skip to drawing that in whole
        jr      z,      @@last
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)
        call    drawCardEdgeLeft        ; draw only the first column of tiles
        pop     DE
        inc     DE                      ; move to next card in pile
        dec     C
        jr      nz,     -
        ;-----------------------------------------------------------------------
@@last  ld      A,      [DE]            ; read the top-most card
        jp      drawCard                ; draw it whole (and return)

        ;=======================================================================
        ; empty pile:
        ;
@empty: call    tilemap.getBufferAddr   ; translate row/col to buffer address

        ; draw the pre-baked empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_4rows

        ;=======================================================================
        ; stacks:
        ;
        ; is it a face-down stack (e.g. deck),
        ; or face-up stack (e.g. foundation)?
@stack: bit     BIT_FACE,       [HL]
        jr      nz,     @face

        ; read the top-most card in the pile
        call    piles.getLastCard
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_5rows

        ;=======================================================================
        ; stack with face-up card:
        ;
@face:  call    piles.getLastCard
        call    tilemap.getBufferAddr   ; translate to a buffer address

        ; fall through to below to draw
        ; the singular face-up card!
        ; ...

drawCard:
;===============================================================================
; draws a card, handling all of its different properties:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  BC      (preserved)
;       DE, HL  (clobbered)
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; draw the card in full
        jp      tilemap.writeTiles_4rows

        ;=======================================================================
        ; face-up:
        ;
@face:  push    AF

        call    drawCardEdgeTop

        pop     AF
        ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM >:[
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside

        ;-----------------------------------------------------------------------
        ; middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y2X1
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y2X2
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y2X3
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        call    drawCardEdgeTop@next    ; move to the next row
        ld      A,      TILE_CARD_Y3X1
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y3X2
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y3X3
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-left: suit
        ;-----------------------------------------------------------------------
        call    drawCardEdgeTop@next    ; move to the next row
        ld      A,      D               ; retrieve card value once again
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y4X1
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y4X2
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-right: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; retrieve ordinal from earlier
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y4X3-1        ; offset the tile with the ordinal
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ret


drawCardEdgeTop:
;===============================================================================
; for cards in a column where one card covers another,
; and we need to draw only the top edge of a card:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  HL      the buffer address is advanced to the next tilemap row
;       BC      (preserved)
;       AF, DE  (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; draw only the first line of the tiles
        jp      tilemap.writeTiles_1row

        ;=======================================================================
        ; face-up:
        ;
@face:  ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM >:[
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y1X1-1        ; offset the tile with the ordinal
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y1X2
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-right corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y1X3
        xor     E                       ; add the disabled bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ; fall through to automatically
        ; move to the next tilemap row
        ; ...

        ;=======================================================================
        ; move to the next tilemap row:
        ;-----------------------------------------------------------------------
        ; we could use `add HL, BC` but we want to preserve BC
        ;
@next:  ld      A,      TILEMAP_WIDTH-3 ; number of tiles to skip to next row
        add     A,      L               ; add this to the address lo-byte
        jr      nc,     +               ; did that overflow?
        inc     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret


drawCardEdgeLeft:
;===============================================================================
; for cards in a row where one card covers another,
; and we need to draw only the left edge of a card:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  HL      the buffer address is advanced to the next tilemap column
;       BC      (preserved)
;       AF, DE  (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back_left
        ; draw only the first line of the tiles
        jp      tilemap.writeTiles_1col

        ;=======================================================================
        ; face-up:
        ;
@face:  ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM >:[
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y1X1-1        ; offset the tile with the ordinal
        xor     E                       ; add the disabled bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ;-----------------------------------------------------------------------
        ; middle-left:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y2X1
        xor     E                       ; add the disabled bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ld      A,      TILE_CARD_Y3X1
        xor     E                       ; add the disabled bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ;-----------------------------------------------------------------------
        ; bottom-left corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y4X1
        xor     E                       ; add the disabled bit, if present
        ld      [HL],   A               ; write the tile

        ; move front-buffer address to the next column;
        ; this involves moving up by 3 tilemap rows
        ;
        ld      A,      L
        sub     (TILEMAP_WIDTH*3)-1     ; (less one tile, to move right a col)
        jr      nc,     +               ; did that underflow?
        dec     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret

        ;=======================================================================
        ; move to the next tilemap row:
        ;-----------------------------------------------------------------------
        ; we could use `add HL, BC` but we want to preserve BC
        ;
@next:  ld      A,      L
        add     TILEMAP_WIDTH           ; number of tiles to skip to next row
        jr      nc,     +               ; did that overflow?
        inc     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret


getCardPos:
;===============================================================================
; retrieve the row & column tile co-ordinates of a specific card in a pile:
; this position varies depending on the type of pile and its properties,
; such as horizontal / vertical spread, that this routine accounts for
;
; in:   L       index (`INDEX_*`) of the pile
;       A       card index (0-based)
;
; out:  B       row number of the card on the tile-map
;       C       column number of the card on the tile-map
;       A       (preserved) -- in case you want to read the card value
;       L, DE   (preserved)
;       H       (clobbered) -- select a field before using HL!
;-------------------------------------------------------------------------------
        call    piles.getPos            ; start with the row/col of the pile
        and     A,      A               ; if the card index is zero, the
        ret     z                       ;  pile position is already correct

        ; check the type of pile, which will determine which
        ; direction the cards in the pile spread, if at all
        ;
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]    ; if the pile is square (no spread)
        ret     nz                      ;  then no row/col adjustment needed
        bit     BIT_HORZ,       [HL]    ; horizontal spread?
        jr      nz,     @horz

        ; vertical spread:
        ;-----------------------------------------------------------------------
@vert:  ld      H,      A               ; (preserve card index)
        add     A,      B
        ld      B,      A
        ld      A,      H               ; (restore card index)
        ret

        ;-----------------------------------------------------------------------
        ; horizontal spread:
@horz:  ld      H,      A               ; (preserve card index)
        add     A,      C
        ld      C,      A
        ld      A,      H               ; (restore card index)
        ret


.SECTION "RSTPointPile" SIZE 8  RETURNORG
;###############################################################################
rst_getPointPile:                                                       ;$30
;===============================================================================
; returns the index of the Pile struct the cursor is pointing to:
;
; out:  L       index of the pile the cursor is pointing at
;       A       card index being pointed to, 0-based
;       BC, DE  (preserved)
;       H       (clobbered) -- select a field before using HL!
;-------------------------------------------------------------------------------
        ; retrieve index of pile being pointed at
        ld      HL,     pile_point
        ld      L,      [HL]
        ; retrieve card number being pointed to
        ld      A,      [card_point]
        ret
;###############################################################################
.ENDS


cursorLeft:
;===============================================================================
; move the cursor left:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; retrieve current pile index (L),
        ; and the card index being pointed at (A)
        rst     rst_getPointPile

        ld      H,      FIELD_TYPE      ; check pile type to see
        bit     BIT_HORZ,       [HL]    ;  is this is a horizontal pile?
        jr      z,      @pile           ;  no? move straight to next pile

        ; horizontal spread:
        ;-----------------------------------------------------------------------
        ; is the current position 0? i.e. at the
        ; bottom (left, visually) of the pile?
        and     A,      A               ; (set flags!)
        jr      z,      @pile           ; if yes, move to next pile to the left

        ; do not point at a disabled card!
        dec     A                       ; move left a card
        rst     piles.rst_cardAddr      ; get the addr of that card
        ld      A,      [DE]            ; read its value
        bit     BIT_DISABLED,   A       ; if the card is enabled,
        jp      z,      pointToCard     ;  point to same pile, previous card

        ; card is disabled, move to
        ; the next pile instead
        ; ...

        ; move to the pile to the left:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_LEFT      ; read the `left` field that
        ld      L,      [HL]            ;  tells us the pile to point to
        jp      pointToPile


cursorRight:
;===============================================================================
; move the cursor right:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        rst     rst_getPointPile        ; get pile (L) and card (A) index
        ld      C,      A               ; put aside card index
        rst     piles.rst_pileCount     ; get the card-count of the pile
        jr      z,      @pile           ; move cursor if this pile is emepty

        ld      H,      FIELD_TYPE      ; check pile type to see
        bit     BIT_HORZ,       [HL]    ;  is this is a horizontal pile?
        jr      z,      @pile           ;  no? move straight to next pile

        ; horizontal spread:
        ;-----------------------------------------------------------------------
        ; have we reached the end of the row?
        ;
        ; a neat trick is used here to both do the comparison and effectively
        ; add 1 to the card index to be able to move to the next card, *if*
        ; we're not at the end of the pile (and the card isn't disabled)
        ;
        inc     C                       ; adjust pointed-to card index
        cp      A                       ;  to 1-based and compare with count

        ; if equal, the end of the pile has been hit,
        ; move the cursor to the next pile
        jr      z,      @pile

        ; do not point at a disabled card!
        ld      A,      C               ; retrieve new card index
        rst     piles.rst_cardAddr      ; get the addr of that card
        ld      A,      [DE]            ; read its value
        bit     BIT_DISABLED,   A       ; if the card is enabled,
        ld      A,      C               ;  retrieve the new card index, and
        jp      z,      pointToCard     ;  point to same pile; next card

        ; card is disabled, move to
        ; the next pile instead
        ; ...

        ; move to the pile to the right:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_RIGHT     ; read the `right` field that
        ld      L,      [HL]            ;  tells us the pile to point to
        jp      pointToPile


cursorUp:
;===============================================================================
; move the cursor up, either going through a pile of cards,
; or upwards to the nearest pile above the current one:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; retrieve current pile index (L),
        ; and the card index being pointed at (A)
        rst     rst_getPointPile

        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     @pile
        ; if currently in a horizontal pile, pressing up should just move
        ; to the next pile and not try flipping through the cards!
        bit     BIT_HORZ,       [HL]
        jr      nz,     @pile

        ; move up within the current pile:
        ;-----------------------------------------------------------------------
        and     A,      A               ; is the current position 0?
        jr      z,      @pile           ; if yes, move to next pile above

        ; do not point at a disabled card!
        dec     A                       ; move up a card
        ld      C,      A               ; before we read card, backup index
        rst     piles.rst_cardAddr      ; get the addr of that card
        ld      A,      [DE]            ; read its value
        bit     BIT_DISABLED,   A       ; if the card is enabled,
        ld      A,      C               ;  restore the new index, and
        jp      z,      pointToCard     ;  point to same pile; previous card

        ; card is disabled, move to
        ; the next pile instead
        ; ...

        ; move up to the next pile:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_UP        ; read the `up` field that
        ld      L,      [HL]            ;  tells us the pile to point to
        jr      pointToPile


cursorDown:
;===============================================================================
; move the cursor down, either going through a pile of cards,
; or downward to the nearest pile below the current one:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        rst     rst_getPointPile        ; retrieve current pile index
        ld      C,      A               ; card index pointed at (0-based)

        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     @pile
        ; if currently in a horizontal pile, pressing down should just move
        ; to the next pile and not try flipping through the current pile!
        bit     BIT_HORZ,       [HL]
        jr      nz,     @pile

        ; move down within the current pile:
        ;-----------------------------------------------------------------------
        ; get the number of cards in the pile
        rst     piles.rst_pileCount
        ; if there are no cards in the pile
        ; we can move to the pile below
        jr      z,      @pile

        ; have we reached the bottom of the column?
        ;
        ; a neat trick is used here to both do the comparison and effectively
        ; add 1 to the card index to be able to move to the next card, *if*
        ; we're not at the end of the pile
        ;
        inc     C                       ; adjust pointed-to card index
        cp      A,      C               ;  to 1-based and compare with count
        ld      A,      C

        ; (NOTE: we do not *yet* support a situation where the cursor
        ;  may be on an enabled card that is topped by a disabled card)

        ; if they are not equal, the pointer has not reached the top of
        ; the pile (visually, bottom on screen). move the cursor to the
        ; next card by using the 1-based index as 0-based!
        jr      nz,     pointToCard

        ; move down to the next pile:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_DOWN      ; read the `down` field that
        ld      L,      [HL]            ;  tells us the pile to point to

        ; fall through to below
        ; to point to the new pile!
        ; ...

pointToPile:
;===============================================================================
; move the cursor to a specific pile, pointing to the default card,
; e.g. on columns this is the face-up card furthest down the screen
;
; in:   L       index (`INDEX_*`) of the pile to point to
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; if there are zero cards in the pile, the default card is 0
        rst     piles.rst_pileCount     ; get pile count, set flags
        jr      z,      pointToCard     ; =0? point to it

        ; for any pile with multiple cards,
        ; we point to the last card by default
        dec     A                       ; (adjust to 0-based)

        ; fall through below
        ; ...

pointToCard:
;===============================================================================
; move the cursor to a specific card in a pile:
;
; in:   L       index (`INDEX_*`) of the pile
;       A       index of the card in the pile, 0-based!
;
; out:  L       (preserved)
;       H       (clobbered) -- select a field before using HL!
;       A       (clobbered)
;       BC, DE  (clobbered)
;-------------------------------------------------------------------------------
        ld      [card_point],   A       ; save card index to point to (0-based)

        ; calculate the exact X/Y position in pixels to move the cursor to,
        ; accounting for the specific card in the pile and the cursor mode
        call    cursorPosForCard

        ; save the index of the pile to point to:
        ld      A,              L
        ld      [pile_point],   A

        ; move the cursor to these exact X/Y co-ords
        jp      cursor.moveToScrXY


setPointPile:
;===============================================================================
; sets which pile the cursor is pointing to:
; (but doesn't move the cursor)
;
; in:   L       index (`INDEX_*`) of the pile
; out:  A       index of the last card in the pile
;       L       (preserved)
;       H       (clobbered) -- select a field before using HL!
;-------------------------------------------------------------------------------
        rst     piles.rst_lastCardIndex ; index of the last card in the pile

        ; fall through to below, using
        ; the last card index
        ; ...

setPointCard:
;===============================================================================
; in:   L       index (`INDEX_*`) of the pile
;       A       index of the card in the pile
;
; out:  A, L    (preserved)
;       H       (clobbered) -- select a field before using HL!
;-------------------------------------------------------------------------------
        ld      [card_point],   A
        ld      H,              A       ; preserve card-index,
        ld      A,              L       ;  whilst we do the pile index
        ld      [pile_point],   A
        ld      A,              H       ; restore card-index
        ret


cursorPosForCard:
;===============================================================================
; returns the exact cursor position (in px)
; to point to a specific card in a pile:
;
; this routine does not actually move the cursor!
; use `cursor.moveToScrXY` with this routine's output
;
; in:   L       index (`INDEX_*`) of the pile
;       A       card index (0-based)
; out:  B       screen Y-position, in px, the cursor would point to
;       C       screen X-position, in px, the cursor would point to
;       L, A    (preserved)
;       DE      (preserved)
;       H       (clobbered) -- select another field before using HL!
;-------------------------------------------------------------------------------
        push    DE                      ; (preserve DE)
        ld      E,      A               ; save card-index for later comparison
        call    getCardPos              ; get the card's position in tiles

        ld      A,      [mode]          ; check the cursor mode;
        and     A,      A               ; (set flags)
        jr      nz,     @user           ; diverge for user-mode

        ;=======================================================================
        ; cursor auto-mode:
        ;
        ; convert the X/Y tile positions into X/Y screen pixels
@auto:  call    sprites.tilePosToScrXY
        ; the sprite version of a card has a border we need to account for
        inc     B                       ; adjust 1px for top-border
        inc     C                       ; adjust 1px for left-border

        ; the deck is slightly taller than a normal squared pile:
        ; check if the pile index is that of the deck
        ;
        ld      A,      INDEX_DECK      ; pile index of the deck
        cp      L                       ; compare with current pile index
        jr      nz,     +               ; no match -> make sure A is restored

        ; adjust the sprite card location to appear
        ; over the top card of the deck
        dec     B
        dec     B
        dec     B
        dec     B
        ;-----------------------------------------------------------------------
+       ld      A,      E               ; return card-index
        pop     DE                      ; (restore DE)
        ret

        ;=======================================================================
        ; cursor user-mode:
        ;
        ; is the pile empty?
@user:  rst     piles.rst_pileCount     ; get pile count (A), set flags
        jr      z,      @empty          ; -> an empty pile space
        ld      D,      A               ; also remember count for later

        ; for types of piles that have no spread (e.g. decks / foundations),
        ; we point to the top of the pile without counting cards
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     @square

        ; is this a horizontal or vertical spread of cards?
        bit     BIT_HORZ,       [HL]    ; check orientation bit
        jr      nz,     @horz           ; -> handle horizontal pile

        ; vertical spread:
        ;=======================================================================
        ; point to the horizontal middle of the card; we want to point to
        ; the space between the suit / number so as not to obscure either
@vert:  inc     C

        ; for a spread, the cursor will be positioned
        ; differently for the top card, vs the spread
        ;
        ; compare the number of cards in the pile (A) to the target
        ; card (C). empty has already been checked so A must be > 0
        ;
        ld      A,      D               ; number of cards in the pile
        dec     A                       ; (adjust for 0-based)
        cp      E                       ; compare count against target card
        jr      nz,     +

        ; top-card:
        ;-----------------------------------------------------------------------
        ; for the card on top of the pile,
        ; point to the centre
        inc     B
        ; translate the tile row (B)  & col (C)
        ; into the X & Y position in pixels
        call    sprites.tilePosToScrXY
        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        inc     B
        ;-----------------------------------------------------------------------
        ld      A,      E               ; return card-index
        pop     DE                      ; (restore DE)
        ret

        ;-----------------------------------------------------------------------
        ; within the spread:
        ;
        ; translate the tile row (B)  & col (C)
        ; into the X & Y position in pixels
+       call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        ;-----------------------------------------------------------------------
        ld      A,      E               ; return card-index
        pop     DE                      ; (restore DE)
        ret

        ;=======================================================================
        ; horizontal spread:
        ;
@horz:  inc     B                       ; 2nd row, below the suit/ordinal

        ; for a horizontal spread, the cursor will be positioned
        ; differently for the top card, vs the other cards
        ;
        ; compare the number of cards in the pile to the target
        ; card. empty has already been checked so A must be > 0
        ;
        ld      A,      D               ; number of cards in the pile
        dec     A                       ; (adjust for 0-based)
        cp      E                       ; compare count against target card
        jr      nz,     +

        ; for the card on top of the pile,
        ; point to the centre
        inc     C

        ; translate the tile row (B)  & col (C)
        ; into the X & Y position in pixels
+       call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        inc     B                       ; 1px down
        dec     C                       ; 1px left
        ;-----------------------------------------------------------------------
        ld      A,      E               ; return card-index
        pop     DE                      ; (restore DE)
        ret

        ;=======================================================================
        ; square pile / deck:
        ;
        ; the deck is slightly taller than a normal squared pile:
        ; check if the pile index is that of the deck
        ;
@square:ld      A,      INDEX_DECK      ; pile index of the deck
        cp      L                       ; compare with current pile index
        jr      nz,     @empty          ; no match -> treat like empty pile

        inc     C                       ; adjust right one col, to the middle
        inc     B                       ; adjust down one row, to the middle

        ; convert the tile row/col to screen-space pixels
        call    sprites.tilePosToScrXY

        ; offset the cursor for the deck's extra thickness
        dec     B
        dec     B
        dec     B
        dec     C
        dec     C
        ;-----------------------------------------------------------------------
        ld      A,      E               ; return card-index
        pop     DE                      ; (restore DE)
        ret

        ;=======================================================================
        ; empty pile:
        ;
        ; for empty piles, we want to point to the centre of the space
@empty: inc     C                       ; adjust right one col, to the middle
        inc     B                       ; adjust down one row, to the middle
        
        ; convert the tile row/col to screen-space pixels
        call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        dec     C
        ;-----------------------------------------------------------------------
        ld      A,      E               ; return card-index
        pop     DE                      ; (restore DE)
        ret


tapCard:
;===============================================================================
; button pressed; pick up a pile / drop held cards:
;-------------------------------------------------------------------------------
        ; is the cursor already holding any cards?
        ;
        ld      L,      INDEX_CURSOR    ; get card-count of the cursor's pile
        rst     piles.rst_pileCount

        ; retrieve current pile index (L) and the card index (A)
        ; being pointed at -- note this routine will not change the flags!
        rst     rst_getPointPile

        call    nz,     dropPile        ; if cursor is holding cards, drop them
        call    z,      pickPile        ; otherwise, pick up cards

        ; with the pile changed, the cursor needs
        ; to be moved again to the top of the pile
        rst     rst_getPointPile
        jp      pointToPile


pickPile:
;===============================================================================
; pick up a pile:
;
; this will pick up all the cards in the specified pile, from the specified
; index, down to the top of the pile. the cards will be removed from the pile,
; converted into sprites, and placed in the cursor's hand
;
; WARNING:      this routine will *not* move the cursor after the cards have
;               been removed from the pile, meaning the cursor will be pointing
;               at an invalid index!
;
; in:   L       index (`INDEX_*`) of the source pile
;       A       index of the card in the pile to start from (0-based)
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; preserve source pile and card-index as these will be lost
        ; after moving the piles in RAM (destination is returned)
        ;
        ld      H,              A       ; preserve card-index in source pile
        ld      A,              L       ; to undo this move, the source pile
        ld      [undo.tmp_dst], A       ;  becomes the destination
        push    HL

        ; move the cards in the source pile, from the
        ; index card downward, to the cursor's pile
        ;
        ld      A,      H               ; (restore card-index)
        ld      E,      INDEX_CURSOR    ; destination pile = cursor's hand
        call    piles.move              ; NOTE: returns L = destination pile

        ; build card sprites:
        ;=======================================================================
        ; get the card pool address for the cursor's pile; i.e. the starting
        ; point in the cursor's pile to begin building card sprites from
        ; (note that L = destination pile after move, the cursor's pile)
        ;
        rst     piles.rst_poolAddr

        ; restore source pile (L) and card-index (H)
        pop     HL

        ; ensure that the cursor is positioned correctly for where the card
        ; sprites will be built; this will differ if the cursor sprite
        ; is visible or not:
        ;
        ; `cursorPosForCard` will account for user/auto mode and return
        ; the X/Y co-ords where the cursor should be
        ;
        ld      A,      H               ; restore card-index
        call    cursorPosForCard        ; (NOTE: A, L & DE preserved)

        ; place the current cursor in this position so that the destination
        ; check will be based upon the card-position, not the old position
        ; of the hand sprite
        ;
        call    cursor.setPos

        ; next, for user-mode the cards will be offset to the side
        ; so that they look like they are held by the cursor's hand
        ;
        ld      A,      [mode]          ; check current cursor mode
        and     A,      A               ; (set flags)
        jr      z,      @build          ; for auto-mode, skip over

        ; user-mode:
        ;-----------------------------------------------------------------------
        ; change to the cursor hand sprite for holding cards
@user:  ld      A,      CURSOR_HOLD
        call    cursor.setSprite

        ; set our starting X/Y position
        ; for building card sprites:
        ld      A,      [cursor.ypos]
        ld      B,      A               ; B will be the Y-position (px)
        ld      A,      [cursor.xpos]
        add     A,      8               ; add 8 to X to fit in the cursor hand
        ld      C,      A               ; C will be the X-position (px)

        ; because all sprites are in 8x16 mode, we will need to overlap
        ; sprites where cards stack in a pile and due to sprite-priority,
        ; we have to assign sprites from the top of memory, downards
        ; (literally writing the sprite attributes backwards)
        ;
@build: ld      HL,     sprites.attrs.40 + (_sizeof_Sprite-1)
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value from the pool

        ; ensure the card is face-up! this is so that dealing from the deck
        ; will always flip the cards face-up. the updated card has to be
        ; written back to the pile so that the change reflects both in
        ; the sprite building and when the screen is refreshed
        and     ~CARD_BACK
        ld      [DE],   A

        ; create sprites for the top half of each card
        ; (only the last card has a bottom half)
        call    sprites.createCard_Top

        ; check for the zero terminator:
        inc     DE                      ; move to next card
        ld      A,      [DE]            ; read card value (or zero)
        and     A,      A               ; (set flags!)
        jr      nz,     -               ; keep looping until last card
        ;-----------------------------------------------------------------------

        ; bottom half of last card:
        dec     DE                      ; rewind before the zero-terminator
        ld      A,      [DE]            ; re-read the last card value
        call    sprites.createCard_Bottom

        ; move complete, refresh screen
        ;-----------------------------------------------------------------------
        call    sprites.update          ; update the sprites
        jp      update                  ; update the screen

        ; cannot pick this pile:
        ;=======================================================================
        ; TODO: we should implement a sound / cursor shake
@era:   ret


dropPile:
;===============================================================================
; drop the cards in the cursor's hand onto the specified pile:
;
; in:   L       index (`INDEX_*`) of the pile to drop the cards on
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; undo data:
        ;-----------------------------------------------------------------------
        ld      A,              L       ; to undo this move, the destination
        ld      [undo.tmp_src], A       ;  pile becomes the source
        ; since the cards will be dropped on to the destination pile,
        ; the *current* top-card (+1) of the pile will be where we need
        ; to take the cards from to reverse this action
        rst     piles.rst_pileCount
        ld      [undo.tmp_idx], A
        ; `pickPile` will have set the undo destination pile, and `dropPile`
        ; sets the rest, so we can now push to the undo buffer
        call    undo.push

        ; drop cards:
        ;-----------------------------------------------------------------------
        push    HL                      ; preserve destination pile index
        call    cursor.clearCards       ; remove cards in cursor's hand!

        ld      A,      [mode]          ; for user-mode, restore the hand
        call    setCursorMode           ;  sprite to the no-cards default

+       pop     DE                      ; retrieve destination pile into E

        ; move the pile of cards in the cursor's hand
        ; on to the top of the destination pile
        ld      L,      INDEX_CURSOR    ; source pile index, the cursor
        xor     A                       ; A = 0, move all cards in hand
        call    piles.move

        call    sprites.update
        jp      update                  ; update the screen


discardCard:
;===============================================================================
; move a card from a pile to the discard pile:
;
; in:   L       source pile index (`INDEX_*`)
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ld      E,      INDEX_DISCARD

        ; skip the next two bytes as a `ld BC, $xxxx`!
        .BYTE   $01

dealCard:
;===============================================================================
; draw a card from the deck (flipping it face-up)
; and move it to the top of a pile:
;
; in:   E       destination pile index
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ld      L,      INDEX_DECK

        ; with the source pile implied,
        ; fall-through to move one card
        ; ...

moveTopCard:
;===============================================================================
; visually moves the top card of a pile from one pile to another;
; the move takes multiple frames to complete:
;
; in:   L       source pile index (`INDEX_*`)
;       E       destination pile index
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        rst     piles.rst_lastCardIndex

        ; with the index of the last card,
        ; fall through to move the card
        ; ...

movePile:
;===============================================================================
; visually moves a pile of cards from one pile to another;
; the move takes multiple frames to complete:
;
; (use `piles.move` to move cards around in memory)
;
; WARNING: will not check for an empty pile!
; verify source pile is not empty before calling!
;
; in:   L       source pile index (`INDEX_*`)
;       A       card-index to take cards from, to the end of the pile
;       E       destination pile index
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; after picking up the cards we won't have access to the source pile
        ; so push a backup on to the stack for after the move
        push    HL
        ; put aside destination until we've handled the source pile first
@undo:  push    DE

        ; pick up source cards:
        ;-----------------------------------------------------------------------
        ; put cursor into auto-mode so that
        ;
        ; 1. the cursor's hand is hidden
        ; 2. card sprites will be built directly over the card(s) being moved
        ; 3. the move-destination (in px) will align to the pile
        ;
        call    setCursorModeAuto       ; (note: preserves A)
        call    pickPile                ; pick up the card(s) in the pile
                                        ; (NOTE: all registers clobbered!)

        ; move to destination:
        ;-----------------------------------------------------------------------
        ; we need to move the pile of cards to the top of the destination
        ; pile, but not *covering* the last card, it has to be in the next
        ; card position down
        pop     HL                      ; retrieve our destination pile into L
        rst     piles.rst_pileCount     ; get next index: 0, or last-card+1
        call    cursorPosForCard        ; get the exact position in px
        call    cursor.moveToScrXY      ; set the cursor destination
        call    cursor.wait             ; wait for cursor to finish moving

        ; drop cards on pile:
        ;-----------------------------------------------------------------------
        call    dropPile                ; put the cards down on the dest. pile
                                        ; (NOTE: all registers clobbered!)
        pop     HL                      ; retrieve our source pile again

        ; because the cursor was positioned manually, we must update the
        ; variable for which pile/card the cursor is pointing at
        call    setPointPile

        ; the automatic move is complete,
        ; switch back to user-controlled cursor
        call    setCursorModeUser
        ; get the cursor position for the user-controlled cursor
        call    cursorPosForCard
        ; manually set the cursor position to avoid movement
        call    cursor.setPos
        ; set the flag to update the sprite table during v-blank
        call    sprites.update
        ; wait for the vblank to occur so that all changes to the tilemap
        ; and sprites are rendered before continuing as the caller might
        ; start making more tilemap changes
        jp      waitVBlank


movePileUndo
;===============================================================================
; moves cards between piles, but leaves the cursor
; on the destination (rather than source) pile:
;
; this is used to move cards when undoing a move,
; as you want the cursor to stay where it is
;
; in:   L       source pile index (`INDEX_*`)
;       A       card-index to take cards from, to the end of the pile
;       E       destination pile index
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        push    DE                      ; push destination pile index
        jr      movePile@undo           ; jump into routine, skipping source