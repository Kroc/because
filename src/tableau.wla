; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; card bytes:
;===============================================================================
; this section defines how we store cards in memory, one byte per card
;
; %bissnnnn     b     = "back" (back is visible)
;               i     = "inactive", 0=active, 1=inactive (unplayable card)
;               ss    = suit, 0-3,  0=spades, 1=clubs, 2=hearts, 3=diamonds
;               nnnn  = number, 1 (A), 2-9, 10 (J), 11 (Q), 12 (K),
;                       13-15 unused. 0 = no-card / null
;
.DEF    CARD_NONE       %00000000

.DEF    CARD_FRONT      %00000000       ; face-up card
.DEF    CARD_BACK       %10000000       ; face-down card

.DEF    CARD_ACTIVE     %00000000       ; card is playable
.DEF    CARD_INACTIVE   %01000000       ; card is disabled

; suits:                %--0----- = black
.DEF    SUIT_SPADE      %00000000
.DEF    SUIT_CLUB       %00010000
;                       %--1----- = red
.DEF    SUIT_HEART      %00100000
.DEF    SUIT_DIAMOND    %00110000

.DEF    CARD_A          %00000001
.DEF    CARD_2          %00000010
.DEF    CARD_3          %00000011
.DEF    CARD_4          %00000100
.DEF    CARD_5          %00000101
.DEF    CARD_6          %00000110
.DEF    CARD_7          %00000111
.DEF    CARD_8          %00001000
.DEF    CARD_9          %00001001
.DEF    CARD_X          %00001010
.DEF    CARD_J          %00001011
.DEF    CARD_Q          %00001100
.DEF    CARD_K          %00001101

; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 playfield.
; for our purposes we place the menu on the left and the playfield next to it,
; therefore the playfield begins at X = 12 and not the top-left (X = 0)
PLAYFIELD_TOP   = 0
PLAYFIELD_LEFT  = MENU_WIDTH
PLAYFIELD_ADDR  = tilemap.front_buffer + (PLAYFIELD_TOP * 32) + PLAYFIELD_LEFT

; cursor:
;===============================================================================
.RAMSECTION \
        "cursor"        RETURNORG
        ;-----------------------------------------------------------------------
        ; the address of the Pile struct that the cursor is pointing to;
        ; e.g. deck / depot; $0000 if cursor is free
        cursor_pile     WORD
        ; the number of the card in the pile the cursor is pointing at.
        ; note that this is 0-based and not 1-based like the pile size!
        cursor_card     BYTE
.ENDS

; tableau piles:
;===============================================================================
; regardless of the number of cards in a "deck" pile,
; it always displays as one face-down card
.DEF    PILE_DECK       %00000001
; like a "deck", the foundation does not spread,
; but differs by displaying the top card face-up
.DEF    PILE_FOUNDATION %00000010
; a downward spread of cards as you would typically see in Klondike
.DEF    PILE_COLUMN     %00000100

; for piles that spread to the right, instead of down the screen
; this flag can be added to the pile type
.DEF    PILE_HORZ       %10000000
.DEF    PILE_ROW        PILE_COLUMN | PILE_HORZ

.STRUCT Pile
        ;-----------------------------------------------------------------------
        ; we place the limit byte first so that when moving cards around,
        ; we can validate the movement without having to skip over fields
        ; that we will need to come back to
        ;
        type            BYTE    ; type of pile, i.e. deck, hand, foundation &c.
        limit           BYTE    ; max.number of cards allowed in pile, 1-based!
        count           BYTE    ; number of cards in the pile, 1-based!
        pool            WORD    ; address of storage for card pile
        row             BYTE    ; row position on the tilemap (not pixels!)
        col             BYTE    ; column position on the tilemap (not pixels!)
        left            BYTE    ; pile to the left of this one (lo-byte)
        right           BYTE    ; pile to the right of this one (lo-byte)
        up              BYTE    ; pile above this one (lo-byte)
        down            BYTE    ; pile below this one (lo-byte)
.ENDST

; define some RAM to hold cards during a game:
;
; the list of piles must not exceed 256 bytes
; as we increment only one register for speed!
.RAMSECTION \
        "layout"        ALIGN 256 SIZE 256 RETURNORG
        ;-----------------------------------------------------------------------
        ; a deck, where cards are drawn from
        deck            INSTANCEOF Pile
        ; a "discard" pile, where cards are thrown away
        discard         INSTANCEOF Pile
        ; a "hand" for cards to be played, e.g. three-card-draw
        hand            INSTANCEOF Pile
        ; up to four foundation piles, where cards are stacked in order
        foundation1     INSTANCEOF Pile
        foundation2     INSTANCEOF Pile
        foundation3     INSTANCEOF Pile
        foundation4     INSTANCEOF Pile
        ; up to eight depot piles, where cards are sorted
        depot1          INSTANCEOF Pile
        depot2          INSTANCEOF Pile
        depot3          INSTANCEOF Pile
        depot4          INSTANCEOF Pile
        depot5          INSTANCEOF Pile
        depot6          INSTANCEOF Pile
        depot7          INSTANCEOF Pile
        depot8          INSTANCEOF Pile
.ENDS

.RAMSECTION \
        "storage"       SIZE 1024       RETURNORG
        ;-----------------------------------------------------------------------
        storage         DSB 1024
.ENDS

.DEF    __pool_addr     tableau.storage

; use this macro before defining a set of piles in ROM
; in order to reset the starting pool address
;
.MACRO  BeginPiles
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.REDEF  __pool_addr     tableau.storage
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; this macro simplifies writing a pre-defined Pile of cards into ROM
;
.MACRO  DefinePile
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.DSTRUCT \1 INSTANCEOF Pile VALUES
        type:           .BYTE   \2
        limit:          .BYTE   \3
        count:          .BYTE   0       ; (assigned at run-time)
        pool:           .WORD   __pool_addr
        row:            .BYTE   \4
        col:            .BYTE   \5
        left:           .BYTE   <\6
        right:          .BYTE   <\7
        up:             .BYTE   <\8
        down:           .BYTE   <\9
.ENDST

.REDEF  __pool_addr     __pool_addr+\3

;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

clearBackground:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ; the background tile indices are 'signed', so what we think of as
        ; the first tile, tile "0", is tile # "-1", i.e $80
        ld      A,      $80
        ld      HL,     PLAYFIELD_ADDR
        ; number of tiles to skip to next row
        ld      DE,     32-20

        ;-----------------------------------------------------------------------
        ld      C,      32      ; 32 rows
@row:   ld      B,      20      ; 20 columns (13...32)
@col:   ld      [HL+],  A       ; set cell to empty background tile
        dec     B
        jr      nz, @col
        
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret

clearPiles:
;===============================================================================
; clear all piles, card storage:
;
; out:  DE      first address of the card storage pool
;       BC, A   set to zero, by nature of looping
;       HL      (clobbered)
;-------------------------------------------------------------------------------
        ld      HL,     SECTIONSTART_tableau.layout
        ld      BC,     (SECTIONEND_tableau.layout-SECTIONSTART_tableau.layout)+1
        call    zero
        ld      HL,     SECTIONSTART_tableau.layout
        ld      BC,     (SECTIONEND_tableau.layout-SECTIONSTART_tableau.layout)+1
        call    zero

        ; return the starting address of the card pool
        ; (used for allocating piles)
        ld      DE,     storage
        ret


allocateDeck:
;===============================================================================
; allocates the deck: (this is always 52 cards in size)
; the deck is populated with cards, but not shuffled
;
; in:   BC      address to a Pile structure (in ROM) to copy from
;-------------------------------------------------------------------------------
        ; HL    address of Pile structure (`deck`)
        ; BC    address of template Pile in ROM
        ld      HL,     deck
        call    allocatePile

        push    BC                      ; preserve new ROM address
        
        ; fill the deck with cards:
        ;-----------------------------------------------------------------------
        ; calling `addCard` 52 times would be needlessly slow,
        ; so we're going to manually write the pile size
        ld      A,      52
        ld      [deck.count],   A
        
        ; C will be our suit counter;
        ; 0=spades, 1=clubs, 2=hearts, 3=diamonds
        ld      C,      0

@next:  ld      B,      1               ; B = our ordinal counter, 1 to 13
-       ld      A,      C               ; begin with the suit 0-3
        swap    A                       ; suit bits go in the upper nybble
        or      B                       ; add the ordinal (1-13)
        or      CARD_BACK               ; flip the card over!
        ld      [DE],   A               ; store card and move to next slot
        inc     DE

        inc     B                       ; move to the next ordinal
        ld      A,      B               ; (need to use A for comparison)
        cp      CARD_K                  ; have we gone past the king?
        jr      nc,     -               ; no, continue adding cards

        inc     C                       ; move to the next suit
        bit     3,      C               ; have we hit 4?
        jr      z,      @next           ; no, do next suit

        ;-----------------------------------------------------------------------
        pop     BC                      ; restore new ROM address
        ret


allocatePile:
;===============================================================================
; allocates a pile where cards will be stored:
; e.g. a deck, hand, foundation or depot, etc.
;
; in:   HL      address of the working Pile structure in RAM;
;               this consists of a set of properties that will be filled out
;
;       BC      address of the template Pile structure (in ROM) to copy
;
; out:  HL      the structure address is moved forward over the Pile
;               structure. useful if you are allocating multiple piles
;               that directly follow each other in RAM
;
;       DE      address of the card pool for the pile, i.e. where the "cards",
;               each a byte, will be stored. this area will already have been
;               cleared according to the limit set in the template Pile
;
;       BC      the ROM address will have been moved over the Pile struct
;               allowing you to automatically use the next template in ROM
;
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        ; copy the Pile template (in ROM) over the working Pile in RAM:
        ;
        ; first byte is the type of the Pile
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; next byte is maximum number of cards in the pile (1-based)
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; (put aside max pile size until we clear the Pile's card pool)
        push    AF
        ; then the number of cards in the pile (defaults to 0)
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        
        ; next two bytes are the storage address;
        ; we put this aside in DE for later
        ld      A,      [BC]
        ld      E,      A               ; lo-byte first
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]
        ld      D,      A               ; hi-byte next
        ld      [HL+],  A
        inc     C

        ; next is the row/column position on the tilemap
        ld      A,      [BC]            ; read row (Y) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C
        ld      A,      [BC]            ; read column (X) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C

        ; positional data:
        ld      A,      [BC]            ; pile left
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile right
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile top
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile down
        ld      [HL+],  A
        inc     C

        ; clear the allocated card storage:
        ;-----------------------------------------------------------------------
        pop     AF                      ; retrieve max. card count
        push    BC                      ; preserve current ROM address
        push    DE                      ; keep original pool address

        ld      B,      A               ; copy card-limit to counter
        xor     A                       ; (write zeroes)

-       ld      [DE],   A               ; clear one byte
        inc     DE                      ; move to the next byte
        dec     B                       ; one less byte to fill
        jr      nz, -                   ; have we done all of them?

        pop     DE                      ; restore original pool address
        pop     BC                      ; restore current ROM address
        
        ret


addCard:
;===============================================================================
; add a card to a pile:
;
; in:   A       card to add (see CARD_* constants)
;       HL      address to the Pile structure, *not* the Pile's storage
;
; out:  HL      preserved, to allow adding multiple cards in row
;       carry   if the pile is full (card cannot be added), carry will be set
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve original HL for return
        ld      B,      A               ; put aside card to add for later

        ; read the max. number of cards allowed in the pile:
        inc     L                       ; (2nd byte in Pile struct)
        ld      C,      [HL]            ; C = pile limit
        inc     L
        ; read number of cards in the pile:
        ld      A,      [HL]            ; A = card count
        
        ; compare number of cards in pile, with max (1-based)
        cp      C
        jr      nc,      @full

        ; add card:
        ;-----------------------------------------------------------------------
        ; first increase the card count:
@add:   inc     A                       ; increase number of cards in pile
        ld      [HL],   A               ; write back updated card count
        
        ; now write the card to the card pool;
        ; begin by reading the storage address:
        inc     L
        ld      E,      [HL]            ; lo-byte first
        inc     L
        ld      D,      [HL]            ; then hi-byte

        ; move to the empty-slot at the end of the pile
        add     A,      E               ; add number of cards to pile addr.
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A

        ld      A,      B               ; retrieve card to add
        ld      [DE],   A               ; write to pile
        
        scf
        ccf

        pop     HL                      ; return original HL
        ret

        ; pile is full!
        ;-----------------------------------------------------------------------
@full:  scf

        ld      B,      B               ; DEBUG

        pop     HL                      ; return original HL
        ret


getPilePool:
;===============================================================================
; given a Pile struct address, returns the address
; in the card pool where the pile's cards are stored
;
; in:   HL      address of a Pile structure (e.g. deck, depot)
;
; out:  DE      address of the pile's card pool
;       A       number of cards currently in the pile (1-based!)
;       z       Z-flag is set according to the number of cards in the pile
;       HL      (preserved)
;-------------------------------------------------------------------------------
        inc     L                       ; skip the `type` field
        inc     L                       ; skip the `limit` field
        ; read the card count from the pool
        ld      A,      [HL+]           ; (also skip the `count` field)
        ld      E,      [HL]            ; read the pool address, lo-byte
        inc     L
        ld      D,      [HL]            ; read the pool address, hi-byte

        dec     L                       ; restore HL:
        dec     L                       ;  this is still faster than
        dec     L                       ;  PUSH and POPing HL
        dec     L

        and     A,      A               ; (set flags!)
        ret


getPilePos:
;===============================================================================
; retrieve the row & column co-ordinates (on the tile-map) of a pile:
; these are tile co-ordinates, NOT pixels!
;
; in:   HL      address of the Pile structure
;               (NOT the pile pool address)
;
; out:  B       row number of the pile on the tile-map
;       C       column number of the pile on-screen
;               (note that these two disregard scroll position!)
;
;       HL, DE  (preserved)
;       A       (preserved)
;-------------------------------------------------------------------------------
        ; this routine merely returns the X & Y tile co-ordinates stored
        ; in the Pile structure. the lack of index registers on the SM83
        ; is excruciating...
        ;
        push    HL

        ld      B,      0
        ld      C,      Pile.row
        add     HL,     BC
        
        ld      B,      [HL]
        inc     L
        ld      C,      [HL]
        
        pop     HL
        ret


drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; in:   HL      address of the Pile structure
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ld      A,      [HL+]           ; read type of pile
        inc     L                       ; skip max-size of pile
        
        ; is the pile a deck?
        cp      A,      PILE_DECK
        jr      z,      @deck

        ; column:
        ;-----------------------------------------------------------------------
@col:   ld      A,      [HL+]           ; read number of cards in pile
        and     A,      A               ; (set flags!)
        jr      z,      @empty          ; if zero, draw empty space

        ; get the pile's row & col (BC), and the card pool address (DE)
        call    @pos
        ; get screen-buffer address for the X/Y co-ords. note that this returns
        ; the address in HL, but clobbers BC. we depend upon it preserving A
        ; (our card count) and DE (the card pool address)
        call    tilemap.getBufferAddr
        ; retain the card-count for iterating through the pile
        ld      C,      A
        ; begin the pile at the first card
        ld      B,      0

        ; when a pile has multiple cards, the cards below only have their
        ; top row drawn, but the last card has to be drawn whole; the carry
        ; flag indicates this to the `draw_card` routine
        ;
-       inc     B                       ; (pre-increment our counter)
        ld      A,      B               ; compare current & total cards --
        cp      C                       ; carry is set, except the last card!
        push    BC                      ; (preserve when drawing)

        inc     DE                      ; move to next card in pile
                                        ; NOTE: does not change carry!
        ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)

        call    drawCard
        pop     DE
        pop     BC
        jr      c,      -

        ret

        ; deck:
        ;-----------------------------------------------------------------------
@deck:  ld      A,      [HL+]           ; read number of cards in pile
        and     A,      A               ; (set flags!)
        jr      z,      @empty          ; if zero, draw empty space

        ; get the pile's row & col
        call    @pos
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_3wide_5rows

        ; empty pile:
        ;-----------------------------------------------------------------------
        ; draw an empty pile on the buffer:
        ; first get the pile's row & col
@empty: call    @pos
        ; translate to an address on the buffer
        call    tilemap.getBufferAddr
        ; draw the empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_3wide_4rows

        ; get the position of the pile:
        ;-----------------------------------------------------------------------
@pos:   ld      E,      [HL]            ; read pool-address, lo-byte
        inc     L
        ld      D,      [HL]            ; read pool-address, hi-byte
        inc     L
        ld      B,      [HL]            ; read row
        inc     L
        ld      C,      [HL]            ; read column
        ret


drawCard:
;===============================================================================
; draws a card, handling all of its different properties
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
;       carry   if carry is set, only the first row will be drawn
;               (this is for drawing down-stacking piles)
;
; out:  carry   (preserved)
;       BC, DE  (clobbered)
;
; TODO: inactive
;-------------------------------------------------------------------------------
        bit     7,      A               ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;-----------------------------------------------------------------------
        ; face-down cards do not differ between active & inactive
        ld      DE,     tilemap.tilemap_back
        ; if carry is set, we want to draw only one row
        jp      c,      tilemap.writeTiles_3wide_1row
        ; otherwise draw the full card back
        jp              tilemap.writeTiles_3wide_4rows

        ; face-up:
        ;-----------------------------------------------------------------------
        ; remember the state of the carry flag;
        ; if set, we draw only the first row
@face:  push    AF
        ld      BC,     32-3            ; amount to skip to next row
        
        ; top-left corner: ordinal
        ld      D,      A               ; make a copy of the original value
        and     %00001111               ; trim out the other bits
        add     TILE3X4_CARD_1X1-1      ; offset the tile with the ordinal
        ld      [HL+],  A               ; write the tile and advance

        ; top-middle:
        ld      A,      TILE3X4_CARD_1X2
        ld      [HL+],  A

        ; top-right corner: suit
        ld      A,      D
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        ld      E,      A               ; remember the suit for later too
        add     TILE3X4_CARD_1X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; should we only draw the first row?
        pop     AF                      ; restore carry
        ret     c                       ; return now if carry-set

        ; middle:
        ld      A,      TILE3X4_CARD_2X1
        ld      [HL+],  A
        ld      A,      TILE3X4_CARD_2X2
        ld      [HL+],  A
        ld      A,      TILE3X4_CARD_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row
        ld      A,      TILE3X4_CARD_2X1
        ld      [HL+],  A
        ld      A,      TILE3X4_CARD_2X2
        ld      [HL+],  A
        ld      A,      TILE3X4_CARD_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; bottom-left: suit
        ld      A,      E               ; retrieve suit from earlier
        add     TILE3X4_CARD_4X1
        ld      [HL+],  A

        ; bottom-middle:
        ld      A,      TILE3X4_CARD_4X2
        ld      [HL+],  A

        ; bottom-right: ordinal
        ld      A,      D               ; retrieve ordinal from earlier
        and     %00001111               ; trim out the other bits
        add     TILE3X4_CARD_4X3-1      ; offset the tile with the ordinal
        ld      [HL+],  A               ; write the tile and advance

        ret


pointToPile:
;===============================================================================
; move the cursor to a specific pile, pointing to the default card,
; e.g. on columns this is the face-up card furthest down the screen
;
; in:   HL      address of the Pile structure
;-------------------------------------------------------------------------------
        ; the type of the Pile determines where the default card will be:
        ld      A,      [HL]
        ;;and     A,      A               ; (set flags!)

        ; squared piles that don't show each card (e.g. deck, foundation)
        ; always point to the "first" card:
        and     PILE_DECK | PILE_FOUNDATION
        jr      nz,     @first

        ; column piles must point to the last card:
        ; get the pile's card pool where the card-count is
@last:  call    tableau.getPilePool
        ; if there are zero cards in the pile, skip ahead
        jr      z,      pointToCard
        dec     A                       ; (adjust to 0-based)
        
        ; skip the next (1-byte) instruction:
        ; this is a `cp A, $nn` opcode with the next instruction
        ; becoming a harmless immediate 8-bit value
        .BYTE   $fe

@first: xor     A                       ; set A to zero

pointToCard:
;===============================================================================
; move the cursor to a specific card in a pile:
;
; in:   HL      address of the Pile structure
;       A       number of the card in the pile, 0-based!
;
; out:  B       row number the cursor will move to (not pixels!)
;       C       column number the cursor will move to (not pixels!)
;       A, DE   (clobbered)
;-------------------------------------------------------------------------------
        ; update the record of which pile/card is currently being pointed to.
        ; if a pile has multiple cards, then pushing up/down will go through
        ; the cards before leaving the pile
        ;
        ld      B,      A
        ; save the address of the pile to point to:
        ld      DE,     tableau.cursor_pile
        ld      A,      L
        ld      [DE],   A
        inc     DE
        ld      A,      H
        ld      [DE],   A
        inc     DE
        ; save the card number to point to:
        ; note that DE remains on this variable
        ld      A,      B
        ld      [DE],   A

        ; retrieve the row/column of the pile in BC
        call    tableau.getPilePos
        ; we will always be pointing to the horizontal middle of the card;
        ; in the case of face-up cards, we want to point to the space
        ; between the suit / number so as not to obscure either
        inc     C

        ; check the type of the pile, which will determine where the cursor
        ; will point more specifically. note that HL hasn't changed from the
        ; address of the current Pile
        ld      A,      [HL]
        
        cp      PILE_DECK
        jr      nz,     +

        ;; TODO: the centre of the deck is slightly raised

+       cp      PILE_COLUMN
        jr      z,      @col

        jp      cursor.moveToTile

        ; for a column, the cursor will be positioned differently
        ; for the top card (or empty pile), vs the spread
@col:   

        ; add the card number to the row number as
        ; each card in a pile adds another tile's height
        ld      A,      [DE]            ; retrieve card number
        add     A,      B
        ld      B,      A

        call    sprites.tilePosToScrXY
        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        jp      cursor.moveToScrXY


getCursorPile:
;===============================================================================
; returns the address of the Pile struct the cursor is pointing to:
;
; out:  HL      ; address of the Pile the cursor is pointing at
;       A       ; card number being pointed to, 0-based
;       DE      ; (clobbered)
;-------------------------------------------------------------------------------
        ; retrieve current pile location into DE
        ld      HL,     tableau.cursor_pile
        ld      E,      [HL]            ; pool address, lo-byte
        inc     HL
        ld      D,      [HL]            ; pool address, hi-byte
        inc     HL

        ; retrieve card number being pointed to
        ld      A,      [HL]
        inc     HL
        
        ld      H,      D
        ld      L,      E
        
        ret


moveCursorDown:
;===============================================================================
; move the cursor down, either going through a pile of cards,
; or downward to the nearest pile below the current one
;-------------------------------------------------------------------------------
        call    getCursorPile           ; retrieve current pile location
        ld      B,      A               ; card number pointed at (0-based)

        ; first byte is the type of Pile
        ld      A,      [HL]
        
        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile:
        and     PILE_DECK | PILE_FOUNDATION
        ret     nz                      ; TODO: move to next pile below

        ; have we reached the bottom of the column?
        ;-----------------------------------------------------------------------
        ; get pool address from the pile
        ; (number of cards in the pile is returned in A)
@col:   call    tableau.getPilePool
        ret     z                       ; no cards in the column?
        
        ; compare A (number of cards) with B (current card)
        dec     A                       ; pile-size is 1-based,
        cp      B                       ; but current card is 0-based
        
        ; if they are not equal, the pointer has not reached
        ; the top of the pile (visually, bottom on screen)
        ret     z

        ; move down one card
@card:  ld      A,      B
        inc     A
        jp      pointToCard

moveCursorUp:
;===============================================================================
; move the cursor up, either going through a pile of cards,
; or upwards to the nearest pile above the current one
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL) and card number pointed at (A)
        call    getCursorPile
        and     A,      A               ; (set flags!)
        
        ; is the current position 0? i.e. at the
        ; bottom (top, visually) of the pile?
        ret     z

        dec     A
        jp      pointToCard

moveCursorLeft:
;===============================================================================
; move the cursor left
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL)
        call    getCursorPile

        ; read the number of cards in the pile (first field) --
        ; we want to move the cursor to the top of the pile
        ; (furthest *down* the screen) and not to the bottom
        ;
        call    tableau.getPilePool     ; get pool address from the pile
        dec     A                       ; (adjust for 1-based)

        ; move to the field that contains the pile to the left
        ld      B,      0
        ld      C,      Pile.left
        add     HL,     BC
        ; read the lo-byte of the address of the pile to the left
        ld      L,      [HL]
        ; set the hi-byte for the piles
        ld      H,      >SECTIONSTART_tableau.layout
        
        ; move to the default card in the next pile
        jp      pointToPile

moveCursorRight:
;===============================================================================
; move the cursor right
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL)
        call    getCursorPile

        ; read the number of cards in the pile (first field) --
        ; we want to move the cursor to the top of the pile
        ; (furthest *down* the screen) and not to the bottom
        ;
        call    tableau.getPilePool     ; get pool address from the pile
        dec     A                       ; (adjust for 1-based)

        ; move to the field that contains the pile to the right
        ld      B,      0
        ld      C,      Pile.right
        add     HL,     BC
        ; read the lo-byte of the address of the pile to the right
        ld      L,      [HL]
        ; set the hi-byte for the piles
        ld      H,      >SECTIONSTART_tableau.layout
        
        ; move to the default card in the next pile
        jp      pointToPile