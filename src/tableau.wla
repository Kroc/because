; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 playfield.
; for our purposes we place the menu on the left and the playfield next to it,
; therefore the playfield begins at X = 12 and not the top-left (X = 0)
.DEF    TABLEAU_TOP     0
.DEF    TABLEAU_LEFT    MENU_WIDTH
.DEF    TABLEAU_ADDR    \
        tilemap.front_buffer + (TABLEAU_TOP * TILEMAP_WIDTH) + TABLEAU_LEFT
.DEF    TABLEAU_WIDTH   TILEMAP_WIDTH - MENU_WIDTH
.DEF    TABLEAU_HEIGHT  TILEMAP_HEIGHT


clearTiles:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ld      A,      TILE_TABLEAU_BG
        ; starting address of the tableau in the *front buffer*
        ld      HL,     TABLEAU_ADDR
        ; (number of tiles to skip to next row)
        ld      DE,     TILEMAP_WIDTH - SCREEN_WIDTH

        ;-----------------------------------------------------------------------
        ld      C,      TABLEAU_HEIGHT
@row:
.REPEAT TABLEAU_WIDTH
        ld      [HL+],  A       ; set cell to empty background tile
.ENDR
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


refresh:
;===============================================================================
; redraw the tableau:
;-------------------------------------------------------------------------------
        ; we're going to redraw all piles,
        ; so clear the tabelau of tiles first
        call    clearTiles
        ; evaluate which cards are available for play and which are not,
        ; marking cards as enabled or disabled as appropriate. when the
        ; piles are drawn, disabled cards will be drawn 'greyed-out'
        call    piles.checkPiles

        ; redraw each pile:
        ld      L,      INDEX_DECK
        call    drawPile
        ld      L,      INDEX_DISCARD
        call    drawPile
        ld      L,      INDEX_HAND
        call    drawPile
        ld      L,      INDEX_FOUNDATION1
        call    drawPile
        ld      L,      INDEX_FOUNDATION2
        call    drawPile
        ld      L,      INDEX_FOUNDATION3
        call    drawPile
        ld      L,      INDEX_FOUNDATION4
        call    drawPile
        ld      L,      INDEX_DEPOT1
        call    drawPile
        ld      L,      INDEX_DEPOT2
        call    drawPile
        ld      L,      INDEX_DEPOT3
        call    drawPile
        ld      L,      INDEX_DEPOT4
        call    drawPile
        ld      L,      INDEX_DEPOT5
        call    drawPile
        ld      L,      INDEX_DEPOT6
        call    drawPile
        ld      L,      INDEX_DEPOT7
        call    drawPile
        ld      L,      INDEX_DEPOT8
        call    drawPile
        ld      L,      INDEX_DEPOT9
        call    drawPile
        ld      L,      INDEX_DEPOT10
        call    drawPile
        ld      L,      INDEX_DEPOT11
        call    drawPile
        ld      L,      INDEX_DEPOT12
        
        ; just fall through to routine below
        ;

drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; in:   L       index (`INDEX_*`) of the pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; we automatically skip unallocated piles (type is 0):
        ; this is because the tableau attempts to draw all piles
        ; and only those a particular game uses should be drawn
        ;
        ld      H,      FIELD_TYPE
        ld      A,      [HL]            ; read pile type
        and     A,      A               ; (set flags!)
        ret     z                       ; if pile is unallocated, quit

        call    piles.getPos            ; get pile row & col (BC)

        ; is the pile empty?
        rst     piles.rst_pileCount     ; (get pile count, set flags)
        jr      z,      @empty          ; if zero, draw empty space

        ; check the specific type of pile:
        ; (note that A, card-count, is preserved through this)
        ;
        ld      H,      FIELD_TYPE      ; switch field back again
        bit     BIT_STACK,      [HL]    ; is it a stack?
        jr      nz,     @stack          ; -> handle stack-type piles
        bit     BIT_HORZ,       [HL]    ; is it a horizontal pile?
        jr      nz,     @row            ; -> handle horizontal spreads

        ; column:
        ;=======================================================================
@col:   rst     piles.rst_poolAddr      ; get card pool address (DE)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr

        ; retain the card-count for iterating through the pile;
        ; we will be counting toward zero, even though we will
        ; be drawing cards in order from index 0 upwards
        ld      C,      A
        ; subtract one because we want to draw the tops of all but the last
        ; card. once we've looped through the covered cards, we draw the
        ; top-most card separately
        dec     C
        ; of course, if there's only one card in the pile,
        ; just skip to drawing that in whole
        jr      z,      @@last
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)
        call    drawCardEdgeTop         ; draw only the first line of tiles
        pop     DE
        inc     DE                      ; move to next card in pile
        dec     C
        jr      nz,     -
        ;-----------------------------------------------------------------------
@@last  ld      A,      [DE]            ; read the top-most card
        jp      drawCard                ; draw it whole (and return)

        ;=======================================================================
        ; row:
        ;
@row:   rst     piles.rst_poolAddr      ; get card pool address (DE)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr
        
        ; retain the card-count for iterating through the pile;
        ; we will be counting toward zero, even though we will
        ; be drawing cards in order from index 0 upwards
        ld      C,      A
        ; subtract one because we want to draw the sides of all but the last
        ; card. once we've looped through the covered cards, we draw the
        ; top-most card separately
        dec     C
        ; of course, if there's only one card in the pile,
        ; just skip to drawing that in whole
        jr      z,      @@last
        ;-----------------------------------------------------------------------
-       ld      A,      [DE]            ; read a card value
        push    DE                      ; (preserve when drawing)
        call    drawCardEdgeLeft        ; draw only the first column of tiles
        pop     DE
        inc     DE                      ; move to next card in pile
        dec     C
        jr      nz,     -
        ;-----------------------------------------------------------------------
@@last  ld      A,      [DE]            ; read the top-most card
        jp      drawCard                ; draw it whole (and return)

        ;=======================================================================
        ; empty pile:
        ;
@empty: call    tilemap.getBufferAddr   ; translate row/col to buffer address

        ; draw the pre-baked empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_4rows

        ;=======================================================================
        ; stacks:
        ;
        ; is it a face-down stack (e.g. deck),
        ; or face-up stack (e.g. foundation)?
@stack: bit     BIT_FACE,       [HL]
        jr      nz,     @face

        ; read the top-most card in the pile
        call    piles.getLastCard
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_5rows

        ;=======================================================================
        ; stack with face-up card:
        ;
@face:  call    piles.getLastCard
        call    tilemap.getBufferAddr   ; translate to a buffer address

        ; fall through to below to draw
        ; the singular face-up card!
        ;

drawCard:
;===============================================================================
; draws a card, handling all of its different properties:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  BC      (preserved)
;       DE, HL  (clobbered)
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; draw the card in full
        jp      tilemap.writeTiles_4rows

        ;=======================================================================
        ; face-up:
        ;
@face:  push    AF

        call    drawCardEdgeTop

        pop     AF
        ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside

        ;-----------------------------------------------------------------------
        ; middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y2X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y2X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y2X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        call    drawCardEdgeTop@next    ; move to the next row
        ld      A,      TILE_CARD_Y3X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y3X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ld      A,      TILE_CARD_Y3X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-left: suit
        ;-----------------------------------------------------------------------
        call    drawCardEdgeTop@next    ; move to the next row
        ld      A,      D               ; retrieve card value once again
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y4X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y4X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; bottom-right: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; retrieve ordinal from earlier
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y4X3-1        ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ret


drawCardEdgeTop:
;===============================================================================
; for cards in a column where one card covers another,
; and we need to draw only the top edge of a card:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  HL      the buffer address is advanced to the next tilemap row
;       BC      (preserved)
;       AF, DE  (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; draw only the first line of the tiles
        jp      tilemap.writeTiles_1row

        ;=======================================================================
        ; face-up:
        ;
@face:  ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y1X1-1        ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y1X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-right corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y1X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ; fall through to automatically
        ; move to the next tilemap row
        ;

        ;=======================================================================
        ; move to the next tilemap row:
        ;-----------------------------------------------------------------------
        ; we could use `add HL, BC` but we want to preserve BC
        ;
@next:  ld      A,      TILEMAP_WIDTH-3 ; number of tiles to skip to next row
        add     A,      L               ; add this to the address lo-byte
        jr      nc,     +               ; did that overflow?
        inc     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret


drawCardEdgeLeft:
;===============================================================================
; for cards in a row where one card covers another,
; and we need to draw only the left edge of a card:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
; out:  HL      the buffer address is advanced to the next tilemap column
;       BC      (preserved)
;       AF, DE  (clobbered)
;-------------------------------------------------------------------------------
        bit     BIT_BACK,       A       ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back_left
        ; draw only the first line of the tiles
        jp      tilemap.writeTiles_1col

        ;=======================================================================
        ; face-up:
        ;
@face:  ld      D,      A               ; keep a copy of the original value

        ; disabled card?
        ;
        ; the highest bit of the card value is used to indicate a disabled
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second disabled set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the enabled and disabled card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     CARD_DISABLED           ; isolate the disabled bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     MASK_RANK | MASK_COLOUR ; trim out the other bits
        add     TILE_CARD_Y1X1-1        ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ;-----------------------------------------------------------------------
        ; middle-left:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_Y2X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ld      A,      TILE_CARD_Y3X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile
        call    @next                   ; move to next tilemap row
        ;-----------------------------------------------------------------------
        ; bottom-left corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D
        and     MASK_SUIT               ; mask out the other bits
        add     TILE_CARD_Y4X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL],   A               ; write the tile

        ; move front-buffer address to the next column;
        ; this involves moving up by 3 tilemap rows
        ;
        ld      A,      L
        sub     (TILEMAP_WIDTH*3)-1     ; (less one tile, to move right a col)
        jr      nc,     +               ; did that underflow?
        dec     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret

        ;=======================================================================
        ; move to the next tilemap row:
        ;-----------------------------------------------------------------------
        ; we could use `add HL, BC` but we want to preserve BC
        ;
@next:  ld      A,      L
        add     TILEMAP_WIDTH           ; number of tiles to skip to next row
        jr      nc,     +               ; did that overflow?
        inc     H                       ; if so, bump the address hi-byte
+       ld      L,      A
        ret