; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 playfield.
; for our purposes we place the menu on the left and the playfield next to it,
; therefore the playfield begins at X = 12 and not the top-left (X = 0)
.DEF    TABLEAU_TOP     0
.DEF    TABLEAU_LEFT    MENU_WIDTH
.DEF    TABLEAU_ADDR    \
        tilemap.front_buffer + (TABLEAU_TOP * TILEMAP_WIDTH) + TABLEAU_LEFT
.DEF    TABLEAU_WIDTH   TILEMAP_WIDTH - MENU_WIDTH
.DEF    TABLEAU_HEIGHT  TILEMAP_HEIGHT


clearTiles:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ld      A,      TILE_TABLEAU_BG
        ; starting address of the tableau in the *front buffer*
        ld      HL,     TABLEAU_ADDR
        ; (number of tiles to skip to next row)
        ld      DE,     TILEMAP_WIDTH - SCREEN_WIDTH

        ;-----------------------------------------------------------------------
        ld      C,      TABLEAU_HEIGHT
@row:
.REPEAT TABLEAU_WIDTH
        ld      [HL+],  A       ; set cell to empty background tile
.ENDR
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


refresh:
;===============================================================================
; redraw the tableau:
;-------------------------------------------------------------------------------
        ; we're going to redraw all piles,
        ; so clear the tabelau of tiles first
        call    clearTiles
        ; re-validate all piles to ensure they draw correctly
        ; given the game rules and current state of the game
        call    piles.validate

        ; redraw each pile:
        ld      L,      INDEX_DECK
        call    drawPile
        ld      L,      INDEX_DISCARD
        call    drawPile
        ld      L,      INDEX_HAND
        call    drawPile
        ld      L,      INDEX_FOUNDATION1
        call    drawPile
        ld      L,      INDEX_FOUNDATION2
        call    drawPile
        ld      L,      INDEX_FOUNDATION3
        call    drawPile
        ld      L,      INDEX_FOUNDATION4
        call    drawPile
        ld      L,      INDEX_DEPOT1
        call    drawPile
        ld      L,      INDEX_DEPOT2
        call    drawPile
        ld      L,      INDEX_DEPOT3
        call    drawPile
        ld      L,      INDEX_DEPOT4
        call    drawPile
        ld      L,      INDEX_DEPOT5
        call    drawPile
        ld      L,      INDEX_DEPOT6
        call    drawPile
        ld      L,      INDEX_DEPOT7
        call    drawPile
        ld      L,      INDEX_DEPOT8
        call    drawPile
        ld      L,      INDEX_DEPOT9
        call    drawPile
        ld      L,      INDEX_DEPOT10
        call    drawPile
        ld      L,      INDEX_DEPOT11
        call    drawPile
        ld      L,      INDEX_DEPOT12
        
        ; just fall through to routine below
        ;

drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; in:   L       index (`INDEX_*`) of the pile
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; we automatically skip unallocated piles (type is 0):
        ; this is because the tableau attempts to draw all piles
        ; and only those a particular game uses should be drawn
        ;
        ld      H,      FIELD_TYPE
        ld      A,      [HL]            ; read pile type
        and     A,      A               ; (set flags!)
        ret     z                       ; if pile is unallocated, quit

        ; check the type of pile:
        bit     7,      A               ; is it a stack?
        jr      nz,     @stack          ; -> handle stack-type piles

        ; is the pile empty?
        rst     piles.rst_pileCount     ; (get pile count, set flags)
        jr      z,      @empty          ; if zero, draw empty space

        ; column:
        ;-----------------------------------------------------------------------
        ; (note that A, card-count, is preserved through this)
@col:   rst     piles.rst_poolAddr      ; get card pool address (DE)
        call    piles.getPos            ; get pile row & col (BC)

        ; get screen-buffer address for the X/Y co-ords (BC). note that
        ; this returns the address in HL, but clobbers BC. we depend upon
        ; it preserving A (our card count) and DE (the pile pool address)
        call    tilemap.getBufferAddr
        ; retain the card-count for iterating through the pile
        ld      C,      A
        ; begin the pile at the first card
        ld      B,      0

        ; when a pile has multiple cards, the cards below only have their
        ; top row drawn, but the last card has to be drawn whole; the carry
        ; flag indicates this to the `drawCard` routine
        ;
-       inc     B                       ; (pre-increment our counter)
        ld      A,      B               ; compare current & total cards --
        cp      C                       ; carry is set, except the last card!
        push    BC                      ; (preserve when drawing)

        ld      A,      [DE]            ; read a card value
        inc     DE                      ; move to next card in pile
                                        ; NOTE: does not change carry!
        push    DE                      ; (preserve when drawing)

        call    drawCard

        pop     DE
        pop     BC
        jr      c,      -

        ret

        ;-----------------------------------------------------------------------
        ; empty pile:
        ;
@empty: call    piles.getPos            ; first get the pile's row & col
        call    tilemap.getBufferAddr   ; translate to a buffer address

        ; draw the pre-baked empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_4rows

        ;-----------------------------------------------------------------------
        ; stacks:
        ;
        ; is it a face-down stack (e.g. deck),
        ; or face-up stack (e.g. foundation)?
@stack: bit     5,      A               ; =`PILE_FACE`?
        jr      nz,     @face

        ; is the pile empty?
        rst     piles.rst_pileCount     ; (get pile count, set flags)
        jr      z,      @empty          ; if zero, draw empty space

        ; read the top-most card in the pile
        call    piles.getLastCardAddr
        ld      A,      [DE]

        ; get the pile's row & col
        call    piles.getPos
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_5rows

        ;-----------------------------------------------------------------------
        ; stack with face-up card:
        ;
        ; is the pile empty?
@face:  rst     piles.rst_pileCount     ; (get pile count, set flags)
        jr      z,      @empty          ; if zero, draw empty space

        call    piles.getLastCardAddr
        ld      A,      [DE]
        call    piles.getPos            ; get the pile's row & col
        call    tilemap.getBufferAddr   ; translate to a buffer address

        ; fall through to below to draw
        ; the singular face-up card!
        ;

drawCard:
;===============================================================================
; draws a card, handling all of its different properties:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
;       carry   if carry is set, only the first row will be drawn
;               (this is for drawing down-stacking piles)
;
; out:  carry   (preserved)
;       *       (clobbered)
;-------------------------------------------------------------------------------
        bit     6,      A               ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;=======================================================================
        ; face-down cards do not differ between valid & invalid
        ld      DE,     tilemap.tilemap_back
        ; if carry is set, we want to draw only one row
        jp      c,      tilemap.writeTiles_1row
        ; otherwise draw the full card back
        jp              tilemap.writeTiles_4rows

        ;=======================================================================
        ; face-up:
        ;
        ; remember the state of the carry flag;
        ; if set, we draw only the first row
@face:  push    AF
        ld      BC,     TILEMAP_WIDTH-3 ; amount to skip to next row
        ld      D,      A               ; keep a copy of the original value

        ; "invalid" (disabled) card?
        ;
        ; the highest bit of the card value is used to indicate an "invalid"
        ; card -- one that cannot be played. these are drawn in 'greyed-out'
        ; graphics. because the original mono GameBoy only has 1 background
        ; tile palette, we can't just recolour existing tiles and instead
        ; have to provide a second "invalid" set of card tiles in VRAM
        ;
        ; I've arranged VRAM such that the "valid" and "invalid" card tiles
        ; are exactly... $80 apart! in practice, this works in reverse because
        ; background tiles begin at $80 to $ff for the lower block and then
        ; $00 to $7f for the upper block (this due to sprites sharing half
        ; the tile data). since we need to add the opposite of bit 7 to
        ; tile indices we use XOR instead of OR to apply it
        ;
        and     %10000000               ; isolate the validity bit,
        ld      E,      A               ; and put it aside
        ;-----------------------------------------------------------------------
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; return to the original card value
        and     %00001111               ; trim out the other bits
        rlca
        add     TILE_CARD_1X1-2         ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance
        ;-----------------------------------------------------------------------
        ; top-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_1X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ;-----------------------------------------------------------------------
        ; top-right corner: suit
        ;-----------------------------------------------------------------------
        ld      A,      D
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca
        add     TILE_CARD_1X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; should we only draw the first row?
        pop     AF                      ; restore carry
        ret     c                       ; return now if carry-set
        ;-----------------------------------------------------------------------
        ; middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_2X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row
        ld      A,      TILE_CARD_2X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X3
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row
        ;-----------------------------------------------------------------------
        ; bottom-left: suit
        ;-----------------------------------------------------------------------
        ld      A,      D
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca
        add     TILE_CARD_4X1
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ;-----------------------------------------------------------------------
        ; bottom-middle:
        ;-----------------------------------------------------------------------
        ld      A,      TILE_CARD_4X2
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A
        ;-----------------------------------------------------------------------
        ; bottom-right: ordinal
        ;-----------------------------------------------------------------------
        ld      A,      D               ; retrieve ordinal from earlier
        and     %00001111               ; trim out the other bits
        rlca
        add     TILE_CARD_4X3-2         ; offset the tile with the ordinal
        xor     E                       ; add the invalid bit, if present
        ld      [HL+],  A               ; write the tile and advance

        ret