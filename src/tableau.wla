; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; card bytes:
;===============================================================================
; this section defines how we store cards in memory, one byte per card
;
; %bissnnnn     b     = "back" (back is visible)
;               i     = "inactive", 0=active, 1=inactive (unplayable card)
;               ss    = suit, 0-3,  0=spades, 1=clubs, 2=hearts, 3=diamonds
;               nnnn  = number, 1 (A), 2-9, 10 (J), 11 (Q), 12 (K),
;                       13-15 unused. 0 = no-card / null
;
.DEF    CARD_NONE       %00000000

.DEF    CARD_FRONT      %00000000       ; face-up card
.DEF    CARD_BACK       %10000000       ; face-down card

.DEF    CARD_ACTIVE     %00000000       ; card is playable
.DEF    CARD_INACTIVE   %01000000       ; card is disabled

; suits:                %--0----- = black
.DEF    SUIT_SPADE      %00000000
.DEF    SUIT_CLUB       %00010000
;                       %--1----- = red
.DEF    SUIT_HEART      %00100000
.DEF    SUIT_DIAMOND    %00110000

.DEF    CARD_A          %00000001
.DEF    CARD_2          %00000010
.DEF    CARD_3          %00000011
.DEF    CARD_4          %00000100
.DEF    CARD_5          %00000101
.DEF    CARD_6          %00000110
.DEF    CARD_7          %00000111
.DEF    CARD_8          %00001000
.DEF    CARD_9          %00001001
.DEF    CARD_X          %00001010
.DEF    CARD_J          %00001011
.DEF    CARD_Q          %00001100
.DEF    CARD_K          %00001101

; the GameBoy screen is 20x18 tiles, but VRAM contains a 32x32 playfield.
; for our purposes we place the menu on the left and the playfield next to it,
; therefore the playfield begins at X = 12 and not the top-left (X = 0)
.DEF    TABLEAU_TOP     0
.DEF    TABLEAU_LEFT    MENU_WIDTH
.DEF    TABLEAU_ADDR    \
        tilemap.front_buffer + (TABLEAU_TOP * TILEMAP_WIDTH) + TABLEAU_LEFT
.DEF    TABLEAU_WIDTH   TILEMAP_WIDTH - MENU_WIDTH
.DEF    TABLEAU_HEIGHT  TILEMAP_HEIGHT


; tableau piles:
;===============================================================================
; an unasigned pile is not drawn
.DEF    PILE_NONE       %00000000
; regardless of the number of cards in a deck,
; it always displays as one face-down card
.DEF    PILE_DECK       %00000001
; like a deck, but displays the top card face-up
.DEF    PILE_DISCARD    %00000010
; the foundation does not spread, and displays only the top card
; face-up. unlike a discard pile it does not show any depth
.DEF    PILE_FOUNDATION %00000100
; a downward spread of cards as you would typically see in Klondike
.DEF    PILE_COLUMN     %00001000

; for piles that spread to the right, instead of down the screen
; this flag can be added to the pile type
.DEF    PILE_HORZ       %10000000
.DEF    PILE_ROW        PILE_COLUMN | PILE_HORZ

.STRUCT Pile
        ;-----------------------------------------------------------------------
        ; we place the card count byte first so that we can easily identify
        ; empty piles first as all empty piles tend to look the same
        ; regardless of type
        ;
        count           BYTE    ; number of cards in the pile, 1-based!
        type            BYTE    ; type of pile, i.e. deck, hand, foundation &c.
        limit           BYTE    ; max.number of cards allowed in pile, 1-based!
        pool            WORD    ; address of storage for card pile
        row             BYTE    ; row position on the tilemap (not pixels!)
        col             BYTE    ; column position on the tilemap (not pixels!)
        left            BYTE    ; pile to the left of this one (lo-byte)
        right           BYTE    ; pile to the right of this one (lo-byte)
        up              BYTE    ; pile above this one (lo-byte)
        down            BYTE    ; pile below this one (lo-byte)
.ENDST

; define some RAM to hold cards during a game:
;
; the Piles store metadata with an address that points to the pool
; where the actual cards in the pile are stored; this is so that
; piles that are not being used do not require card storage
;
; the list of piles must not exceed 256 bytes
; as we increment only one register for speed!
;
.RAMSECTION "Layout"    ALIGN 256 SIZE 256 RETURNORG
        ;-----------------------------------------------------------------------
        ; a deck, where cards are drawn from
        deck            INSTANCEOF Pile
        ; a "discard" pile, where cards are thrown away
        discard         INSTANCEOF Pile
        ; a "hand" for cards to be played from, e.g. three-card-draw
        hand            INSTANCEOF Pile
        ; up to four foundation piles, where cards are stacked in order
        foundation1     INSTANCEOF Pile
        foundation2     INSTANCEOF Pile
        foundation3     INSTANCEOF Pile
        foundation4     INSTANCEOF Pile
        ; up to twelve depot piles, where cards are sorted and sorted
        depot1          INSTANCEOF Pile
        depot2          INSTANCEOF Pile
        depot3          INSTANCEOF Pile
        depot4          INSTANCEOF Pile
        depot5          INSTANCEOF Pile
        depot6          INSTANCEOF Pile
        depot7          INSTANCEOF Pile
        depot8          INSTANCEOF Pile
        depot9          INSTANCEOF Pile
        depot10         INSTANCEOF Pile
        depot11         INSTANCEOF Pile
        depot12         INSTANCEOF Pile
.ENDS

; the card pool is where the actual cards are stored; each Pile contains an
; address for the pool. the end of each pile in the pool is zero-terminated
; to minimise the need for counting registers
;
.RAMSECTION "Storage"   SIZE 1024       RETURNORG
        ;-----------------------------------------------------------------------
        storage         DSB 1024
.ENDS

.DEF    __pool_addr     tableau.storage

; use this macro before defining a set of piles in ROM
; in order to reset the starting pool address
;
.MACRO  BeginPiles
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.REDEF  __pool_addr     tableau.storage
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; this macro simplifies writing a pre-defined Pile of cards into ROM
;
.MACRO  DefinePile
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.DSTRUCT \1 INSTANCEOF Pile VALUES
        count:          .BYTE 0         ; (assigned at run-time)
        type:           .BYTE \2
        limit:          .BYTE \3
        pool:           .WORD __pool_addr
        row:            .BYTE \4
        col:            .BYTE \5
        left:           .BYTE <\6
        right:          .BYTE <\7
        up:             .BYTE <\8
        down:           .BYTE <\9
.ENDST

; move to the next available address in the pool;
; we include an extra byte for a zero terminator
.REDEF  __pool_addr     __pool_addr+\3+1

;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM


clearTiles:
;===============================================================================
; clears the tableau area, i.e. where cards are played:
;
;-------------------------------------------------------------------------------
        ld      A,      TILE_TABLEAU_BG
        ; starting address of the tableau in the *front buffer*
        ld      HL,     TABLEAU_ADDR
        ; (number of tiles to skip to next row)
        ld      DE,     TILEMAP_WIDTH - SCREEN_WIDTH

        ;-----------------------------------------------------------------------
        ld      C,      TABLEAU_HEIGHT
@row:
.REPEAT TABLEAU_WIDTH
        ld      [HL+],  A       ; set cell to empty background tile
.ENDR
        ; we only clear 20 out of 32 columns (menu area is preserved),
        ; so move to the next row by skipping ahead over the menu
        add     HL,     DE

        dec     C
        jr      nz, @row

        ret


clearPiles:
;===============================================================================
; clear all piles, card storage:
;
; out:  DE      first address of the card storage pool
;       BC, A   set to zero, by nature of looping
;       HL      (clobbered)
;-------------------------------------------------------------------------------
        ; return the starting address of the card pool (used for allocating
        ; piles). neither of the clear routines affect DE, allowing us to
        ; optimise the tail call
        ld      DE,     storage

        ; the tableau layout of piles is guaranteed to be less than 256 bytes
        ; so we can use `fill` instead of `zero` in this instance
        xor     A                       ; (set A to zero)
        ld      HL,     SECTIONSTART_tableau.Layout
        call    fill@f{SECTIONEND_tableau.Layout-SECTIONSTART_tableau.Layout}

        ; clear the card pool, this is 1KB
        ; (this must be zeroed because piles must be zero-terminated)
        ld      HL,     SECTIONSTART_tableau.Storage
        ld      BC,     SECTIONEND_tableau.Storage-SECTIONSTART_tableau.Storage
        jp     zero


allocateDeck:
;===============================================================================
; allocates the deck: (this is always 52 cards in size)
; the deck is populated with cards, but not shuffled
;
; in:   BC      address to a Pile structure (in ROM) to copy from
;-------------------------------------------------------------------------------
        ; HL    address of Pile structure (`deck`)
        ; BC    address of template Pile in ROM
        ld      HL,     deck
        call    allocatePile

        push    BC                      ; preserve new ROM address

        ; fill the deck with cards:
        ;-----------------------------------------------------------------------
        ; calling `addCard` 52 times would be needlessly slow,
        ; so we're going to manually write the pile size
        ld      A,              52
        ld      [deck.count],   A

        ; C will be our suit counter;
        ; 0=spades, 1=clubs, 2=hearts, 3=diamonds
        ld      C,      0

@next:  ld      B,      1               ; B = our ordinal counter, 1 to 13
-       ld      A,      C               ; begin with the suit 0-3
        swap    A                       ; suit bits go in the upper nybble
        or      B                       ; add the ordinal (1-13)
        or      CARD_BACK               ; flip the card over!
        ld      [DE],   A               ; store card and move to next slot
        inc     DE

        inc     B                       ; move to the next ordinal
        ld      A,      B               ; (need to use A for comparison)
        cp      CARD_K                  ; have we gone past the king?
        jr      nc,     -               ; no, continue adding cards

        inc     C                       ; move to the next suit
        bit     3,      C               ; have we hit 4?
        jr      z,      @next           ; no, do next suit

        ;-----------------------------------------------------------------------
        pop     BC                      ; restore new ROM address
        ret


allocatePile:
;===============================================================================
; allocates a pile where cards will be stored:
; e.g. a deck, hand, foundation or depot, etc.
;
; in:   HL      address of the working Pile structure in RAM;
;               this consists of a set of properties that will be filled out
;
;       BC      address of the template Pile structure (in ROM) to copy
;
; out:  HL      the structure address is moved forward over the Pile
;               structure. useful if you are allocating multiple piles
;               that directly follow each other in RAM
;
;       DE      address of the card pool for the pile, i.e. where the "cards",
;               each a byte, will be stored. this area will already have been
;               cleared according to the limit set in the template Pile
;
;       BC      the ROM address will have been moved over the Pile struct
;               allowing you to automatically use the next template in ROM
;
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        ; copy the Pile template (in ROM) over the working Pile in RAM:
        ;
        ; first byte is number of cards in the pile (defaults to 0)
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; next byte is the type of the Pile
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; then the maximum number of cards in the pile (1-based)
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; (put aside max pile size until we clear the Pile's card pool)
        push    AF
        
        ; next two bytes are the storage address;
        ; we put this aside in DE for later
        ld      A,      [BC]
        ld      E,      A               ; lo-byte first
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]
        ld      D,      A               ; hi-byte next
        ld      [HL+],  A
        inc     C

        ; next is the row/column position on the tilemap
        ld      A,      [BC]            ; read row (Y) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C
        ld      A,      [BC]            ; read column (X) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C

        ; positional data:
        ld      A,      [BC]            ; pile left
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile right
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile top
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile down
        ld      [HL+],  A
        inc     C

        ; clear the allocated card storage:
        ;-----------------------------------------------------------------------
        pop     AF                      ; retrieve max. card count
        push    BC                      ; preserve current ROM address
        push    DE                      ; keep original pool address

        ; the cards for a pile must be zero-terminated,
        ; so we add 1 to the count
        inc     A
        ld      B,      A               ; copy card-limit to counter
        xor     A                       ; (write zeroes)

-       ld      [DE],   A               ; clear one byte
        inc     DE                      ; move to the next byte
        dec     B                       ; one less byte to fill
        jr      nz, -                   ; have we done all of them?

        pop     DE                      ; restore original pool address
        pop     BC                      ; restore current ROM address
        ret


refresh:
;===============================================================================
; redraw the tableau:
;-------------------------------------------------------------------------------
        ; we're going to redraw all piles,
        ; so clear the tabelau of tiles first
        call    clearTiles

        ld      HL,     deck
        call    drawPile
        ld      HL,     discard
        call    drawPile
        ld      HL,     hand
        call    drawPile
        ld      HL,     foundation1
        call    drawPile
        ld      HL,     foundation2
        call    drawPile
        ld      HL,     foundation3
        call    drawPile
        ld      HL,     foundation4
        call    drawPile
        ld      HL,     depot1
        call    drawPile
        ld      HL,     depot2
        call    drawPile
        ld      HL,     depot3
        call    drawPile
        ld      HL,     depot4
        call    drawPile
        ld      HL,     depot5
        call    drawPile
        ld      HL,     depot6
        call    drawPile
        ld      HL,     depot7
        call    drawPile
        ld      HL,     depot8
        call    drawPile
        ld      HL,     depot9
        call    drawPile
        ld      HL,     depot10
        call    drawPile
        ld      HL,     depot11
        call    drawPile
        ld      HL,     depot12
        jp      drawPile


addCard:
;===============================================================================
; add a card to a pile:
;
; in:   A       card to add (see CARD_* constants)
;       HL      address to the Pile structure, *not* the Pile's storage
;
; out:  HL      preserved, to allow adding multiple cards in row
;       carry   if the pile is full (card cannot be added), carry will be set
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve original HL for return
        ld      B,      A               ; put aside card to add for later

        ; read number of cards in the pile:
        ld      A,      [HL+]
        inc     L                       ; (skip pile type field)
        ; read the max. number of cards allowed in the pile:
        ld      C,      [HL]
        
        ; compare number of cards in pile, with max (1-based)
        cp      C
        jr      nc,      @full

        ; add card:
        ;-----------------------------------------------------------------------
        ; write the card to the card pool;
        ; begin by reading the storage address:
@add:   inc     L
        ld      E,      [HL]            ; lo-byte first
        inc     L
        ld      D,      [HL]            ; then hi-byte

        ; move to the empty-slot at the end of the pile's card pool
        ;
        add     A,      E               ; add number of cards to pile addr.
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A

        ld      A,      B               ; retrieve card to add
        ld      [DE],   A               ; write to pile
        
        ; increase the card count:
        ; since this is the first byte in the Pile struct, and we need to
        ; return the address of the Pile struct in HL, we can kill two birds
        ; with one stone!
        pop     HL                      ; retrieve Pile addr
        inc     [HL]                    ; increase number of cards in pile

        scf
        ccf
        ret

        ; pile is full!
        ;-----------------------------------------------------------------------
@full:  scf

        ld      B,      B               ; DEBUG

        pop     HL                      ; return original HL
        ret


getCard:
;===============================================================================
; gets the value of a specific card in a pile:
;
; in:   HL      address of a Pile structure
;       A       index (0-based) of the card to return
;
; out:  A       value of card
;       DE      address of the card pool for the pile
;       HL      (preserved)
;-------------------------------------------------------------------------------
        ; get the pile's pool address (DE)
        call    getPilePool
        push    DE
        ; add the card index:
        add     A,      E               ; add card index to addr lo-byte
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A
        
        ld      A,      [DE]            ; read the card value from the pool

        pop     DE
        ret


removeCard:
;===============================================================================
; removes a card from a pile:
; the value of the card removed is returned
;
; note that it is up to the caller to ensure
; that there are no holes left in the pile!
;
; removing a card will NOT change the screen;
; call `tilemap.refresh` to redraw any modified piles
;
; in:   HL      address of the Pile
;       A       index (0-based) of the card to remove
;
; out:  A       value of card
;       DE      address of the card pool for the pile
;       HL      (preserved)
;-------------------------------------------------------------------------------
        ; reduce the number of cards in the pile first
        ; as that's the first byte in the Pile structure
        dec     [HL]

        ; get the pile's pool address (DE)
        call    getPilePool
        push    DE
        ; add the card index:
        add     A,      E               ; add card index to addr lo-byte
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A
        
        ; read and erase the card:
        ; (changing the size of the pile alone isn't enough as
        ; the list of cards in the pool must be zero-terminated)
        ;
        ld      A,      [DE]            ; read the card value from the pool
        push    AF                      ; keep card value
        xor     A                       ; set A to zero
        ld      [DE],   A               ; erase the card

        pop     AF                      ; return the card value
        pop     DE                      ; return the (starting) pool address
        ret


getPile:
;===============================================================================
; retrieves some basic Pile properties:
;
; in:   HL      address of a Pile structure (e.g. `deck`, `depot`)
;
; out:  A       number of cards in the pile, 1-based
;       B       Pile type (e.g. `PILE_DECK`)
;       C       maximum capacity of the pile, 1-based
;       DE      address in the card pool for the pile
;               (where the cards in the pile are stored)
;       HL      (preserved)
;-------------------------------------------------------------------------------
;;        ld      A,      [HL+]           ; card count
;;        ld      B,      [HL]            ; pile type
;;        inc     L
;;        ld      C,      [HL]            ; pile capacity
;;        inc     L
;;        ld      E,      [HL]            ; pool address, lo-byte
;;        inc     L
;;        ld      D,      [HL]            ; pool address, hi-byte
;;        
;;        dec     L                       ; restore HL:
;;        dec     L                       ;  this is still faster than
;;        dec     L                       ;  PUSH and POPing HL
;;        dec     L
;;        ret


getPilePool:
;===============================================================================
; given a Pile struct address, returns the address
; in the card pool where the pile's cards are stored
;
; in:   HL      address of a Pile structure (e.g. `deck`, `depot`)
;
; out:  DE      address of the pile's card pool
;       HL, A   (preserved)
;-------------------------------------------------------------------------------
        inc     L                       ; skip the `count` field
        inc     L                       ; skip the `type` field
        inc     L                       ; skip the `limit` field
        ld      E,      [HL]            ; read the pool address, lo-byte
        inc     L
        ld      D,      [HL]            ; read the pool address, hi-byte

        dec     L                       ; restore HL:
        dec     L                       ;  this is still faster than
        dec     L                       ;  PUSH and POPing HL
        dec     L

        ret


getPilePos:
;===============================================================================
; retrieve the row & column co-ordinates (on the tile-map) of a pile:
; these are tile co-ordinates, NOT pixels!
;
; in:   HL      address of the Pile structure
;               (NOT the pile pool address)
;
; out:  B       row number of the pile on the tile-map
;       C       column number of the pile on-screen
;               (note that these two disregard scroll position!)
;
;       HL, DE  (preserved)
;       A       (preserved)
;-------------------------------------------------------------------------------
        ; this routine merely returns the X & Y tile co-ordinates stored
        ; in the Pile structure. the lack of index registers on the SM83
        ; is excruciating...
        ;
        push    HL

        ld      B,      0
        ld      C,      Pile.row
        add     HL,     BC
        
        ld      B,      [HL]
        inc     L
        ld      C,      [HL]
        
        pop     HL
        ret


drawPile:
;===============================================================================
; draws a pile on the screen-buffer:
;
; TODO: if we can always forward HL to the next pile
;       it will help with refreshing the tableau
;
; in:   HL      address of the Pile structure
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; TODO: should probably swap type/count bytes? (AGAIN)
        inc     L
        ld      A,      [HL-]
        and     A,      A
        ret     z
        
        ld      A,      [HL+]           ; read number of cards in pile
        and     A,      A               ; (set flags!)
        jr      z,      @empty          ; if zero, draw empty space

        ; check the type of pile (note, preserving A)
        bit     0,      [HL]            ; is it a deck?
        jr      nz,     @deck

        ; column:
        ;-----------------------------------------------------------------------
        ; get the pile's row & col (BC), and the card pool address (DE)
@col:   call    @pos
        ; get screen-buffer address for the X/Y co-ords. note that this returns
        ; the address in HL, but clobbers BC. we depend upon it preserving A
        ; (our card count) and DE (the card pool address)
        call    tilemap.getBufferAddr
        ; retain the card-count for iterating through the pile
        ld      C,      A
        ; begin the pile at the first card
        ld      B,      0

        ; when a pile has multiple cards, the cards below only have their
        ; top row drawn, but the last card has to be drawn whole; the carry
        ; flag indicates this to the `draw_card` routine
        ;
-       inc     B                       ; (pre-increment our counter)
        ld      A,      B               ; compare current & total cards --
        cp      C                       ; carry is set, except the last card!
        push    BC                      ; (preserve when drawing)

        ld      A,      [DE]            ; read a card value
        inc     DE                      ; move to next card in pile
                                        ; NOTE: does not change carry!
        push    DE                      ; (preserve when drawing)

        call    drawCard
        pop     DE
        pop     BC
        jr      c,      -

        ret

        ; deck:
        ;-----------------------------------------------------------------------
        ; get the pile's row & col
@deck:  call    @pos
        ; the deck in particular extends a row upwards
        ; to give it that thicker appearance
        dec     B
        ; get an address in the buffer for the X/Y co-ords
        call    tilemap.getBufferAddr
        ; draw out the tiles for the deck
        ld      DE,     tilemap.tilemap_deck
        jp      tilemap.writeTiles_5rows

        ; empty pile:
        ;-----------------------------------------------------------------------
        ; draw an empty pile on the buffer:
        ; first get the pile's row & col
@empty: call    @pos
        ; translate to an address on the buffer
        call    tilemap.getBufferAddr
        ; draw the empty pile tiles
        ld      DE,     tilemap.tilemap_empty
        jp      tilemap.writeTiles_4rows

        ; get the position of the pile:
        ;-----------------------------------------------------------------------
@pos:   inc     L                       ; skip over card count byte
        inc     L                       ; skip over max-cards byte
        ld      E,      [HL]            ; read pool-address, lo-byte
        inc     L
        ld      D,      [HL]            ; read pool-address, hi-byte
        inc     L
        ld      B,      [HL]            ; read row
        inc     L
        ld      C,      [HL]            ; read column
        ret


drawCard:
;===============================================================================
; draws a card, handling all of its different properties:
;
; in:   HL      address in the front-buffer to draw the card
;       A       the card to draw
;       carry   if carry is set, only the first row will be drawn
;               (this is for drawing down-stacking piles)
;
; out:  carry   (preserved)
;       BC, DE  (clobbered)
;
; TODO: inactive
;-------------------------------------------------------------------------------
        bit     7,      A               ; is the card face-down?
        jr      z,      @face           ; if not, skip onto drawing face-up

        ; face-down:
        ;-----------------------------------------------------------------------
        ; face-down cards do not differ between active & inactive
        ld      DE,     tilemap.tilemap_back
        ; if carry is set, we want to draw only one row
        jp      c,      tilemap.writeTiles_1row
        ; otherwise draw the full card back
        jp              tilemap.writeTiles_4rows

        ; face-up:
        ;-----------------------------------------------------------------------
        ; remember the state of the carry flag;
        ; if set, we draw only the first row
@face:  push    AF
        ld      BC,     TILEMAP_WIDTH-3 ; amount to skip to next row
        
        ; top-left corner: ordinal
        ld      D,      A               ; make a copy of the original value
        and     %00001111               ; trim out the other bits
        rlca
        add     TILE_CARD_1X1-2         ; offset the tile with the ordinal
        ld      [HL+],  A               ; write the tile and advance

        ; top-middle:
        ld      A,      TILE_CARD_1X2
        ld      [HL+],  A

        ; top-right corner: suit
        ld      A,      D
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca
        ld      E,      A               ; remember the suit for later too
        add     TILE_CARD_1X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; should we only draw the first row?
        pop     AF                      ; restore carry
        ret     c                       ; return now if carry-set

        ; middle:
        ld      A,      TILE_CARD_2X1
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X2
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row
        ld      A,      TILE_CARD_2X1
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X2
        ld      [HL+],  A
        ld      A,      TILE_CARD_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to the next row

        ; bottom-left: suit
        ld      A,      E               ; retrieve suit from earlier
        add     TILE_CARD_4X1
        ld      [HL+],  A

        ; bottom-middle:
        ld      A,      TILE_CARD_4X2
        ld      [HL+],  A

        ; bottom-right: ordinal
        ld      A,      D               ; retrieve ordinal from earlier
        and     %00001111               ; trim out the other bits
        rlca
        add     TILE_CARD_4X3-2         ; offset the tile with the ordinal
        ld      [HL+],  A               ; write the tile and advance

        ret