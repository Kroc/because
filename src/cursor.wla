; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; default starting position of the cursor
; (for the GameBoy's screen)
.DEF    CURSOR_START_X  80
.DEF    CURSOR_START_Y  72

.DEF    MODE_FREE       0               ; cursor is free to move
.DEF    MODE_HOLD       1               ; cursor is holding cards
.DEF    MODE_CARD       2               ; moving card, no cursor

; (musn't cross an 8-bit boundary for a micro-optimisation)
;
.RAMSECTION "Cursor"    BITWINDOW 8     RETURNORG
        ;-----------------------------------------------------------------------
        dest_x          BYTE            ; new X-position to move cursor to
        xpos            BYTE            ; current cursor X-position (px)
        dest_y          BYTE            ; new Y-position to move cursor to
        ypos            BYTE            ; current cursor Y-position (px)
        ;-----------------------------------------------------------------------
        mode            BYTE            ; to control different cursor behaviour
.ENDS


init:
;===============================================================================
        ; clear variables:
        xor     A                       ; (set A to zero)
        ld      HL,     SECTIONSTART_cursor.Cursor
        call    fill@x{SECTIONEND_cursor.Cursor-SECTIONSTART_cursor.Cursor}

        ; configure the cursor sprite:
        ld      HL,     sprites.attrs
        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [ypos],         A
        ld      [dest_y],       A
        ld      [HL+],          A
        ld      A,      CURSOR_START_X  ; starting X-position
        ld      [xpos],         A
        ld      [dest_x],       A
        ld      [HL+],          A
        ld      A,      SPRITE_HAND_LHS ; tile-number
        ld      [HL+],  A
        xor     A                       ; (set A to zero)
        ld      [HL+],  A               ; display attribute

        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [HL+],  A
        ld      A,      CURSOR_START_X + 8
        ld      [HL+],  A
        ld      A,      SPRITE_HAND_RHS ; tile-number
        ld      [HL+],  A
        ld      [HL],   0               ; display attributes

        ; flag the sprite changes to be uploaded during vblank
        ld      HL,     update_sprites
        set     0,      [HL]

        ret


setMode:
;===============================================================================
; change the cursor behaviour mode:
;
; out:  BC      (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        ld      [mode], A
        and     A,      A
        jr      z,      @free
        dec     A
        jr      z,      @hold
        dec     A
        jr      z,      @card

        ret

        ; set the cursor to free-mode:
        ;-----------------------------------------------------------------------
        ; reset the hand sprite to the default cursor
@free:  ld      A,      SPRITE_HAND_LHS
        ld      [sprites.attrs.1.tile], A
        ld      A,      SPRITE_HAND_RHS
        ld      [sprites.attrs.2.tile], A
        ret

        ; set the cursor to hold-mode:
        ;-----------------------------------------------------------------------
        ; change the cursor to the holding hand
@hold:  ld      A,      SPRITE_HOLD_LHS
        ld      [sprites.attrs.1.tile], A
        ld      A,      SPRITE_HOLD_RHS
        ld      [sprites.attrs.2.tile], A
        ret

        ; set the cursor to card-mode:
        ;-----------------------------------------------------------------------
        ; hide the cursor, only the card will be visible
@card:  xor     A                       ; set A to 0 = SPRITE_NONE
        ld      [sprites.attrs.1.tile], A
        ld      [sprites.attrs.2.tile], A
        ret


clearSprites:
;===============================================================================
; remove the card sprites held by the cursor:
;
; out:  BC, DE  (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; address of the third sprite in the local sprite table;
        ; the first two sprites are the hand cursor
        ld      HL,     sprites.attrs.3
        ; because the number of bytes to clear is fixed we can jump into
        ; `fill` at the exact place needed. this is done not only for speed,
        ; but also to preserve BC. the number of bytes to clear is 38 sprites
        ; (cursor sprites are excluded), times 4 bytes per sprite
        ;
        xor     A                       ; (set A to zero)
        call    fill@x{38*_sizeof_Sprite}

        ; reset the hand sprite to the default cursor
        ld      A,      MODE_FREE
        call    setMode

        ; set the update flag to upload the sprite
        ; changes to VRAM during the next v-blank
        ld      HL,     update_sprites
        set     0,      [HL]
        ret


update:
;===============================================================================
; move the cursor one frame towards its destination:
;
; note that sprite position changes are written to the work RAM
; and this is automatically synced with OAM during vblank
;
; out:  DE      (preserved) -- MUST be preserved during vblank usage
;       HL/BC/A (clobbered)
;-------------------------------------------------------------------------------
        ; calculate the X & Y speed to move the cursor:
        ;
        ld      BC,     0               ; default X (C) & Y (B) speed is zero

        ; calculate X-speed:
        ;-----------------------------------------------------------------------
        ; is the cursor in its intended X-position? the destination X-position
        ; and current X-position are next to each other in RAM; we subtract
        ; them from each other to check for any difference
        ;
        ld      HL,     dest_x          ; begin with destination X addr
        ld      A,      [HL+]           ; read and increment addr to current-X
        sub     A,      [HL]            ; subtract destination-X from current-X
        jr      z,      +               ; if equal, no horizontal movement
        sra     A                       ; limit the maximum speed
        sra     A                       ; by dividing the distance by 4
        jr      nz,     +               ; if dividing reduced it to zero,
        inc     A                       ; move by at least 1 pixel
+       ld      C,      A               ; remember this "x-speed"

        ; calculate Y-speed:
        ;-----------------------------------------------------------------------
        ; is the cursor in its intended Y-position? the destination Y-position
        ; and current Y-position are next to each other in RAM; we subtract
        ; them from each other to check for any difference
        ;
        inc     L                       ; move to `cursor.dest_y`
        ld      A,      [HL+]           ; read and increment addr to current-Y
        sub     A,      [HL]            ; subtract destination-Y from current-Y
        jr      z,      +               ; if equal, no vertical movement
        sra     A                       ; limit the maximum speed
        sra     A                       ; by dividing the distance by 4
        jr      nz,     +               ; if dividing reduced it to zero,
        inc     A                       ; move by at least 1 pixel
+       ld      B,      A               ; remember "y-speed"

        ; any movement at all?
        or      C                       ; combine X-speed (C) & Y-speed (A)
        ret     z                       ; if zero, no movement to be done

        ; move card sprites:
        ;-----------------------------------------------------------------------
        ld      HL,     sprites.attrs.40.attr
-       dec     L                       ; skip sprite display attributes byte
        ld      A,      [HL-]           ; read sprite tile
        and     A,      A               ; (set flags!)
        jr      z,      +               ; stop at the last card sprite
        ld      A,      [HL]            ; read sprite X-position
        add     A,      C               ; add the speed differential
        ld      [HL-],  A               ; update sprite X-position
        ld      A,      [HL]            ; read sprite Y-position
        add     A,      B               ; add the speed differential
        ld      [HL-],  A               ; update sprite Y-position
        jr      -

        ; move the hand cursor: (sprites 1 & 2)
        ;-----------------------------------------------------------------------
+       ld      HL,     xpos
        ld      A,      C
        add     A,      [HL]            ; add distance to current `cursor.xpos`
        ld      [HL],   A               ; update the `cursor.xpos` variable
        ld      [sprites.attrs.1.x],    A
        add     A,      8
        ld      [sprites.attrs.2.x],    A

        ld      HL,     ypos
        ld      A,      B
        add     A,      [HL]            ; add distance to current `cursor.ypos`
        ld      [HL],   A               ; update the `cursor.ypos` variable
        ld      [sprites.attrs.1.y],    A
        ld      [sprites.attrs.2.y],    A

        ; set the update flag to upload the sprite
        ; changes to VRAM during the next v-blank
        ld      HL,     update_sprites
        set     0,      [HL]
        ret


getPointPile:
;===============================================================================
; returns the index of the Pile struct the cursor is pointing to:
;
; out:  L       index of the pile the cursor is pointing at
;       A       card index being pointed to, 0-based
;       BC, DE  (preserved)
;       H       (clobbered) -- select a field before using HL!
;-------------------------------------------------------------------------------
        ; retrieve index of pile being pointed at
        ld      HL,     tableau.pile_point
        ld      L,      [HL]
        ; retrieve card number being pointed to
        ld      A,      [tableau.card_point]
        ret


moveLeft:
;===============================================================================
; move the cursor left:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; retrieve current pile index (L),
        ; and the card index being pointed at (A)
        call    getPointPile

        ld      H,      FIELD_TYPE      ; check pile type to see
        bit     BIT_HORZ,       [HL]    ;  is this is a horizontal pile?
        jr      z,      @pile           ;  no? move straight to next pile

        ; horizontal spread:
        ;-----------------------------------------------------------------------
        ; is the current position 0? i.e. at the
        ; bottom (left, visually) of the pile?
        and     A,      A               ; (set flags!)
        jr      z,      @pile           ; if yes, move to next pile to the left

        ; do not point at a disabled card!
        dec     A                       ; move left a card
        rst     piles.rst_cardAddr      ; get the addr of that card
        ld      A,      [DE]            ; read its value
        bit     BIT_DISABLED,   A       ; if the card is enabled,
        jp      z,      pointToCard     ;  point to same pile, previous card

        ; card is disabled, move to
        ; the next pile instead
        ;

        ; move to the pile to the left:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_LEFT      ; read the `left` field that
        ld      L,      [HL]            ;  tells us the pile to point to
        jp      pointToPile


moveRight:
;===============================================================================
; move the cursor right:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        call    getPointPile            ; get pile (L) and card (A) index
        ld      C,      A               ; put aside card index
        rst     piles.rst_pileCount     ; get the card-count of the pile
        jr      z,      @pile           ; move cursor if this pile is emepty

        ld      H,      FIELD_TYPE      ; check pile type to see
        bit     BIT_HORZ,       [HL]    ;  is this is a horizontal pile?
        jr      z,      @pile           ;  no? move straight to next pile

        ; horizontal spread:
        ;-----------------------------------------------------------------------
        ; have we reached the end of the row?
        ;
        ; a neat trick is used here to both do the comparison and effectively
        ; add 1 to the card index to be able to move to the next card, *if*
        ; we're not at the end of the pile (and the card isn't disabled)
        ;
        inc     C                       ; adjust pointed-to card index
        cp      A                       ;  to 1-based and compare with count

        ; if equal, the end of the pile has been hit,
        ; move the cursor to the next pile
        jr      z,      @pile

        ; do not point at a disabled card!
        ld      A,      C               ; retrieve new card index
        rst     piles.rst_cardAddr      ; get the addr of that card
        ld      A,      [DE]            ; read its value
        bit     BIT_DISABLED,   A       ; if the card is enabled,
        ld      A,      C               ;  retrieve the new card index, and
        jp      z,      pointToCard     ;  point to same pile; next card

        ; card is disabled, move to
        ; the next pile instead
        ;

        ; move to the pile to the right:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_RIGHT     ; read the `right` field that
        ld      L,      [HL]            ;  tells us the pile to point to
        jp      pointToPile


moveUp:
;===============================================================================
; move the cursor up, either going through a pile of cards,
; or upwards to the nearest pile above the current one:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; retrieve current pile index (L),
        ; and the card index being pointed at (A)
        call    getPointPile

        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     @pile
        ; if currently in a horizontal pile, pressing up should just move
        ; to the next pile and not try flipping through the cards!
        bit     BIT_HORZ,       [HL]
        jr      nz,     @pile

        ; move up within the current pile:
        ;-----------------------------------------------------------------------
        and     A,      A               ; is the current position 0?
        jr      z,      @pile           ; if yes, move to next pile above

        ; do not point at a disabled card!
        dec     A                       ; move up a card
        ld      C,      A               ; before we read card, backup index
        rst     piles.rst_cardAddr      ; get the addr of that card
        ld      A,      [DE]            ; read its value
        bit     BIT_DISABLED,   A       ; if the card is enabled,
        ld      A,      C               ;  restore the new index, and
        jp      z,      pointToCard     ;  point to same pile; previous card

        ; card is disabled, move to
        ; the next pile instead
        ;

        ; move up to the next pile:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_UP        ; read the `up` field that
        ld      L,      [HL]            ;  tells us the pile to point to
        jr      pointToPile


moveDown:
;===============================================================================
; move the cursor down, either going through a pile of cards,
; or downward to the nearest pile below the current one:
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        call    getPointPile            ; retrieve current pile index
        ld      C,      A               ; card index pointed at (0-based)

        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     @pile
        ; if currently in a horizontal pile, pressing down should just move
        ; to the next pile and not try flipping through the current pile!
        bit     BIT_HORZ,       [HL]
        jr      nz,     @pile

        ; move down within the current pile:
        ;-----------------------------------------------------------------------
        ; get the number of cards in the pile
        rst     piles.rst_pileCount
        ; if there are no cards in the pile
        ; we can move to the pile below
        jr      z,      @pile

        ; have we reached the bottom of the column?
        ;
        ; a neat trick is used here to both do the comparison and effectively
        ; add 1 to the card index to be able to move to the next card, *if*
        ; we're not at the end of the pile
        ;
        inc     C                       ; adjust pointed-to card index
        cp      A,      C               ;  to 1-based and compare with count
        ld      A,      C

        ; (NOTE: we do not *yet* support a situation where the cursor
        ;  may be on an enabled card that is topped by a disabled card)

        ; if they are not equal, the pointer has not reached the top of
        ; the pile (visually, bottom on screen). move the cursor to the
        ; next card by using the 1-based index as 0-based!
        jr      nz,     pointToCard

        ; move down to the next pile:
        ;-----------------------------------------------------------------------
@pile:  ld      H,      FIELD_DOWN      ; read the `down` field that
        ld      L,      [HL]            ;  tells us the pile to point to

        ; fall through to below
        ; to point to the new pile!
        ;

pointToPile:
;===============================================================================
; move the cursor to a specific pile, pointing to the default card,
; e.g. on columns this is the face-up card furthest down the screen
;
; in:   L       index (`INDEX_*`) of the pile to point to
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; if there are zero cards in the pile, the default card is 0
        rst     piles.rst_pileCount     ; get pile count, set flags
        jr      z,      pointToCard     ; =0? point to it

        ; for any pile with multiple cards,
        ; we point to the last card by default
        dec     A                       ; (adjust to 0-based)

        ; fall through below
        ;

pointToCard:
;===============================================================================
; move the cursor to a specific card in a pile:
;
; in:   HL      address of the Pile structure
;       A       index of the card in the pile, 0-based!
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; update the record of which pile/card is currently being pointed to.
        ; if a pile has multiple cards, then pushing up/down will go through
        ; the cards before leaving the pile
        ;
        ; save the card index to point to: (0-based)
        ld      [tableau.card_point],   A
        ; (also put in a register for later comparison)
        ld      E,              A
        ; save the index of the pile to point to:
        ld      A,              L
        ld      [tableau.pile_point],   A

        ; get pile (L) row (B) & col (C)
        call    piles.getPos

        ; is the pile empty?
        rst     piles.rst_pileCount     ; get pile count (A), set flags
        jr      z,      @empty          ; -> draw an empty pile space
        ld      D,      A               ; also remember count for later

        ; for types of piles that have no spread (e.g. decks / foundations),
        ; we point to the top of the pile without counting cards
        ld      H,      FIELD_TYPE
        bit     BIT_SQUARE,     [HL]
        jr      nz,     @empty          ; TODO: the deck is slightly raised

        ; is this a horizontal or vertical spread of cards?
        bit     BIT_HORZ,       [HL]    ; check orientation bit
        jr      nz,     @horz           ; -> handle horizontal pile

        ; vertical spread:
        ;=======================================================================
        ; add the card index (A) to the row number (B),
        ; as each card in a pile adds another tile's height
        ;
@vert:  ld      A,      E               ; index of card pointed at
        add     A,      B               ; add the tilemap row of the pile
        ld      B,      A
        ; point to the horizontal middle of the card; want to point to
        ; the space between the suit / number so as not to obscure either
        inc     C

        ; for a spread, the cursor will be positioned
        ; differently for the top card, vs the spread
        ;
        ; compare the number of cards in the pile (A) to the target
        ; card (C). empty has already been checked so A must be > 0
        ;
        ld      A,      D               ; number of cards in the pile
        dec     A                       ; (adjust for 0-based)
        cp      E                       ; compare count against target card
        jr      z,      +

        ; within the spread:
        ;-----------------------------------------------------------------------
        ; translate the tile row (B)  & col (C)
        ; into the X & Y position in pixels
        call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        jr      moveToScrXY

        ; top-card:
        ;-----------------------------------------------------------------------
        ; for the card on top of the pile,
        ; point to the centre
+       inc     B
        ; translate the tile row (B)  & col (C)
        ; into the X & Y position in pixels
        call    sprites.tilePosToScrXY
        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        inc     B
        jr      moveToScrXY

        ;=======================================================================
        ; horizontal spread:
        ;
        ; add the card index (E) to the column number (C),
        ; as each card in a pile adds another tile's width
@horz:  ld      A,      C
        add     A,      E
        ld      C,      A
        ; point to the 2nd row, below the suit/ordinal
        inc     B

        ; for a horizontal spread, the cursor will be positioned
        ; differently for the top card, vs the other cards
        ;
        ; compare the number of cards in the pile to the target
        ; card. empty has already been checked so A must be > 0
        ;
        ld      A,      D               ; number of cards in the pile
        dec     A                       ; (adjust for 0-based)
        cp      E                       ; compare count against target card
        jr      nz,     +

        ; for the card on top of the pile,
        ; point to the centre
        inc     C

        ; translate the tile row (B)  & col (C)
        ; into the X & Y position in pixels
+       call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        inc     B
        dec     C
        jr      moveToScrXY

        ;=======================================================================
        ; empty pile:
        ;
        ; for empty piles, we want to point to the centre of the space
        ;
@empty: inc     C                       ; move right one col, to the middle
        inc     B                       ; move down one row, to the middle

        ; fall through to the move routine below!
        ;

moveToTile:
;===============================================================================
; move the cursor to a given tile row/col:
; this is a tile position, NOT pixels
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       row position to move the cursor to
;       C       column position to move the cursor to
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; convert the tile row/col to screen-space pixels
        call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        dec     C

        ; fall-through to set the cursor destination
        ;

moveToScrXY:
;===============================================================================
; move the cursor to a specific X/Y position on the screen, in pixels:
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination; another position can be set even whilst in motion
;
; in:   B       Y position to move the cursor to
;       C       X position to move the cursor to
;
; out:  A/BC/DE (preserved)
;       HL      (clobbered)
;-------------------------------------------------------------------------------
        ; update the destination cursor position
        ld      HL,     dest_x
        ld      [HL],   C               ; set destination X-position
        inc     L
        inc     L
        ld      [HL],   B               ; set distination Y-position

        ret


asCard:
;===============================================================================
; changes the cursor to a card, for example, when making auto-moves:
;
; the cursor's pointer (hand) will disappear and be replaced with the
; given card, which will appear in the new position without animation
;
; in:   A       a card value to replace the cursor with
;       B       new cursor position Y
;       C       new cursor position X
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        push    AF                      ; put aside card value for now

        call    clearSprites            ; clear any cards held by the cursor
        ld      A,      MODE_CARD       ; change the cursor mode, so that
        call    setMode                 ;  cursor's sprite disappears

        ; convert the X/Y tile positions into X/Y screen pixels
        call    sprites.tilePosToScrXY
        ; the sprite version of a card has a border we need to account for
        inc     B                       ; adjust 1px for top-border
        inc     C                       ; adjust 1px for left-border

        ; because all sprites are in 8x16 mode, we will need to overlap
        ; sprites where cards stack in a pile and due to sprite-priority,
        ; we have to assign sprites from the top of memory, downards
        ; (literally writing the sprite attributes backwards)
        ld      HL,     sprites.attrs.40.attr

        pop     AF
        ; create sprites for the top half of the card:
        call    sprites.cardToSprites_Top
        ld      A,      [DE]
        call    sprites.cardToSprites_Bottom

        ; set the update flag to upload the sprite
        ; changes to VRAM during the next v-blank
        ld      HL,     update_sprites
        set     0,      [HL]

        ret