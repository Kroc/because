; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; default starting position of the cursor
; (for the GameBoy's screen)
.DEF    CURSOR_START_X  80
.DEF    CURSOR_START_Y  72

.RAMSECTION "cursor"    SLOT "WRAMLO"           RETURNORG
        ;-----------------------------------------------------------------------
        cursor_dest_x   BYTE            ; new X-position to move cursor to
        cursor_x        BYTE            ; current cursor X-position
        cursor_dest_y   BYTE            ; new Y-position to move cursor to
        cursor_y        BYTE            ; current cursor Y-position
.ENDS


init:
;===============================================================================
; this configures the cursor sprite attributes in work RAM,
; which will be automatically written to OAM during vblank
;-------------------------------------------------------------------------------
        ; clear variables:
        xor     A                       ; A = 0
        ld      HL,     cursor_dest_x
        ld      [HL+],  A               ; cursor_dest_x = 0
        ld      [HL+],  A               ; cursor_x = 0
        ld      [HL+],  A               ; cursor_dest_y = 0
        ld      [HL+],  A               ; cursor_y = 0

        ; configure the cursor sprite:
        ld      HL,     sprites.attrs
        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [cursor_y],     A
        ld      [HL+],  A
        ld      A,      CURSOR_START_X  ; starting X-position
        ld      [cursor_x],     A
        ld      [HL+],  A
        ld      A,      SPRITE_HAND_LHS ; tile-number
        ld      [HL+],  A
        ld      A,      %00000000
        ld      [HL+],  A

        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [HL+],  A
        ld      A,      CURSOR_START_X + 8
        ld      [HL+],  A
        ld      A,      SPRITE_HAND_RHS ; tile-number
        ld      [HL+],  A
        ld      A,      %00000000
        ld      [HL+],  A

        ld      A,      8
        ld      [cursor_dest_x],        A
        ld      [cursor_dest_y],        A
        ret


moveToTile:
;===============================================================================
; move the cursor to a given tile row/col:
; this is a tile position, NOT pixels
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       row position to move the cursor to
;       C       column position to move the cursor to
;
; out:  HL      (preserved)
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        ; convert the tile row/col to screen-space pixels
        call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        dec     C

        ; fall-through to set the cursor destination
        ;

moveToScrXY:
;===============================================================================
; move the cursor to a specific X/Y position on the screen, in pixels:
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       Y position to move the cursor to
;       C       X position to move the cursor to
;
; out:  BC      (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; update the destination cursor position
        ld      HL,     cursor_dest_x
        ld      [HL],   C               ; set destination Y-position
        inc     HL
        inc     HL
        ld      [HL],   B               ; set distination X-position
        
        ret


clearCards:
;===============================================================================
; remove the cards held by the cursor:
;
;-------------------------------------------------------------------------------
        ; reset the sprites-in-use count
        ld      A,              2
        ld      [sprites.used], A
        ; number of bytes to clear: 38 sprites
        ; (cursor sprites are excluded),
        ; times 4 bytes per sprite
        ld      BC,     38 * _sizeof_Sprite
        ; address of the third sprite in the local sprite table;
        ; the first two sprites are the hand cursor
        ld      HL,     sprites.attrs.3
        ; zero all the bytes
        jp      zero


update:
;===============================================================================
; move the cursor one frame towards its destination:
;
; note that sprite position changes are written to the work RAM
; and this is automatically synced with OAM during vblank
;
; out:  BC, DE  (preserved)
;       HL, A   (clobbered)
;-------------------------------------------------------------------------------
        ; is the cursor in its intended X-position?
        ;
        ; the destination X-position and current X-position are next to each
        ; other in RAM; we subtract them from each other to check for any
        ; difference
        ld      HL,     cursor_dest_x   ; begin with destination X addr
        ld      A,      [HL+]           ; read and increment addr to current-X
        sub     A,      [HL]            ; subtract destination-X from current-X
        jr      z,      @y              ; if equal, no horizontal movement

        ; move in the X-direction:
        ; TODO: apply min/max speed?
        ;
        sra     A
        sra     A
        jr      nz,     +
        inc     A
+       add     A,      [HL]

        ld      [HL],                   A
        ld      [sprites.attrs.1.x],    A
        add     A,                      8
        ld      [sprites.attrs.2.x],    A

        ;-----------------------------------------------------------------------
@y:     inc     HL                      ; = cursor_dest_y
        ld      A,      [HL+]           ; read and increment addr to current-Y
        sub     A,      [HL]            ; subtract destination-Y from current-Y
        ret     z                       ; if equal, no vertical movement
        
        ; move in the Y-direction:
        ;
        sra     A
        sra     A
        jr      nz,     +
        inc     A
+       add     A,      [HL]

        ld      [HL],                   A
        ld      [sprites.attrs.1.y],    A
        ld      [sprites.attrs.2.y],    A

        ret
