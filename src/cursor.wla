; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; default starting position of the cursor
; (for the GameBoy's screen)
.DEF    CURSOR_START_X  80
.DEF    CURSOR_START_Y  72

.DEF    MODE_FREE       0               ; cursor is free to move
.DEF    MODE_HOLD       %10000000       ; cursor is holding cards

; (musn't cross an 8-bit boundary for a micro-optimisation)
;
.RAMSECTION "Cursor"    BITWINDOW 8     RETURNORG
        ;-----------------------------------------------------------------------
        dest_x          BYTE            ; new X-position to move cursor to
        xpos            BYTE            ; current cursor X-position (px)
        dest_y          BYTE            ; new Y-position to move cursor to
        ypos            BYTE            ; current cursor Y-position (px)
        ;-----------------------------------------------------------------------
        mode            BYTE            ; to control different cursor behaviour
        ;-----------------------------------------------------------------------
        ; the address of the Pile struct that the cursor is pointing to;
        ; e.g. deck / depot; $0000 if cursor is free
        pile_point      WORD
        ; the number of the card in the pile the cursor is pointing at.
        ; note that this is 0-based and not 1-based like the pile size!
        card_point      BYTE
        ;-----------------------------------------------------------------------
        temp            BYTE
        ;-----------------------------------------------------------------------
        ; when the cursor picks up a pile of cards, they are removed from
        ; the original pile and have to be stored elsewhere, so this Pile
        ; exist specifically for the cards in the cursor's hand. the storage
        ; pool is not used so that the cursor's pile has a fixed address
        ; that makes it easier to work with
        ;
        ; TODO: is 13 cards enough? what's the largest pile
        ;       that can be picked up in a game?
        ;       (note sprites are limited to 12 cards!)
        hand_pile       INSTANCEOF Pile
        hand_cards      DSB 13+1         ; +1 for zero-terminator!
.ENDS

; the pile used to hold cards in the hand needs a template;
; we need to ensure that this template doesn't cross an 8-bit boundary
;
.SECTION "CursorPiles"          BITWINDOW 8     RETURNORG
;###############################################################################
; force this template to use the fixed pool address!
.REDEF  __pool_addr             cursor.hand_cards

        ; label,                type, max-cards,
        ; row,                  col,
        ; pile-left,            pile-right,
        ; pile-up,              pile-down
tableau.DefinePile \
        pile_template,          PILE_COLUMN | PILE_HORZ, 13, \
        TILEMAP_HEIGHT-4,       TABLEAU_LEFT + 1, \
        0,                      0, \
        0,                      0
;###############################################################################
.ENDS


init:
;===============================================================================
        ; clear variables:
        xor     A                       ; (set A to zero)
        ld      HL,     SECTIONSTART_cursor.Cursor
        call    fill@f{SECTIONEND_cursor.Cursor-SECTIONSTART_cursor.Cursor}

        ; configure the cursor sprite:
        ld      HL,     sprites.attrs
        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [ypos],         A
        ld      [dest_y],       A
        ld      [HL+],          A
        ld      A,      CURSOR_START_X  ; starting X-position
        ld      [xpos],         A
        ld      [dest_x],       A
        ld      [HL+],          A
        ld      A,      SPRITE_HAND_LHS ; tile-number
        ld      [HL+],  A
        xor     A                       ; (set A to zero)
        ld      [HL+],  A               ; display attribute

        ld      A,      CURSOR_START_Y  ; starting Y-position
        ld      [HL+],  A
        ld      A,      CURSOR_START_X + 8
        ld      [HL+],  A
        ld      A,      SPRITE_HAND_RHS ; tile-number
        ld      [HL+],  A
        ld      [HL],   0               ; display attributes

        ; configure the pile for holding cards in the cursor hand
        ;-----------------------------------------------------------------------
        ld      BC,     pile_template   ; the ROM template to copy from
        ld      HL,     hand_pile       ; where to copy the template in RAM
        jp      tableau.allocatePile


clearHand:
;===============================================================================
; removes the cards from the cursor hand / pile:
;
; WARNING: the cards should be "dropped" on to another pile
; before calling this otherwise they will be permenantly lost!
;
; out:  DE      (preserved) -- required for `pickPile`
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        xor     A                       ; (set A to zero)
        ld      HL,     hand_pile.count ; set the pile card count to zero
        ld      [HL],   A
        ; zero out the list of cards in the private cursor pool
        ld      HL,     hand_cards
        call    fill@f{_sizeof_hand_cards}

        ; fall through to below to clear the sprites
        ;

clearSprites:
;===============================================================================
; remove the card sprites held by the cursor:
;
; out:  BC, DE  (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; reset the hand sprite to the default cursor
        ld      A,      SPRITE_HAND_LHS
        ld      [sprites.attrs.1.tile], A
        ld      A,      SPRITE_HAND_RHS
        ld      [sprites.attrs.2.tile], A
        ; reset the cursor mode to free-hand
        ld      HL,     mode
        ld      [HL],   MODE_FREE
        ; address of the third sprite in the local sprite table;
        ; the first two sprites are the hand cursor
        ld      HL,     sprites.attrs.3
        ; because the number of bytes to clear is fixed we can jump into
        ; `fill` at the exact place needed. this is done not only for speed,
        ; but also to preserve BC. the number of bytes to clear is 38 sprites
        ; (cursor sprites are excluded), times 4 bytes per sprite
        ;
        xor     A                       ; (set A to zero)
        jp      fill@f{38*_sizeof_Sprite}


update:
;===============================================================================
; move the cursor one frame towards its destination:
;
; note that sprite position changes are written to the work RAM
; and this is automatically synced with OAM during vblank
;
; out:  DE      (preserved) -- MUST be preserved during vblank usage
;       HL/BC/A (clobbered)
;-------------------------------------------------------------------------------
        ; calculate the X & Y speed to move the cursor:
        ;
        ld      BC,     0               ; default X (C) & Y (B) speed is zero

        ; calculate X-speed:
        ;-----------------------------------------------------------------------
        ; is the cursor in its intended X-position? the destination X-position
        ; and current X-position are next to each other in RAM; we subtract
        ; them from each other to check for any difference
        ;
        ld      HL,     dest_x          ; begin with destination X addr
        ld      A,      [HL+]           ; read and increment addr to current-X
        sub     A,      [HL]            ; subtract destination-X from current-X
        jr      z,      +               ; if equal, no horizontal movement
        sra     A                       ; limit the maximum speed
        sra     A                       ; by dividing the distance by 4
        jr      nz,     +               ; if dividing reduced it to zero,
        inc     A                       ; move by at least 1 pixel
+       ld      C,      A               ; remember this "x-speed"

        ; calculate Y-speed:
        ;-----------------------------------------------------------------------
        ; is the cursor in its intended Y-position? the destination Y-position
        ; and current Y-position are next to each other in RAM; we subtract
        ; them from each other to check for any difference
        ;
        inc     L                       ; move to `cursor.dest_y`
        ld      A,      [HL+]           ; read and increment addr to current-Y
        sub     A,      [HL]            ; subtract destination-Y from current-Y
        jr      z,      +               ; if equal, no vertical movement
        sra     A                       ; limit the maximum speed
        sra     A                       ; by dividing the distance by 4
        jr      nz,     +               ; if dividing reduced it to zero,
        inc     A                       ; move by at least 1 pixel
+       ld      B,      A               ; remember "y-speed"

        ; any movement at all?
        or      C                       ; combine X-speed (C) & Y-speed (A)
        ret     z                       ; if zero, no movement to be done

        ; move card sprites:
        ;-----------------------------------------------------------------------
        ld      HL,     sprites.attrs.40.attr
-       dec     L                       ; skip sprite display attributes byte
        ld      A,      [HL-]           ; read sprite tile
        and     A,      A               ; (set flags!)
        jr      z,      +               ; stop at the last card sprite
        ld      A,      [HL]            ; read sprite X-position
        add     A,      C               ; add the speed differential
        ld      [HL-],  A               ; update sprite X-position
        ld      A,      [HL]            ; read sprite Y-position
        add     A,      B               ; add the speed differential
        ld      [HL-],  A               ; update sprite Y-position
        jr      -

        ; move the hand cursor: (sprites 1 & 2)
        ;-----------------------------------------------------------------------
+       ld      HL,     xpos
        ld      A,      C
        add     A,      [HL]            ; add distance to current `cursor.xpos`
        ld      [HL],   A               ; update the `cursor.xpos` variable
        ld      [sprites.attrs.1.x],    A
        add     A,      8
        ld      [sprites.attrs.2.x],    A

        ld      HL,     ypos
        ld      A,      B
        add     A,      [HL]            ; add distance to current `cursor.ypos`
        ld      [HL],   A               ; update the `cursor.ypos` variable
        ld      [sprites.attrs.1.y],    A
        ld      [sprites.attrs.2.y],    A

        ret


getPointPile:
;===============================================================================
; returns the address of the Pile struct the cursor is pointing to:
;
; out:  HL      address of the Pile the cursor is pointing at
;       A       card number being pointed to, 0-based
;       DE      (preserved)
;-------------------------------------------------------------------------------
        ; retrieve address of pile being pointed at
        ld      HL,     pile_point
        ld      A,      [HL+]           ; read pile address, lo-byte
        ld      H,      [HL]            ; read pile address, hi-byte
        ld      L,      A
        ; retrieve card number being pointed to
        ld      A,      [card_point]

        ret


moveLeft:
;===============================================================================
; move the cursor left
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL)
        call    getPointPile

        ; move to the field that contains the pile to the left
        ld      B,      0
        ld      C,      Pile.left
        add     HL,     BC
        ; read the lo-byte of the address of the pile to the left
        ld      L,      [HL]
        ; set the hi-byte for the piles
        ld      H,      >tableau.layout

        ; move to the default card in the next pile
        jp      pointToPile


moveRight:
;===============================================================================
; move the cursor right
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL)
        call    getPointPile

        ; move to the field that contains the pile to the right
        ld      B,      0
        ld      C,      Pile.right
        add     HL,     BC
        ; read the lo-byte of the address of the pile to the right
        ld      L,      [HL]
        ; set the fixed hi-byte for the piles
        ld      H,      >tableau.layout

        ; move to the default card in the next pile
        jp      pointToPile


moveUp:
;===============================================================================
; move the cursor up, either going through a pile of cards,
; or upwards to the nearest pile above the current one
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL),
        ; and the card index being pointed at (A)
        call    getPointPile
        and     A,      A               ; (set flags!)

        ; is the current position 0? i.e. at the
        ; bottom (top, visually) of the pile?
        jr      z,      @pile

        dec     A
        jp      pointToCard

        ; move up to the next pile:
        ;-----------------------------------------------------------------------
@pile:  ld      BC,     Pile.up         ; read the `up` field that
        add     HL,     BC              ;  tells us the pile to move to
        ld      L,      [HL]            ; (read the lo-byte of the Pile)
        ld      H,      >tableau.layout ; the hi-byte is fixed
        jp      pointToPile


moveDown:
;===============================================================================
; move the cursor down, either going through a pile of cards,
; or downward to the nearest pile below the current one
;-------------------------------------------------------------------------------
        call    getPointPile            ; retrieve current pile location
        ld      C,      A               ; card number pointed at (0-based)

        ; first byte is the number of cards in the pile
        ld      A,      [HL]
        and     A,      A               ; (set flags!)
        ; if there are no cards in the pile
        ; we can move to the pile below
        jr      z,      @pile

        ; next byte is the type of Pile
        inc     L                       ; move to `type` field
        ld      A,      [HL-]           ; (return HL to card-count)
        ; for types of piles that have no spread (e.g. decks / foundations),
        ; there are no cards to step through, just move to the next pile:
        and     PILE_DECK | PILE_FOUNDATION
        jr      nz,     @pile

        ; have we reached the bottom of the column?
        ;-----------------------------------------------------------------------
        ; are we pointing at the last card in the pile?
        ; a neat trick is used here to both do the comparison and effectively
        ; add 1 to the card index to be able to move to the next card, *if*
        ; we're not at the end of the pile
        ;
@col:   ld      A,      C               ; index of current-card (0-based)
        inc     A                       ; adjust to 1-based but also next card!
        cp      [HL]                    ; compare against card-count (1-based)
        
        ; if they are not equal, the pointer has not reached the top of
        ; the pile (visually, bottom on screen). move the cursor to the
        ; next card by using the 1-based index as 0-based!
        jp      nz,     pointToCard

        ; move down to the next pile:
        ;-----------------------------------------------------------------------
@pile:  ld      BC,     Pile.down       ; read the `down` field that
        add     HL,     BC              ;  tells us the pile to move to
        ld      L,      [HL]            ; (read the lo-byte of the Pile)
        ld      H,      >tableau.layout ; hi-byte is fixed

        ; fall through to below
        ; to point to the new pile!
        ;

pointToPile:
;===============================================================================
; move the cursor to a specific pile, pointing to the default card,
; e.g. on columns this is the face-up card furthest down the screen
;
; in:   HL      address of the Pile structure
;-------------------------------------------------------------------------------
        ; if there are zero cards in the pile, the default card is 0
        ld      A,      [HL]            ; first byte is number of cards in pile
        and     A,      A               ; (set flags!)
        jr      z,      pointToCard     ; =0? point to it

        ; for non-empty piles, the type of the Pile
        ; determines where the default card will be:
        inc     L
        ld      A,      [HL-]           ; read pile type
        ; (note how we've moved HL back to the beginning!)

        ; squared piles that don't show each card (e.g. deck, foundation)
        ; always point to the "first" card:
        and     PILE_DECK | PILE_FOUNDATION
        jr      nz,     @first

        ; column piles must point to the last card:
        ld      A,      [HL]            ; retrieve card count
        dec     A                       ; (adjust to 0-based)

        .byte   $fe

@first: xor    A

pointToCard:
;===============================================================================
; move the cursor to a specific card in a pile:
;
; in:   HL      address of the Pile structure
;       A       index of the card in the pile, 0-based!
;
; out:  *       (clobbered)
;-------------------------------------------------------------------------------
        ; update the record of which pile/card is currently being pointed to.
        ; if a pile has multiple cards, then pushing up/down will go through
        ; the cards before leaving the pile
        ;
        ; save the card number to point to: (0-based)
        ld      [card_point],   A
        ; (also put in a register for later comparison)
        ld      C,      A
        ; save the address of the pile to point to:
        ld      A,      L
        ld      [cursor.pile_point+LO],A
        ld      A,      H
        ld      [cursor.pile_point+HI],A

        ; is the pile empty?
        ld      A,      [HL+]           ; read pile count
        and     A,      A               ; (set flags)
        jr      z,      @empty

        ; check the type of the pile, which will determine
        ; where the cursor will point more specifically
        ; (note that A is untouched here!)
        bit     0,      [HL]            ; deck?
        jr      nz,     @empty          ; TODO: the deck is slightly raised
        bit     1,      [HL]            ; foundation?
        jr      nz,     @empty

        ; for a column, the cursor will be positioned
        ; differently for the top card, vs the spread
        ;-----------------------------------------------------------------------
        ; compare the number of cards in the pile to the target card
        ; (empty has already been checked so A must be > 0)
@col:   dec     A                       ; (adjust for 0-based)
        cp      C                       ; compare against target card
        jr      z,      @top

        call    @pos
        call    @stack

        call    sprites.tilePosToScrXY
        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        jp      moveToScrXY

        ; retrieve the row/column of the pile
        ;-----------------------------------------------------------------------
@pos:   dec     L                       ; (move HL back to Pile start)
        call    tableau.getPilePos      ; get Pile row (B) & col (C)

        ; we will always be pointing to the horizontal middle of the card;
        ; in the case of face-up cards, we want to point to the space
        ; between the suit / number so as not to obscure either
        inc     C
        ret

        ; offset the cursor according to the card number in the stack
        ;-----------------------------------------------------------------------
@stack: ; add the card number to the row number as
        ; each card in a pile adds another tile's height
        ld      A,      [card_point]    ; retrieve card number to point to
        add     A,      B
        ld      B,      A
        ret

        ; top card:
        ;-----------------------------------------------------------------------
@top:   call    @pos
        call    @stack
        inc     B

        call    sprites.tilePosToScrXY
        dec     C
        dec     C
        jp      moveToScrXY

        ; empty pile:
        ;-----------------------------------------------------------------------
        ; for empty piles, we want to point to the centre of the space
        ;
@empty: call    @pos                    ; get Pile row/col
        inc     B                       ; move down one row, to the middle

        ; fall through to the move routine below!
        ;


moveToTile:
;===============================================================================
; move the cursor to a given tile row/col:
; this is a tile position, NOT pixels
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       row position to move the cursor to
;       C       column position to move the cursor to
;
; out:  HL      (preserved)
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        ; convert the tile row/col to screen-space pixels
        call    sprites.tilePosToScrXY

        ; offset the cursor a little so that it appears
        ; over the cards rather than on the outside edge
        ld      A,      5
        add     A,      B
        ld      B,      A
        dec     C

        ; fall-through to set the cursor destination
        ;

moveToScrXY:
;===============================================================================
; move the cursor to a specific X/Y position on the screen, in pixels:
;
; the move isn't instant, it'll move over several frames until it reaches
; its destination. another position can be set even whilst in motion
;
; in:   B       Y position to move the cursor to
;       C       X position to move the cursor to
;
; out:  BC      (preserved)
;       A, HL   (clobbered)
;-------------------------------------------------------------------------------
        ; update the destination cursor position
        ld      HL,     dest_x
        ld      [HL],   C               ; set destination X-position
        inc     L
        inc     L
        ld      [HL],   B               ; set distination Y-position

        ret


doAction:
;===============================================================================
; button pressed; pick up a pile or drop held cards, according to context:
;
;-------------------------------------------------------------------------------
        ld      A,      [mode]  ; get cursor mode
        and     A,      A       ; (set flags!)

        ; if the cursor is free (not holding any cards),
        ; attempt to pick up the pile being pointed at
        jr      z,      pickPile
        ; the cursor is holding cards, try dropping them
        jp      dropPile


pickPile:
;===============================================================================
; attempt to pick up a pile:
;
; this will attempt to pick up all the cards from the one
; currently pointed to, down to the top of the pile
;
;-------------------------------------------------------------------------------
        ; retrieve current pile location (HL),
        ; and the card index being pointed at (A)
        call    getPointPile
        ld      C,      A

        ; is the pile empty?
        ;-----------------------------------------------------------------------
        ld      A,      [HL]            ; read card count
        and     A,      A               ; (set flags!)
        jp      z,      @err            ; if pile is empty, exit

        ; TODO: validate pick

        ; move pile to cursor's pile:
        ;-----------------------------------------------------------------------
        ; move all the cards in the source pile, from
        ; the index card down, to the cursor's pile:
        ld      DE,     hand_pile
        ld      A,      C
        ; the destination pile's address is returned in HL, and the 
        ; destination pile's pool address in DE, which is where we
        ; want to start creating sprites from
        call    tableau.movePile

        ; initialise sprites:
        ;-----------------------------------------------------------------------
        ; change the cursor to the holding hand
        ld      A,      SPRITE_HOLD_LHS
        ld      [sprites.attrs.1.tile], A
        ld      A,      SPRITE_HOLD_RHS
        ld      [sprites.attrs.2.tile], A
        ; change the cursor mode so that the cards move with the cursor
        ld      HL,     mode
        ld      [HL],   MODE_HOLD

        ; set our starting X/Y position for building card sprites:
        ld      A,      [ypos]
        ld      B,      A               ; B will be the Y-position (px)
        ld      A,      [xpos]
        add     A,      8               ; add 8 to X to fit in the cursor hand
        ld      C,      A               ; C will be the X-position (px)

        ; because all sprites are in 8x16 mode, we will need to overlap
        ; sprites where cards stack in a pile and due to sprite-priority,
        ; we have to assign sprites from the top of memory, downards
        ; (literally writing the sprite attributes backwards)
        ld      HL,     sprites.attrs.40.attr

        ; convert cards to sprites:
        ;-----------------------------------------------------------------------
        ; seed the loop with the first card value
        ld      A,      [DE]

        ; we must remember the current card value so that after
        ; the zero-terminator is encountered, we can construct
        ; the bottom-half of the last card (not covered)
@loop:  ld      [temp], A

        ; create sprites for the top half of each card:
        ; (only the last card has a bottom half)
        ;=======================================================================
        ; top-left corner: ordinal
        ;-----------------------------------------------------------------------
        ld      [HL],   %00000000       ; set sprite display attribute
        dec     L                       ; (move to sprite tile byte)
        and     %00001111               ; trim out the other bits of card value
        rlca                            ; x2 tile index due to 8x16 sprites
        add     SPRITE_CARD_12X1-2      ; offset the tile with the ordinal
        ld      [HL-],  A               ; set the sprite's tile
        ld      A,      C
        ld      [HL-],  A               ; write sprite X-position
        ld      A,      B
        ld      [HL-],  A               ; write sprite Y-position
        ;-----------------------------------------------------------------------
        ; top-middle:
        ;-----------------------------------------------------------------------
        ld      [HL],   %00000000       ; set sprite display attribute
        dec     L                       ; (move to sprite tile byte)
        ld      A,      SPRITE_CARD_12X2; this one has a fixed sprite tile
        ld      [HL-],  A
        ld      A,      C               ; position this sprite next
        add     A,      8               ; to the previous one
        ld      [HL-],  A               ; write sprite X-position
        ld      A,      B
        ld      [HL-],  A               ; write sprite Y-position
        ;-----------------------------------------------------------------------
        ; top-right: suit
        ;-----------------------------------------------------------------------
        ld      [HL],   %00000000       ; set sprite display attribute
        dec     L
        ld      A,      [DE]            ; retrieve our original card value
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca                            ; x2 tile index due to 8x16 sprites
        add     SPRITE_CARD_12X3        ; offset the tile with the suit
        ld      [HL-],  A
        ld      A,      C               ; position this sprite next
        add     A,      16              ; to the previous one
        ld      [HL-],  A               ; write sprite X-position
        ld      A,      B
        ld      [HL-],  A               ; write sprite Y-position
        ; move to the next row
        add     A,      8
        ld      B,      A

        ;-----------------------------------------------------------------------
        ; read a card value from the pool; if this is the
        ; zero terminator, we've reached the end of the pile
        ;
        inc     DE                      ; move to next card
        ld      A,      [DE]
        and     A,      A               ; (set flags!)
        jr      nz,     @loop           ; keep looping until last card

        ; bottom half of last card:
        ;=======================================================================
        ; since sprites are 8x16, the last card is two sprites high;
        ; move down another 8px to make it 16px below the top half
+       ld      A,      B
        add     A,      8
        ld      B,      A
        ;-----------------------------------------------------------------------
        ; bottom-left: suit
        ;-----------------------------------------------------------------------
        ld      [HL],   %00000000       ; set sprite display attribute
        dec     L
        ld      A,      [temp]          ; retrieve the last card value
        swap    A                       ; move the suit to the bottom nybble
        and     %00000011               ; mask out the other bits
        rlca                            ; x2 tile index due to 8x16 sprites
        add     SPRITE_CARD_34X1        ; offset the tile with the suit
        ld      [HL-],  A
        ld      A,      C
        ld      [HL-],  A               ; write sprite X-position
        ld      A,      B
        ld      [HL-],  A               ; write sprite Y-position
        ;-----------------------------------------------------------------------
        ; bottom-middle:
        ;-----------------------------------------------------------------------
        ld      [HL],   %00000000       ; set sprite display attribute
        dec     L                       ; (move to sprite tile byte)
        ld      A,      SPRITE_CARD_34X2; this one has a fixed sprite tile
        ld      [HL-],  A
        ld      A,      C               ; position this sprite next
        add     A,      8               ; to the previous one
        ld      [HL-],  A               ; write sprite X-position
        ld      A,      B
        ld      [HL-],  A               ; write sprite Y-position
        ;-----------------------------------------------------------------------
        ; bottom-right corner: ordinal
        ;-----------------------------------------------------------------------
        ld      [HL],   %00000000       ; set sprite display attribute
        dec     L                       ; (move to sprite tile byte)
        ld      A,      [temp]          ; retrieve the last card value
        and     %00001111               ; trim out the other bits of card value
        rlca                            ; x2 tile index due to 8x16 sprites
        add     SPRITE_CARD_34X3-2      ; offset the tile with the ordinal
        ld      [HL-],  A               ; set the sprite's tile
        ld      A,      C               ; position this sprite next
        add     A,      16              ; to the previous one
        ld      [HL-],  A               ; write sprite X-position
        ld      A,      B
        ld      [HL-],  A               ; write sprite Y-position

        ;-----------------------------------------------------------------------
        ; because the card being pointed to was removed, we need to move the
        ; cursor (and all the cards now in the cursor's hand) to the card above
        ;
        call    getPointPile            ; get the old pile / card index
        and     A,      A               ; (set flags!)
        jr      z,      +               ; is the pile empty?
        dec     A                       ; if not, move to previous card
+       call    pointToCard             ; tell the cursor to move

        ; redraw the entire tableau; this may seem overkill but the removal
        ; of one card may affect the validation of other piles which would
        ; also need redrawing
        ; TODO: should validation be part of drawing, or a separate routine?
        call    tableau.refresh
        ; compare the display buffers and queue
        ; the changes to be made during vblank
        jp      tilemap.update

        ; cannot pick this pile:
        ;=======================================================================
        ; TODO: we should implement a sound / cursor shake
@err:   ret


dropPile:
;===============================================================================
; drop the cards in the cursor's hand onto the current pile:
;
;-------------------------------------------------------------------------------
        ; TODO: disallow pointing to the inner cards
        ;       of a pile when cursor is holding cards
        ;
        ; remove the cards shown in the cursor's hand!
        call    clearSprites

        ; retrieve current pile being pointed at
        ; into DE, as it's the destination
        ld      HL,     pile_point
        ld      E,      [HL]            ; read pile address, lo-byte
        inc     L
        ld      D,      [HL]            ; read pile address, hi-byte

        ; move the pile of cards in the cursor's hand
        ; on to the top of the pile being pointed at
        ld      HL,     hand_pile
        xor     A                       ; A = 0, move all cards in hand
        call    tableau.movePile

        ; with the pile changed, the cursor needs
        ; to be moved again to the top of the pile
        call    pointToCard

        ; redraw the entire tableau; this may seem overkill but the removal
        ; of one card may affect the validation of other piles which would
        ; also need redrawing
        ; TODO: should validation be part of drawing, or a separate routine?
        call    tableau.refresh
        ; compare the display buffers and queue
        ; the changes to be made during vblank
        jp      tilemap.update