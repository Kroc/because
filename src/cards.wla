; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020-2022:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt
;
; card bytes:
;===============================================================================
; this section defines how we store cards in memory, one byte per card
;
; %bissnnnn     b     = "back" (back is visible)
;               i     = "inactive", 0=active, 1=inactive (unplayable card)
;               ss    = suit, 0-3,  0=spades, 1=clubs, 2=hearts, 3=diamonds
;               nnnn  = number, 1 (A), 2-9, 10 (J), 11 (Q), 12 (K),
;                       13-15 unused. 0 = no-card / null
;
.DEF    CARD_NONE       %00000000

.DEF    CARD_FRONT      %00000000       ; face-up card
.DEF    CARD_BACK       %10000000       ; face-down card

.DEF    CARD_ACTIVE     %00000000       ; card is playable
.DEF    CARD_INACTIVE   %01000000       ; card is disabled

; suits:                %--0----- = black
.DEF    SUIT_SPADE      %00000000
.DEF    SUIT_CLUB       %00010000
;                       %--1----- = red
.DEF    SUIT_HEART      %00100000
.DEF    SUIT_DIAMOND    %00110000

.DEF    CARD_A          %00000001
.DEF    CARD_2          %00000010
.DEF    CARD_3          %00000011
.DEF    CARD_4          %00000100
.DEF    CARD_5          %00000101
.DEF    CARD_6          %00000110
.DEF    CARD_7          %00000111
.DEF    CARD_8          %00001000
.DEF    CARD_9          %00001001
.DEF    CARD_X          %00001010
.DEF    CARD_J          %00001011
.DEF    CARD_Q          %00001100
.DEF    CARD_K          %00001101

; the different kinds of piles:
;
; regardless of the number of cards in a "deck" pile,
; it always displays as one face-down card
.DEF    PILE_DECK       %00000001
; like a "deck", the foundation does not spread,
; but differs by displaying the top card face-up
.DEF    PILE_FOUNDATION %00000010
; a downward spread of cards as you would typically see in Klondike
.DEF    PILE_COLUMN     %00000100

; for piles that spread to the right, instead of down the screen
; this flag can be added to the pile type
.DEF    PILE_HORZ       %10000000
.DEF    PILE_ROW        PILE_COLUMN | PILE_HORZ

.STRUCT Pile
        ;-----------------------------------------------------------------------
        ; we place the limit byte first so that when moving cards around,
        ; we can validate the movement without having to skip over fields
        ; that we will need to come back to
        ;
        type            BYTE    ; type of pile, i.e. deck, hand, foundation &c.
        limit           BYTE    ; max.number of cards allowed in pile
        pool            WORD    ; address of storage for card pile
        row             BYTE    ; row position on the tilemap (not pixels!)
        col             BYTE    ; column position on the tilemap (not pixels!)
        left            BYTE    ; pile to the left of this one (lo-byte)
        right           BYTE    ; pile to the right of this one (lo-byte)
        up              BYTE    ; pile above this one (lo-byte)
        down            BYTE    ; pile below this one (lo-byte)
.ENDST

; define some RAM to hold cards during a game:
;
.RAMSECTION \
        "table"         ALIGN 256 RETURNORG
        ;-----------------------------------------------------------------------
        ; a deck, where cards are drawn from
        deck            INSTANCEOF Pile
        ; a "discard" pile, where cards are thrown away
        discard         INSTANCEOF Pile
        ; a "hand" for cards to be played, e.g. three-card-draw
        hand            INSTANCEOF Pile
        ; up to four foundation piles, where cards are stacked in order
        foundation1     INSTANCEOF Pile
        foundation2     INSTANCEOF Pile
        foundation3     INSTANCEOF Pile
        foundation4     INSTANCEOF Pile
        ; up to eight tableau piles, where cards are sorted
        tableau1        INSTANCEOF Pile
        tableau2        INSTANCEOF Pile
        tableau3        INSTANCEOF Pile
        tableau4        INSTANCEOF Pile
        tableau5        INSTANCEOF Pile
        tableau6        INSTANCEOF Pile
        tableau7        INSTANCEOF Pile
        tableau8        INSTANCEOF Pile
        ; TODO: the above must not exceed 256 bytes
        ;       why can we not set size limits for RAMSECTIONs?
        
        storage         DSB 1024
.ENDS

.DEF    __pool_addr     cards.storage

; use this macro before defining a set of piles in ROM
; in order to reset the starting pool address
;
.MACRO  BeginPiles
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
.REDEF  __pool_addr     cards.storage
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM

; this macro simplifies writing a pre-defined Pile of cards into ROM
;
.MACRO  DefinePile
;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

.DSTRUCT \1 INSTANCEOF Pile VALUES
        type:           .BYTE   \2
        limit:          .BYTE   \3
        pool:           .WORD   __pool_addr
        row:            .BYTE   \4
        col:            .BYTE   \5
        left:           .BYTE   <\6
        right:          .BYTE   <\7
        up:             .BYTE   <\8
        down:           .BYTE   <\9
.ENDST

.REDEF  __pool_addr     __pool_addr+\3+1

;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
.ENDM


clear:
;===============================================================================
; clear all piles, card storage:
;
; out:  DE      first address of the card storage pool
;       BC, A   set to zero, by nature of looping
;       HL      (clobbered)
;-------------------------------------------------------------------------------
        ld      HL,     SECTIONSTART_cards.table
        ld      BC,     (SECTIONEND_cards.table - SECTIONSTART_cards.table)+1
        call    zero
        
        ; return the starting address of the card pool
        ; (used for allocating piles)
        ld      DE,     storage
        ret


allocateDeck:
;===============================================================================
; allocates the deck: (this is always 52 cards in size)
; the deck is populated with cards, but not shuffled
;
; in:   BC      address to a Pile structure (in ROM) to copy from
;-------------------------------------------------------------------------------
        ; HL    address of Pile structure (`deck`)
        ; BC    address of template Pile in ROM
        ld      HL,     deck
        call    allocatePile

        push    BC                      ; preserve B & C

        ; fill the deck with cards:
        ;-----------------------------------------------------------------------
        ; C will be our suit counter; 0=spades, 1=clubs, 2=hearts, 3=diamonds
        ld      C,      0

@next:  ld      B,      1               ; B = our ordinal counter, 1 to 13
-       ld      A,      C               ; begin with the suit 0-3
        swap    A                       ; suit bits go in the upper nybble
        or      B                       ; add the ordinal (1-13)
        or      CARD_BACK               ; flip the card over!
        ld      [DE],   A               ; store card and move to next slot
        inc     DE

        inc     B                       ; move to the next ordinal
        ld      A,      B               ; (need to use A for comparison)
        cp      CARD_K                  ; have we gone past the king?
        jr      nc,     -               ; no, continue adding cards

        inc     C                       ; move to the next suit
        bit     3,      C               ; have we hit 4?
        jr      z,      @next           ; no, do next suit

        ;-----------------------------------------------------------------------
        pop     BC                      ; restore B & C
        ret


allocatePile:
;===============================================================================
; allocates a pile where cards will be stored:
; e.g. a deck, hand, foundation or tableau, etc.
;
; in:   HL      address of the working Pile structure in RAM;
;               this consists of a set of properties that will be filled out
;
;       BC      address of the template Pile structure (in ROM) to copy
;
; out:  HL      the structure address is moved forward over the Pile
;               structure. useful if you are allocating multiple piles
;               that directly follow each other in RAM
;
;       DE      address of the card pool for the pile, i.e. where the "cards",
;               each a byte, will be stored. this area will already have been
;               cleared according to the limit set in the template Pile
;
;       AF      (clobbered)
;-------------------------------------------------------------------------------
        ; copy the Pile template (in ROM) over the working Pile in RAM:
        ;
        ; first byte is the type of the Pile
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; next byte is maximum number of cards in the pile
        ld      A,      [BC]
        ld      [HL+],  A               ; move HL (RAM) forward
        inc     C                       ; move BC (ROM) forward
        ; put this aside until we clear the Pile's card pool
        push    AF

        ; next two bytes are the storage address;
        ; we put this aside in DE for later
        ld      A,      [BC]
        ld      E,      A               ; lo-byte first
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]
        ld      D,      A               ; hi-byte next
        ld      [HL+],  A
        inc     C

        ; next is the row/column position on the tilemap
        ld      A,      [BC]            ; read row (Y) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C
        ld      A,      [BC]            ; read column (X) from ROM
        ld      [HL+],  A               ; write to RAM
        inc     C

        ; positional data:
        ld      A,      [BC]            ; pile left
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile right
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile top
        ld      [HL+],  A
        inc     C
        ld      A,      [BC]            ; pile down
        ld      [HL+],  A
        inc     C

        ; clear the allocated card storage:
        ;-----------------------------------------------------------------------
        pop     AF                      ; retrieve max. card count
        push    BC                      ; preserve ROM address
        push    DE                      ; keep original pool address

        ld      B,      A               ; copy card-limit to counter
        inc     B                       ; first byte is number of cards...
        xor     A                       ; ...in the pile, i.e. zero

-       ld      [DE],   A               ; clear one byte
        inc     DE                      ; move to the next byte
        dec     B                       ; one less byte to fill
        jr      nz, -                   ; have we done all of them?

        pop     DE                      ; restore original pool address
        pop     BC                      ; restore current ROM address
        
        ret


addCard:
;===============================================================================
; add a card to a pile:
;
; in:   A       card to add (see CARD_* constants)
;       HL      address to the Pile structure, *not* the Pile's storage
;
; out:  HL      preserved, to allow adding multiple cards in row
;       carry   if the pile is full (card cannot be added), carry will be set
;       A, BC   (clobbered)
;-------------------------------------------------------------------------------
        push    HL                      ; preserve original HL for return
        ld      B,      A               ; put aside card to add for later

        ; read the max. number of cards allowed in the pile:
        ;
        ; NOTE: we can get away with only incrementing L because the piles
        ;       begin at an $xx00 address and don't exceed 256 bytes
        inc     L                       ; (2nd byte in Pile struct)
        ld      C,      [HL]
        inc     L
        ; read the storage address:
        ld      E,      [HL]            ; lo-byte first
        inc     L
        ld      D,      [HL]            ; then hi-byte

        ; from that, read the first byte of the card pool
        ; (the number of cards in the pile)
        ld      A,      [DE]
        ; compare number of cards in pile, with max (1-based)
        cp      C
        jr      nc,      @full

        ; add card:
        ;-----------------------------------------------------------------------
@add:   inc     A                       ; increase number of cards in pile
        ld      [DE],   A               ; write back updated card count
        
        ; move to the empty-slot at the end of the pile
        add     A,      E               ; add number of cards to pile addr.
        jr      nc,     +               ; E overflows?
        inc     D                       ; ripple to D
+       ld      E,      A

        ld      A,      B               ; retrieve card to add
        ld      [DE],   A               ; write to pile
        
        scf
        ccf

        pop     HL                      ; return original HL
        ret

        ; pile is full!
        ;-----------------------------------------------------------------------
@full:  scf

        ld      B,      B               ; DEBUG

        pop     HL                      ; return original HL
        ret


getPilePool:
;===============================================================================
; given a Pile struct address, returns the address
; in the card pool where the pile's cards are stored
;
; in:   HL      address of a Pile structure (e.g. deck, tableau)
; out:  DE      address of the pile's card pool
;       HL, A   (preserved)
;-------------------------------------------------------------------------------
        push    HL

        inc     L               ; skip the `type` field
        inc     L               ; skip the `limit` field
        ld      E,      [HL]    ; read the pool address, lo-byte
        inc     L
        ld      D,      [HL]    ; read the pool address, hi-byte

        pop     HL
        ret


getPilePos:
;===============================================================================
; retrieve the row & column co-ordinates (on the tile-map) of a pile:
; these are tile co-ordinates, NOT pixels!
;
; in:   HL      address of the Pile structure
;               (NOT the pile pool address)
;
; out:  B       row number of the pile on the tile-map
;       C       column number of the pile on-screen
;               (note that these two disregard scroll position!)
;
;       HL, DE  (preserved)
;       A       (preserved)
;-------------------------------------------------------------------------------
        ; this routine merely returns the X & Y tile co-ordinates stored
        ; in the Pile structure. the lack of index registers on the SM83
        ; is excruciating...
        ;
        push    HL

        ld      B,      0
        ld      C,      Pile.row
        add     HL,     BC
        
        ld      B,      [HL]
        inc     L
        ld      C,      [HL]
        
        pop     HL
        ret