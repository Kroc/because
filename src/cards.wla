; impatience <github.com/kroc/impatience> copyright (c) Kroc Camen 2020:
; creative commons attribution (cc-by) 4.0, see LICENSE.txt

; card bytes:
;===============================================================================
; this section defines how we store cards in memory, one byte per card
;
; %bissnnnn	b     = "back" (back is visible)
;               i     = "inactive", 0=active, 1=inactive (unplayable card)
;		ss    = suit, 0-3,  0=spades, 1=clubs, 2=hearts, 3=diamonds
;		nnnn  = number, 1 (A), 2-9, 10 (J), 11 (Q), 12 (K),
;			13-15 unused. 0 = no-card / null
;
.DEF	CARD_NONE	%00000000

.DEF    CARD_FRONT      %00000000
.DEF	CARD_BACK	%10000000

.DEF    CARD_ACTIVE     %00000000       ; card is playable
.DEF    CARD_INACTIVE   %01000000       ; card is disabled

.DEF    CARD_PLACE      %11111111       ; a card placeholder, e.g. a foundation

; suits:                %--0----- = black
.DEF	SUIT_SPADE	%00000000
.DEF	SUIT_CLUB	%00010000
;                       %--1----- = red
.DEF	SUIT_HEART	%00100000
.DEF	SUIT_DIAMOND	%00110000

.DEF	CARD_A		%00000001
.DEF	CARD_2		%00000010
.DEF	CARD_3		%00000011
.DEF	CARD_4		%00000100
.DEF	CARD_5		%00000101
.DEF	CARD_6		%00000110
.DEF	CARD_7		%00000111
.DEF	CARD_8		%00001000
.DEF	CARD_9 		%00001001
.DEF	CARD_X		%00001010
.DEF	CARD_J		%00001011
.DEF	CARD_Q		%00001100
.DEF	CARD_K		%00001101

.STRUCT "Pile"
        ;-----------------------------------------------------------------------
        ; we place the limit byte first so that when moving cards around,
        ; we can validate the movement without having to skip over fields
        ; that we will need to come back to
        ;
        limit           BYTE    ; max.number of cards allowed in pile
        addr            WORD    ; address of storage for card pile
        x               BYTE    ; X-position on screen
        y               BYTE    ; Y-position on screen
.ENDST

; define some RAM to hold cards during a game:
;
.RAMSECTION     "table" ALIGN 256       RETURNORG
        ;-----------------------------------------------------------------------
        ; a deck, where cards are drawn from
        deck            INSTANCEOF Pile
        ; a "discard" pile, where cards are thrown away
        discard         INSTANCEOF Pile
        ; a "hand" for cards to be played, e.g. three-card-draw
        hand            INSTANCEOF Pile
        ; up to four foundation piles, where cards are stacked in order
        foundation1     INSTANCEOF Pile
        foundation2     INSTANCEOF Pile
        foundation3     INSTANCEOF Pile
        foundation4     INSTANCEOF Pile
        ; up to eight tableau piles, where cards are sorted
        tableau1        INSTANCEOF Pile
        tableau2        INSTANCEOF Pile
        tableau3        INSTANCEOF Pile
        tableau4        INSTANCEOF Pile
        tableau5        INSTANCEOF Pile
        tableau6        INSTANCEOF Pile
        tableau7        INSTANCEOF Pile
        tableau8        INSTANCEOF Pile

        storage         DSB 1024
.ENDS

.CODE

clear:
;===============================================================================
; clear all piles, card storage:
;
; out:  DE      first address of the card storage pool
;       A, BC   set to zero, by nature of looping
;       HL      (clobbered)
;-------------------------------------------------------------------------------
        ld      HL,     SECTIONSTART_cards.table
        ld      BC,     (SECTIONEND_cards.table - SECTIONSTART_cards.table)+1
        xor     A                       ; (set A to zero)
-       ld      [HL+],  A               ; clear a byte
        
        ; watch out! 16-bit decrement doesn't set flags!
        dec     C
        jr      nz,     -
        dec     B
        jr      nz,     -
        
        ; return the starting address of the card pool
        ; (used for allocating piles)
        ld      DE,     storage
        ret


alloc_deck:
;===============================================================================
; allocates the deck: (this is always 52 cards in size)
; the deck is populated with cards, but not shuffled
;
; in:   B       row (Y) of the pile on the tilemap
;       C       column (X) of the pile on the tilemap
;
;       DE      address to set as the data-store for the pile,
;               i.e. where the "cards", each a byte, will be stored
;-------------------------------------------------------------------------------
        ld      HL,     deck            ; address of deck structure
        ld      A,      52              ; size-limit of deck

        ; backup our starting storage address because after
        ; allocating we want to go back and populate the deck
        push    DE

        ; HL    address of pile structure (`deck`)
        ; DE    address in storage pool
        ; BC    row & column to draw the deck
        ;  A    number of cards in deck
        ;
        call    alloc_pile

        pop     DE                      ; return to starting storage address
        push    BC                      ; preserve B & C

        ; fill the deck with cards:
        ;-----------------------------------------------------------------------
        ; C will be our suit counter; 0=spades, 1=clubs, 2=hearts, 3=diamonds
        ld      C,      0

@next:  ld      B,      1               ; B = our ordinal counter, 1 to 13
-       ld      A,      C               ; begin with the suit 0-3
        swap    A                       ; suit bits go in the upper nybble
        or      B                       ; add the ordinal (1-13)
        or      CARD_BACK               ; flip the card over!
        ld      [DE],   A               ; store card and move to next slot
        inc     DE

        inc     B                       ; move to the next ordinal
        ld      A,      B               ; (need to use A for comparison)
        cp      13                      ; have we gone past the king?
        jr      nc,     -               ; no, continue adding cards

        inc     C                       ; move to the next suit
        bit     3,      C               ; have we hit 4?
        jr      z,      @next           ; no, do next suit

        ;-----------------------------------------------------------------------
        pop     BC                      ; restore original B & C
        ld      A,      52              ; preserve size-limit of deck
        ret


alloc_pile:
;===============================================================================
; allocates a pile where cards will be stored:
; e.g. a deck, hand, foundation or tableau, etc.
;
; in:   A       maximum size (the limit) of the pile,
;               i.e. how many cards the pile can hold
;
;       HL      address of the `Pile` structure;
;               this consists of a set of properties that will be filled out
;
;       DE      address to set as the data-store for the pile,
;               i.e. where the "cards", each a byte, will be stored
;               this area will be cleared, according to the limit set
;
;       B       y-position of the pile on-screen
;       C       x-position of the pile on-screen
;
; out:  HL      the structure address is moved forward over the `Pile`
;               structure. useful if you are allocating multiple piles
;               that directly follow each other in RAM
;
;       DE      the storage address is moved forward by the pile-size
;               allocated. this is so that you can allocate one pile
;               after another
;
;       AF, BC  (preserved)
;-------------------------------------------------------------------------------
        push    AF                      ; preserve the A-register

        ; the first byte is the number of bytes reserved for storage
        ld      [HL+],  A

        ; the next two bytes are the address to the card-storage:
        ; (note that we can get away with only incrementing L
        ;  as the pile structures all fit within 256 bytes)
        ld      [HL],   E
        inc     L
        ld      [HL],   D
        inc     L

        ; next is the row/column position on the tilemap
        ; (these are separate byte fields, so not little-endian order)
        ld      [HL],   B               ; write row (Y)
        inc     L
        ld      [HL],   C               ; write column (X)
        inc     L

        ; clear the allocated card storage
        ;-----------------------------------------------------------------------
        push    BC                      ; (preserve B & C registers)

        ld      B,      A               ; card-limit to counter
        inc     B                       ; (account for 1-based count)
        xor     A                       ; "fill" the pile with empty-slots
-       ld      [DE],   A               ; clear one byte
        inc     DE                      ; move to the next byte
        dec     B                       ; one less byte to fill
        jr      nz, -                   ; have we done all of them?

        pop     BC                      ; restore original B & C registers
        pop     AF                      ; restore original A register
        ret


draw_deck:
;===============================================================================
; draws the deck on the back-buffer:
;
;-------------------------------------------------------------------------------
        ld      HL,     deck.addr       ; address of deck pile
        ld      E,      [HL]            ; read cards-address, lo-byte
        inc     L
        ld      D,      [HL]            ; read cards-address, hi-byte
        inc     L
        ld      B,      [HL]            ; read row
        inc     L
        ld      C,      [HL]            ; read column

        ; draw deck:
        ;-----------------------------------------------------------------------
        ; TODO: check if the deck is full or empty
        ;
        ; get an address in the front-buffer for the X/Y co-ords
        dec     B
        call    gfx.get_buffer_addr

        ; TODO: we should store this as a data-stream
        ld      BC,     32-3
        ld      A,      TILE3X4_DECK_0X1
        ld      [HL+],  A 
        inc     A       ;=TILE3X4_DECK_1X2
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_1X3
        ld      [HL+],  A
        add     HL,     BC              ; move to next tilemap row

        ld      A,      TILE3X4_DECK_1X1
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_2X2
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_2X3
        ld      [HL+],  A
        add     HL,     BC              ; move to next tilemap row
        
        ld      A,      TILE3X4_DECK_2X1
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_3X2
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_3X3
        ld      [HL+],  A
        add     HL,     BC              ; move to next tilemap row
        
        ld      A,      TILE3X4_DECK_3X1
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_4X2
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_4X3
        ld      [HL+],  A
        add     HL,     BC              ; move to next tilemap row

        ld      A,      TILE3X4_DECK_4X1
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_5X2
        ld      [HL+],  A
        inc     A       ;=TILE3X4_DECK_5X3
        ld      [HL+],  A

        ret